// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: greenlight.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Greenlight_NetAddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ipv4 // = 0
  case ipv6 // = 1
  case torV2 // = 2
  case torV3 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .ipv4
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ipv4
    case 1: self = .ipv6
    case 2: self = .torV2
    case 3: self = .torV3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ipv4: return 0
    case .ipv6: return 1
    case .torV2: return 2
    case .torV3: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_NetAddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_NetAddressType] = [
    .ipv4,
    .ipv6,
    .torV2,
    .torV3,
  ]
}

#endif  // swift(>=4.2)

enum Greenlight_BtcAddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Default
  case bech32 // = 0
  case p2ShSegwit // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .bech32
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bech32
    case 1: self = .p2ShSegwit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bech32: return 0
    case .p2ShSegwit: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_BtcAddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_BtcAddressType] = [
    .bech32,
    .p2ShSegwit,
  ]
}

#endif  // swift(>=4.2)

enum Greenlight_OutputStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case confirmed // = 0
  case unconfirmed // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .confirmed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .confirmed
    case 1: self = .unconfirmed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .confirmed: return 0
    case .unconfirmed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_OutputStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_OutputStatus] = [
    .confirmed,
    .unconfirmed,
  ]
}

#endif  // swift(>=4.2)

/// Let the node decide what feerate to apply based on its internal
/// view of the network's current feerate.
enum Greenlight_FeeratePreset: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case slow // = 1
  case urgent // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .slow
    case 2: self = .urgent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .slow: return 1
    case .urgent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_FeeratePreset: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_FeeratePreset] = [
    .normal,
    .slow,
    .urgent,
  ]
}

#endif  // swift(>=4.2)

enum Greenlight_CloseChannelType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mutual // = 0
  case unilateral // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .mutual
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mutual
    case 1: self = .unilateral
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mutual: return 0
    case .unilateral: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_CloseChannelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_CloseChannelType] = [
    .mutual,
    .unilateral,
  ]
}

#endif  // swift(>=4.2)

enum Greenlight_InvoiceStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unpaid // = 0
  case paid // = 1
  case expired // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unpaid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unpaid
    case 1: self = .paid
    case 2: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unpaid: return 0
    case .paid: return 1
    case .expired: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_InvoiceStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_InvoiceStatus] = [
    .unpaid,
    .paid,
    .expired,
  ]
}

#endif  // swift(>=4.2)

enum Greenlight_PayStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pending // = 0
  case complete // = 1
  case failed // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .complete
    case 2: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .complete: return 1
    case .failed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Greenlight_PayStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Greenlight_PayStatus] = [
    .pending,
    .complete,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Greenlight_HsmRequestContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var dbid: UInt64 = 0

  var capabilities: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_HsmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var raw: Data = Data()

  /// A list of updated key-value-version tuples that is to be
  /// merged into the state tracked by the plugin.
  var signerState: [Greenlight_SignerStateEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_HsmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var context: Greenlight_HsmRequestContext {
    get {return _context ?? Greenlight_HsmRequestContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var raw: Data = Data()

  /// A list of key-value-version tuples that the signer should
  /// use to update its internal state.
  var signerState: [Greenlight_SignerStateEntry] = []

  /// Currently active requests that are used to justify changes
  /// in state.
  var requests: [Greenlight_PendingRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _context: Greenlight_HsmRequestContext? = nil
}

struct Greenlight_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Greenlight_NetAddressType = .ipv4

  var addr: String = String()

  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_GetInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_GetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var alias: String = String()

  var color: Data = Data()

  var numPeers: UInt32 = 0

  var addresses: [Greenlight_Address] = []

  var version: String = String()

  var blockheight: UInt32 = 0

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_StopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_StopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: String = String()

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: String = String()

  var features: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ListPeersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Htlc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var direction: String = String()

  var id: UInt64 = 0

  var amount: String = String()

  var expiry: UInt64 = 0

  var paymentHash: String = String()

  var state: String = String()

  var localTrimmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Aliases {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var local: String = String()

  var remote: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  var alias: Greenlight_Aliases {
    get {return _storage._alias ?? Greenlight_Aliases()}
    set {_uniqueStorage()._alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return _storage._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {_uniqueStorage()._alias = nil}

  var shortChannelID: String {
    get {return _storage._shortChannelID}
    set {_uniqueStorage()._shortChannelID = newValue}
  }

  var direction: UInt32 {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  var fundingTxid: String {
    get {return _storage._fundingTxid}
    set {_uniqueStorage()._fundingTxid = newValue}
  }

  var closeToAddr: String {
    get {return _storage._closeToAddr}
    set {_uniqueStorage()._closeToAddr = newValue}
  }

  var closeTo: String {
    get {return _storage._closeTo}
    set {_uniqueStorage()._closeTo = newValue}
  }

  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  var total: String {
    get {return _storage._total}
    set {_uniqueStorage()._total = newValue}
  }

  var dustLimit: String {
    get {return _storage._dustLimit}
    set {_uniqueStorage()._dustLimit = newValue}
  }

  var spendable: String {
    get {return _storage._spendable}
    set {_uniqueStorage()._spendable = newValue}
  }

  var receivable: String {
    get {return _storage._receivable}
    set {_uniqueStorage()._receivable = newValue}
  }

  var theirToSelfDelay: UInt32 {
    get {return _storage._theirToSelfDelay}
    set {_uniqueStorage()._theirToSelfDelay = newValue}
  }

  var ourToSelfDelay: UInt32 {
    get {return _storage._ourToSelfDelay}
    set {_uniqueStorage()._ourToSelfDelay = newValue}
  }

  var status: [String] {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var htlcs: [Greenlight_Htlc] {
    get {return _storage._htlcs}
    set {_uniqueStorage()._htlcs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Greenlight_Peer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var connected: Bool = false

  var addresses: [Greenlight_Address] = []

  var features: String = String()

  var channels: [Greenlight_Channel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ListPeersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peers: [Greenlight_Peer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: String = String()

  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_DisconnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_NewAddrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addressType: Greenlight_BtcAddressType = .bech32

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_NewAddrResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addressType: Greenlight_BtcAddressType = .bech32

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ListFundsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minconf: Greenlight_Confirmation {
    get {return _minconf ?? Greenlight_Confirmation()}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minconf: Greenlight_Confirmation? = nil
}

struct Greenlight_ListFundsOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Greenlight_Outpoint {
    get {return _output ?? Greenlight_Outpoint()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var address: String = String()

  var status: Greenlight_OutputStatus = .confirmed

  var reserved: Bool = false

  var reservedToBlock: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _output: Greenlight_Outpoint? = nil
  fileprivate var _amount: Greenlight_Amount? = nil
}

struct Greenlight_ListFundsChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data = Data()

  var connected: Bool = false

  var shortChannelID: UInt64 = 0

  var ourAmountMsat: UInt64 = 0

  var amountMsat: UInt64 = 0

  var fundingTxid: Data = Data()

  var fundingOutput: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ListFundsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outputs: [Greenlight_ListFundsOutput] = []

  var channels: [Greenlight_ListFundsChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Feerate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Greenlight_Feerate.OneOf_Value? = nil

  var preset: Greenlight_FeeratePreset {
    get {
      if case .preset(let v)? = value {return v}
      return .normal
    }
    set {value = .preset(newValue)}
  }

  var perkw: UInt64 {
    get {
      if case .perkw(let v)? = value {return v}
      return 0
    }
    set {value = .perkw(newValue)}
  }

  var perkb: UInt64 {
    get {
      if case .perkb(let v)? = value {return v}
      return 0
    }
    set {value = .perkb(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case preset(Greenlight_FeeratePreset)
    case perkw(UInt64)
    case perkb(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: Greenlight_Feerate.OneOf_Value, rhs: Greenlight_Feerate.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.preset, .preset): return {
        guard case .preset(let l) = lhs, case .preset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.perkw, .perkw): return {
        guard case .perkw(let l) = lhs, case .perkw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.perkb, .perkb): return {
        guard case .perkb(let l) = lhs, case .perkb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Greenlight_Confirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blocks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_WithdrawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String = String()

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var feerate: Greenlight_Feerate {
    get {return _feerate ?? Greenlight_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var minconf: Greenlight_Confirmation {
    get {return _minconf ?? Greenlight_Confirmation()}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var utxos: [Greenlight_Outpoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
  fileprivate var _feerate: Greenlight_Feerate? = nil
  fileprivate var _minconf: Greenlight_Confirmation? = nil
}

struct Greenlight_WithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_FundChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var feerate: Greenlight_Feerate {
    get {return _feerate ?? Greenlight_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var announce: Bool = false

  var minconf: Greenlight_Confirmation {
    get {return _minconf ?? Greenlight_Confirmation()}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  ///TODO Maybe add UTXOS
  var closeTo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
  fileprivate var _feerate: Greenlight_Feerate? = nil
  fileprivate var _minconf: Greenlight_Confirmation? = nil
}

struct Greenlight_Outpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var outnum: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_FundChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var outpoint: Greenlight_Outpoint {
    get {return _outpoint ?? Greenlight_Outpoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var channelID: Data = Data()

  var closeTo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Greenlight_Outpoint? = nil
}

struct Greenlight_Timeout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seconds: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_BitcoinAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_CloseChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var unilateraltimeout: Greenlight_Timeout {
    get {return _unilateraltimeout ?? Greenlight_Timeout()}
    set {_unilateraltimeout = newValue}
  }
  /// Returns true if `unilateraltimeout` has been explicitly set.
  var hasUnilateraltimeout: Bool {return self._unilateraltimeout != nil}
  /// Clears the value of `unilateraltimeout`. Subsequent reads from it will return its default value.
  mutating func clearUnilateraltimeout() {self._unilateraltimeout = nil}

  var destination: Greenlight_BitcoinAddress {
    get {return _destination ?? Greenlight_BitcoinAddress()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unilateraltimeout: Greenlight_Timeout? = nil
  fileprivate var _destination: Greenlight_BitcoinAddress? = nil
}

struct Greenlight_CloseChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closeType: Greenlight_CloseChannelType = .mutual

  var tx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Amount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unit: Greenlight_Amount.OneOf_Unit? = nil

  var millisatoshi: UInt64 {
    get {
      if case .millisatoshi(let v)? = unit {return v}
      return 0
    }
    set {unit = .millisatoshi(newValue)}
  }

  var satoshi: UInt64 {
    get {
      if case .satoshi(let v)? = unit {return v}
      return 0
    }
    set {unit = .satoshi(newValue)}
  }

  var bitcoin: UInt64 {
    get {
      if case .bitcoin(let v)? = unit {return v}
      return 0
    }
    set {unit = .bitcoin(newValue)}
  }

  var all: Bool {
    get {
      if case .all(let v)? = unit {return v}
      return false
    }
    set {unit = .all(newValue)}
  }

  var any: Bool {
    get {
      if case .any(let v)? = unit {return v}
      return false
    }
    set {unit = .any(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Unit: Equatable {
    case millisatoshi(UInt64)
    case satoshi(UInt64)
    case bitcoin(UInt64)
    case all(Bool)
    case any(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: Greenlight_Amount.OneOf_Unit, rhs: Greenlight_Amount.OneOf_Unit) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.millisatoshi, .millisatoshi): return {
        guard case .millisatoshi(let l) = lhs, case .millisatoshi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.satoshi, .satoshi): return {
        guard case .satoshi(let l) = lhs, case .satoshi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bitcoin, .bitcoin): return {
        guard case .bitcoin(let l) = lhs, case .bitcoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Greenlight_InvoiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var label: String = String()

  var description_p: String = String()

  var preimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
}

struct Greenlight_Invoice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var description_p: String = String()

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var received: Greenlight_Amount {
    get {return _received ?? Greenlight_Amount()}
    set {_received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  var hasReceived: Bool {return self._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  mutating func clearReceived() {self._received = nil}

  var status: Greenlight_InvoiceStatus = .unpaid

  var paymentTime: UInt32 = 0

  var expiryTime: UInt32 = 0

  var bolt11: String = String()

  var paymentHash: Data = Data()

  var paymentPreimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
  fileprivate var _received: Greenlight_Amount? = nil
}

struct Greenlight_PayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String = String()

  /// Only needed when the invoice does not specify an amount.
  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// Non-zero number of seconds before we should stop retrying
  /// the payment and return an error.
  var timeout: UInt32 = 0

  var maxfeepercent: Double = 0

  var maxfee: Greenlight_Amount {
    get {return _maxfee ?? Greenlight_Amount()}
    set {_maxfee = newValue}
  }
  /// Returns true if `maxfee` has been explicitly set.
  var hasMaxfee: Bool {return self._maxfee != nil}
  /// Clears the value of `maxfee`. Subsequent reads from it will return its default value.
  mutating func clearMaxfee() {self._maxfee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
  fileprivate var _maxfee: Greenlight_Amount? = nil
}

struct Greenlight_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: Data = Data()

  var paymentHash: Data = Data()

  var paymentPreimage: Data = Data()

  var status: Greenlight_PayStatus = .pending

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var amountSent: Greenlight_Amount {
    get {return _amountSent ?? Greenlight_Amount()}
    set {_amountSent = newValue}
  }
  /// Returns true if `amountSent` has been explicitly set.
  var hasAmountSent: Bool {return self._amountSent != nil}
  /// Clears the value of `amountSent`. Subsequent reads from it will return its default value.
  mutating func clearAmountSent() {self._amountSent = nil}

  var bolt11: String = String()

  /// UTC Unix timestamp of the time the invoice was created.
  var createdAt: Double = 0

  /// UTC Unix timestamp of the time the payment was completed
  /// (successfully or failed). 0 if not completed yet.
  var completedAt: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
  fileprivate var _amountSent: Greenlight_Amount? = nil
}

/// A payment identifier is a way to reference a unique payment, either
/// by its bolt11 string or just the payment hash. Only one of the two
/// may be provided at once, since having multiple ones may conflict
/// with each other.
struct Greenlight_PaymentIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Greenlight_PaymentIdentifier.OneOf_ID? = nil

  var bolt11: String {
    get {
      if case .bolt11(let v)? = id {return v}
      return String()
    }
    set {id = .bolt11(newValue)}
  }

  var paymentHash: Data {
    get {
      if case .paymentHash(let v)? = id {return v}
      return Data()
    }
    set {id = .paymentHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case bolt11(String)
    case paymentHash(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Greenlight_PaymentIdentifier.OneOf_ID, rhs: Greenlight_PaymentIdentifier.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.bolt11, .bolt11): return {
        guard case .bolt11(let l) = lhs, case .bolt11(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentHash, .paymentHash): return {
        guard case .paymentHash(let l) = lhs, case .paymentHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Request a list of payments that this node has performed. Optionally
/// the query can be narrowed to a single payment by providing an
/// identifier.
struct Greenlight_ListPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: Greenlight_PaymentIdentifier {
    get {return _identifier ?? Greenlight_PaymentIdentifier()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: Greenlight_PaymentIdentifier? = nil
}

/// The response matching `ListPaymentRequest`. It returns a list of
/// PayResponses, i.e., the same format as `Pay` returned its result.
struct Greenlight_ListPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payments: [Greenlight_Payment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_InvoiceIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Greenlight_InvoiceIdentifier.OneOf_ID? = nil

  var label: String {
    get {
      if case .label(let v)? = id {return v}
      return String()
    }
    set {id = .label(newValue)}
  }

  var invstring: String {
    get {
      if case .invstring(let v)? = id {return v}
      return String()
    }
    set {id = .invstring(newValue)}
  }

  var paymentHash: Data {
    get {
      if case .paymentHash(let v)? = id {return v}
      return Data()
    }
    set {id = .paymentHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case label(String)
    case invstring(String)
    case paymentHash(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Greenlight_InvoiceIdentifier.OneOf_ID, rhs: Greenlight_InvoiceIdentifier.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.label, .label): return {
        guard case .label(let l) = lhs, case .label(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invstring, .invstring): return {
        guard case .invstring(let l) = lhs, case .invstring(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paymentHash, .paymentHash): return {
        guard case .paymentHash(let l) = lhs, case .paymentHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Greenlight_ListInvoicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: Greenlight_InvoiceIdentifier {
    get {return _identifier ?? Greenlight_InvoiceIdentifier()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: Greenlight_InvoiceIdentifier? = nil
}

/// Options to stream_incoming to specify what to stream.
struct Greenlight_StreamIncomingFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_ListInvoicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invoices: [Greenlight_Invoice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_TlvField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: UInt64 = 0

  /// length is implied since the value field carries its own
  /// length here.
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_OffChainPayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var preimage: Data = Data()

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var extratlvs: [Greenlight_TlvField] = []

  var paymentHash: Data = Data()

  var bolt11: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
}

struct Greenlight_IncomingPayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var details: Greenlight_IncomingPayment.OneOf_Details? = nil

  var offchain: Greenlight_OffChainPayment {
    get {
      if case .offchain(let v)? = details {return v}
      return Greenlight_OffChainPayment()
    }
    set {details = .offchain(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Details: Equatable {
    case offchain(Greenlight_OffChainPayment)

  #if !swift(>=4.1)
    static func ==(lhs: Greenlight_IncomingPayment.OneOf_Details, rhs: Greenlight_IncomingPayment.OneOf_Details) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.offchain, .offchain): return {
        guard case .offchain(let l) = lhs, case .offchain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// A single hop in a Routehint
struct Greenlight_RoutehintHop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var shortChannelID: String = String()

  var feeBase: UInt64 = 0

  var feeProp: UInt32 = 0

  var cltvExpiryDelta: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Routehint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hops: [Greenlight_RoutehintHop] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_KeysendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var amount: Greenlight_Amount {
    get {return _amount ?? Greenlight_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var label: String = String()

  var routehints: [Greenlight_Routehint] = []

  var extratlvs: [Greenlight_TlvField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Greenlight_Amount? = nil
}

struct Greenlight_StreamLogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_LogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var line: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_SignerStateEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt64 = 0

  var key: String = String()

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This represents a grpc request that is currently pending, along
/// with the pubkey of the client issuing the request and a matching
/// signature. This allows the signer to verify that the state changes
/// implied in a signature request correspond to authentic grpc
/// commands, and were not injected somewhere along the way.
struct Greenlight_PendingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Data = Data()

  var uri: String = String()

  var signature: Data = Data()

  var pubkey: Data = Data()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The `NodeConfig` is used to pass startup parameters to the
/// node. The `gl-plugin` will look for a file in its directory to load
/// these values from. Please refer to the individual fields to learn
/// what they do.
struct Greenlight_NodeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// In order to start without a signer attached we need to
  /// stash a couple of canned messages that we'd otherwise ask
  /// from the signer. These are just request-response tuples
  /// that we use to match and reply against incoming requests.
  var startupmsgs: [Greenlight_StartupMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A message that we know will be requested by `lightningd` at
/// startup, and that we stash a response to on the scheduler. This
/// allows the scheduler to start a node without requiring the signer
/// to connect first. Messages are stored in full, including type
/// prefix, but without the length prefix.
struct Greenlight_StartupMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Data = Data()

  var response: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_StreamCustommsgRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Greenlight_Custommsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data = Data()

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Greenlight_NetAddressType: @unchecked Sendable {}
extension Greenlight_BtcAddressType: @unchecked Sendable {}
extension Greenlight_OutputStatus: @unchecked Sendable {}
extension Greenlight_FeeratePreset: @unchecked Sendable {}
extension Greenlight_CloseChannelType: @unchecked Sendable {}
extension Greenlight_InvoiceStatus: @unchecked Sendable {}
extension Greenlight_PayStatus: @unchecked Sendable {}
extension Greenlight_HsmRequestContext: @unchecked Sendable {}
extension Greenlight_HsmResponse: @unchecked Sendable {}
extension Greenlight_HsmRequest: @unchecked Sendable {}
extension Greenlight_Empty: @unchecked Sendable {}
extension Greenlight_Address: @unchecked Sendable {}
extension Greenlight_GetInfoRequest: @unchecked Sendable {}
extension Greenlight_GetInfoResponse: @unchecked Sendable {}
extension Greenlight_StopRequest: @unchecked Sendable {}
extension Greenlight_StopResponse: @unchecked Sendable {}
extension Greenlight_ConnectRequest: @unchecked Sendable {}
extension Greenlight_ConnectResponse: @unchecked Sendable {}
extension Greenlight_ListPeersRequest: @unchecked Sendable {}
extension Greenlight_Htlc: @unchecked Sendable {}
extension Greenlight_Aliases: @unchecked Sendable {}
extension Greenlight_Channel: @unchecked Sendable {}
extension Greenlight_Peer: @unchecked Sendable {}
extension Greenlight_ListPeersResponse: @unchecked Sendable {}
extension Greenlight_DisconnectRequest: @unchecked Sendable {}
extension Greenlight_DisconnectResponse: @unchecked Sendable {}
extension Greenlight_NewAddrRequest: @unchecked Sendable {}
extension Greenlight_NewAddrResponse: @unchecked Sendable {}
extension Greenlight_ListFundsRequest: @unchecked Sendable {}
extension Greenlight_ListFundsOutput: @unchecked Sendable {}
extension Greenlight_ListFundsChannel: @unchecked Sendable {}
extension Greenlight_ListFundsResponse: @unchecked Sendable {}
extension Greenlight_Feerate: @unchecked Sendable {}
extension Greenlight_Feerate.OneOf_Value: @unchecked Sendable {}
extension Greenlight_Confirmation: @unchecked Sendable {}
extension Greenlight_WithdrawRequest: @unchecked Sendable {}
extension Greenlight_WithdrawResponse: @unchecked Sendable {}
extension Greenlight_FundChannelRequest: @unchecked Sendable {}
extension Greenlight_Outpoint: @unchecked Sendable {}
extension Greenlight_FundChannelResponse: @unchecked Sendable {}
extension Greenlight_Timeout: @unchecked Sendable {}
extension Greenlight_BitcoinAddress: @unchecked Sendable {}
extension Greenlight_CloseChannelRequest: @unchecked Sendable {}
extension Greenlight_CloseChannelResponse: @unchecked Sendable {}
extension Greenlight_Amount: @unchecked Sendable {}
extension Greenlight_Amount.OneOf_Unit: @unchecked Sendable {}
extension Greenlight_InvoiceRequest: @unchecked Sendable {}
extension Greenlight_Invoice: @unchecked Sendable {}
extension Greenlight_PayRequest: @unchecked Sendable {}
extension Greenlight_Payment: @unchecked Sendable {}
extension Greenlight_PaymentIdentifier: @unchecked Sendable {}
extension Greenlight_PaymentIdentifier.OneOf_ID: @unchecked Sendable {}
extension Greenlight_ListPaymentsRequest: @unchecked Sendable {}
extension Greenlight_ListPaymentsResponse: @unchecked Sendable {}
extension Greenlight_InvoiceIdentifier: @unchecked Sendable {}
extension Greenlight_InvoiceIdentifier.OneOf_ID: @unchecked Sendable {}
extension Greenlight_ListInvoicesRequest: @unchecked Sendable {}
extension Greenlight_StreamIncomingFilter: @unchecked Sendable {}
extension Greenlight_ListInvoicesResponse: @unchecked Sendable {}
extension Greenlight_TlvField: @unchecked Sendable {}
extension Greenlight_OffChainPayment: @unchecked Sendable {}
extension Greenlight_IncomingPayment: @unchecked Sendable {}
extension Greenlight_IncomingPayment.OneOf_Details: @unchecked Sendable {}
extension Greenlight_RoutehintHop: @unchecked Sendable {}
extension Greenlight_Routehint: @unchecked Sendable {}
extension Greenlight_KeysendRequest: @unchecked Sendable {}
extension Greenlight_StreamLogRequest: @unchecked Sendable {}
extension Greenlight_LogEntry: @unchecked Sendable {}
extension Greenlight_SignerStateEntry: @unchecked Sendable {}
extension Greenlight_PendingRequest: @unchecked Sendable {}
extension Greenlight_NodeConfig: @unchecked Sendable {}
extension Greenlight_StartupMessage: @unchecked Sendable {}
extension Greenlight_StreamCustommsgRequest: @unchecked Sendable {}
extension Greenlight_Custommsg: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "greenlight"

extension Greenlight_NetAddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Ipv4"),
    1: .same(proto: "Ipv6"),
    2: .same(proto: "TorV2"),
    3: .same(proto: "TorV3"),
  ]
}

extension Greenlight_BtcAddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BECH32"),
    1: .same(proto: "P2SH_SEGWIT"),
  ]
}

extension Greenlight_OutputStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIRMED"),
    1: .same(proto: "UNCONFIRMED"),
  ]
}

extension Greenlight_FeeratePreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "SLOW"),
    2: .same(proto: "URGENT"),
  ]
}

extension Greenlight_CloseChannelType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTUAL"),
    1: .same(proto: "UNILATERAL"),
  ]
}

extension Greenlight_InvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNPAID"),
    1: .same(proto: "PAID"),
    2: .same(proto: "EXPIRED"),
  ]
}

extension Greenlight_PayStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETE"),
    2: .same(proto: "FAILED"),
  ]
}

extension Greenlight_HsmRequestContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HsmRequestContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "dbid"),
    3: .same(proto: "capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.dbid) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.capabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    if self.dbid != 0 {
      try visitor.visitSingularUInt64Field(value: self.dbid, fieldNumber: 2)
    }
    if self.capabilities != 0 {
      try visitor.visitSingularUInt64Field(value: self.capabilities, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_HsmRequestContext, rhs: Greenlight_HsmRequestContext) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.dbid != rhs.dbid {return false}
    if lhs.capabilities != rhs.capabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_HsmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HsmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "raw"),
    5: .standard(proto: "signer_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.raw) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.signerState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularBytesField(value: self.raw, fieldNumber: 2)
    }
    if !self.signerState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signerState, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_HsmResponse, rhs: Greenlight_HsmResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.signerState != rhs.signerState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_HsmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HsmRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "context"),
    3: .same(proto: "raw"),
    4: .standard(proto: "signer_state"),
    5: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.raw) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.signerState) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.raw.isEmpty {
      try visitor.visitSingularBytesField(value: self.raw, fieldNumber: 3)
    }
    if !self.signerState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signerState, fieldNumber: 4)
    }
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_HsmRequest, rhs: Greenlight_HsmRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._context != rhs._context {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.signerState != rhs.signerState {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Empty, rhs: Greenlight_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "addr"),
    3: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .ipv4 {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Address, rhs: Greenlight_Address) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_GetInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_GetInfoRequest, rhs: Greenlight_GetInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_GetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "alias"),
    3: .same(proto: "color"),
    4: .standard(proto: "num_peers"),
    5: .same(proto: "addresses"),
    6: .same(proto: "version"),
    7: .same(proto: "blockheight"),
    8: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.color) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPeers) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.blockheight) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularBytesField(value: self.color, fieldNumber: 3)
    }
    if self.numPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPeers, fieldNumber: 4)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 5)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 6)
    }
    if self.blockheight != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockheight, fieldNumber: 7)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_GetInfoResponse, rhs: Greenlight_GetInfoResponse) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.color != rhs.color {return false}
    if lhs.numPeers != rhs.numPeers {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.version != rhs.version {return false}
    if lhs.blockheight != rhs.blockheight {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StopRequest, rhs: Greenlight_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StopResponse, rhs: Greenlight_StopResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ConnectRequest, rhs: Greenlight_ConnectRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.features) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.features.isEmpty {
      try visitor.visitSingularStringField(value: self.features, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ConnectResponse, rhs: Greenlight_ConnectResponse) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListPeersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListPeersRequest, rhs: Greenlight_ListPeersRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Htlc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Htlc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "id"),
    3: .same(proto: "amount"),
    4: .same(proto: "expiry"),
    5: .standard(proto: "payment_hash"),
    6: .same(proto: "state"),
    7: .standard(proto: "local_trimmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.expiry) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.paymentHash) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.localTrimmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiry, fieldNumber: 4)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 5)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 6)
    }
    if self.localTrimmed != false {
      try visitor.visitSingularBoolField(value: self.localTrimmed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Htlc, rhs: Greenlight_Htlc) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.id != rhs.id {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.state != rhs.state {return false}
    if lhs.localTrimmed != rhs.localTrimmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Aliases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Aliases"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.local) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.remote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.local.isEmpty {
      try visitor.visitSingularStringField(value: self.local, fieldNumber: 1)
    }
    if !self.remote.isEmpty {
      try visitor.visitSingularStringField(value: self.remote, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Aliases, rhs: Greenlight_Aliases) -> Bool {
    if lhs.local != rhs.local {return false}
    if lhs.remote != rhs.remote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "owner"),
    18: .same(proto: "alias"),
    3: .standard(proto: "short_channel_id"),
    4: .same(proto: "direction"),
    5: .standard(proto: "channel_id"),
    6: .standard(proto: "funding_txid"),
    7: .standard(proto: "close_to_addr"),
    8: .standard(proto: "close_to"),
    9: .same(proto: "private"),
    10: .same(proto: "total"),
    11: .standard(proto: "dust_limit"),
    12: .same(proto: "spendable"),
    13: .same(proto: "receivable"),
    14: .standard(proto: "their_to_self_delay"),
    15: .standard(proto: "our_to_self_delay"),
    16: .same(proto: "status"),
    17: .same(proto: "htlcs"),
  ]

  fileprivate class _StorageClass {
    var _state: String = String()
    var _owner: String = String()
    var _alias: Greenlight_Aliases? = nil
    var _shortChannelID: String = String()
    var _direction: UInt32 = 0
    var _channelID: String = String()
    var _fundingTxid: String = String()
    var _closeToAddr: String = String()
    var _closeTo: String = String()
    var _private: Bool = false
    var _total: String = String()
    var _dustLimit: String = String()
    var _spendable: String = String()
    var _receivable: String = String()
    var _theirToSelfDelay: UInt32 = 0
    var _ourToSelfDelay: UInt32 = 0
    var _status: [String] = []
    var _htlcs: [Greenlight_Htlc] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _state = source._state
      _owner = source._owner
      _alias = source._alias
      _shortChannelID = source._shortChannelID
      _direction = source._direction
      _channelID = source._channelID
      _fundingTxid = source._fundingTxid
      _closeToAddr = source._closeToAddr
      _closeTo = source._closeTo
      _private = source._private
      _total = source._total
      _dustLimit = source._dustLimit
      _spendable = source._spendable
      _receivable = source._receivable
      _theirToSelfDelay = source._theirToSelfDelay
      _ourToSelfDelay = source._ourToSelfDelay
      _status = source._status
      _htlcs = source._htlcs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._shortChannelID) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._direction) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._fundingTxid) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._closeToAddr) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._closeTo) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._total) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._dustLimit) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._spendable) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._receivable) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._theirToSelfDelay) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._ourToSelfDelay) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._status) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._htlcs) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._alias) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._shortChannelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortChannelID, fieldNumber: 3)
      }
      if _storage._direction != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._direction, fieldNumber: 4)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 5)
      }
      if !_storage._fundingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fundingTxid, fieldNumber: 6)
      }
      if !_storage._closeToAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeToAddr, fieldNumber: 7)
      }
      if !_storage._closeTo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeTo, fieldNumber: 8)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 9)
      }
      if !_storage._total.isEmpty {
        try visitor.visitSingularStringField(value: _storage._total, fieldNumber: 10)
      }
      if !_storage._dustLimit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dustLimit, fieldNumber: 11)
      }
      if !_storage._spendable.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spendable, fieldNumber: 12)
      }
      if !_storage._receivable.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receivable, fieldNumber: 13)
      }
      if _storage._theirToSelfDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._theirToSelfDelay, fieldNumber: 14)
      }
      if _storage._ourToSelfDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ourToSelfDelay, fieldNumber: 15)
      }
      if !_storage._status.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._status, fieldNumber: 16)
      }
      if !_storage._htlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._htlcs, fieldNumber: 17)
      }
      try { if let v = _storage._alias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Channel, rhs: Greenlight_Channel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._state != rhs_storage._state {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._shortChannelID != rhs_storage._shortChannelID {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._fundingTxid != rhs_storage._fundingTxid {return false}
        if _storage._closeToAddr != rhs_storage._closeToAddr {return false}
        if _storage._closeTo != rhs_storage._closeTo {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._total != rhs_storage._total {return false}
        if _storage._dustLimit != rhs_storage._dustLimit {return false}
        if _storage._spendable != rhs_storage._spendable {return false}
        if _storage._receivable != rhs_storage._receivable {return false}
        if _storage._theirToSelfDelay != rhs_storage._theirToSelfDelay {return false}
        if _storage._ourToSelfDelay != rhs_storage._ourToSelfDelay {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._htlcs != rhs_storage._htlcs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Peer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "connected"),
    3: .same(proto: "addresses"),
    4: .same(proto: "features"),
    5: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.features) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 2)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 3)
    }
    if !self.features.isEmpty {
      try visitor.visitSingularStringField(value: self.features, fieldNumber: 4)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Peer, rhs: Greenlight_Peer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.features != rhs.features {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListPeersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListPeersResponse, rhs: Greenlight_ListPeersResponse) -> Bool {
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_DisconnectRequest, rhs: Greenlight_DisconnectRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_DisconnectResponse, rhs: Greenlight_DisconnectResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_NewAddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addressType != .bech32 {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_NewAddrRequest, rhs: Greenlight_NewAddrRequest) -> Bool {
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_NewAddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_type"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addressType != .bech32 {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_NewAddrResponse, rhs: Greenlight_NewAddrResponse) -> Bool {
    if lhs.addressType != rhs.addressType {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListFundsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListFundsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minconf"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minconf) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minconf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListFundsRequest, rhs: Greenlight_ListFundsRequest) -> Bool {
    if lhs._minconf != rhs._minconf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListFundsOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListFundsOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "output"),
    2: .same(proto: "amount"),
    4: .same(proto: "address"),
    5: .same(proto: "status"),
    6: .same(proto: "reserved"),
    7: .standard(proto: "reserved_to_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.reserved) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.reservedToBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    if self.status != .confirmed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.reserved != false {
      try visitor.visitSingularBoolField(value: self.reserved, fieldNumber: 6)
    }
    if self.reservedToBlock != 0 {
      try visitor.visitSingularUInt32Field(value: self.reservedToBlock, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListFundsOutput, rhs: Greenlight_ListFundsOutput) -> Bool {
    if lhs._output != rhs._output {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.address != rhs.address {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reserved != rhs.reserved {return false}
    if lhs.reservedToBlock != rhs.reservedToBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListFundsChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListFundsChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .same(proto: "connected"),
    3: .standard(proto: "short_channel_id"),
    4: .standard(proto: "our_amount_msat"),
    5: .standard(proto: "amount_msat"),
    6: .standard(proto: "funding_txid"),
    7: .standard(proto: "funding_output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.shortChannelID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ourAmountMsat) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.amountMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.fundingTxid) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.fundingOutput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 1)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 2)
    }
    if self.shortChannelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.shortChannelID, fieldNumber: 3)
    }
    if self.ourAmountMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.ourAmountMsat, fieldNumber: 4)
    }
    if self.amountMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.amountMsat, fieldNumber: 5)
    }
    if !self.fundingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundingTxid, fieldNumber: 6)
    }
    if self.fundingOutput != 0 {
      try visitor.visitSingularUInt32Field(value: self.fundingOutput, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListFundsChannel, rhs: Greenlight_ListFundsChannel) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.shortChannelID != rhs.shortChannelID {return false}
    if lhs.ourAmountMsat != rhs.ourAmountMsat {return false}
    if lhs.amountMsat != rhs.amountMsat {return false}
    if lhs.fundingTxid != rhs.fundingTxid {return false}
    if lhs.fundingOutput != rhs.fundingOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListFundsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListFundsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
    2: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListFundsResponse, rhs: Greenlight_ListFundsResponse) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Feerate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Feerate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preset"),
    5: .same(proto: "perkw"),
    6: .same(proto: "perkb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Greenlight_FeeratePreset?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .preset(v)
        }
      }()
      case 5: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .perkw(v)
        }
      }()
      case 6: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .perkb(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .preset?: try {
      guard case .preset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .perkw?: try {
      guard case .perkw(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }()
    case .perkb?: try {
      guard case .perkb(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Feerate, rhs: Greenlight_Feerate) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Confirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Confirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.blocks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blocks != 0 {
      try visitor.visitSingularUInt32Field(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Confirmation, rhs: Greenlight_Confirmation) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_WithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "amount"),
    3: .same(proto: "feerate"),
    7: .same(proto: "minconf"),
    8: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._minconf) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minconf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_WithdrawRequest, rhs: Greenlight_WithdrawRequest) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_WithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_WithdrawResponse, rhs: Greenlight_WithdrawResponse) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_FundChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "amount"),
    3: .same(proto: "feerate"),
    7: .same(proto: "announce"),
    8: .same(proto: "minconf"),
    10: .standard(proto: "close_to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.announce) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._minconf) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.closeTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.announce != false {
      try visitor.visitSingularBoolField(value: self.announce, fieldNumber: 7)
    }
    try { if let v = self._minconf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.closeTo.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTo, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_FundChannelRequest, rhs: Greenlight_FundChannelRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs.announce != rhs.announce {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs.closeTo != rhs.closeTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Outpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Outpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "outnum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outnum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.outnum != 0 {
      try visitor.visitSingularUInt32Field(value: self.outnum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Outpoint, rhs: Greenlight_Outpoint) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.outnum != rhs.outnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_FundChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "outpoint"),
    3: .standard(proto: "channel_id"),
    4: .standard(proto: "close_to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.closeTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 3)
    }
    if !self.closeTo.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_FundChannelResponse, rhs: Greenlight_FundChannelResponse) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.closeTo != rhs.closeTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Timeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timeout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Timeout, rhs: Greenlight_Timeout) -> Bool {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_BitcoinAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BitcoinAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_BitcoinAddress, rhs: Greenlight_BitcoinAddress) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_CloseChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "unilateraltimeout"),
    3: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._unilateraltimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    try { if let v = self._unilateraltimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_CloseChannelRequest, rhs: Greenlight_CloseChannelRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._unilateraltimeout != rhs._unilateraltimeout {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_CloseChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_type"),
    2: .same(proto: "tx"),
    3: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.closeType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.closeType != .mutual {
      try visitor.visitSingularEnumField(value: self.closeType, fieldNumber: 1)
    }
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 2)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_CloseChannelResponse, rhs: Greenlight_CloseChannelResponse) -> Bool {
    if lhs.closeType != rhs.closeType {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "millisatoshi"),
    2: .same(proto: "satoshi"),
    3: .same(proto: "bitcoin"),
    4: .same(proto: "all"),
    5: .same(proto: "any"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.unit != nil {try decoder.handleConflictingOneOf()}
          self.unit = .millisatoshi(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.unit != nil {try decoder.handleConflictingOneOf()}
          self.unit = .satoshi(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.unit != nil {try decoder.handleConflictingOneOf()}
          self.unit = .bitcoin(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.unit != nil {try decoder.handleConflictingOneOf()}
          self.unit = .all(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.unit != nil {try decoder.handleConflictingOneOf()}
          self.unit = .any(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.unit {
    case .millisatoshi?: try {
      guard case .millisatoshi(let v)? = self.unit else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .satoshi?: try {
      guard case .satoshi(let v)? = self.unit else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .bitcoin?: try {
      guard case .bitcoin(let v)? = self.unit else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case .all?: try {
      guard case .all(let v)? = self.unit else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .any?: try {
      guard case .any(let v)? = self.unit else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Amount, rhs: Greenlight_Amount) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_InvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "label"),
    3: .same(proto: "description"),
    4: .same(proto: "preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_InvoiceRequest, rhs: Greenlight_InvoiceRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Invoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invoice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "description"),
    3: .same(proto: "amount"),
    4: .same(proto: "received"),
    5: .same(proto: "status"),
    6: .standard(proto: "payment_time"),
    7: .standard(proto: "expiry_time"),
    8: .same(proto: "bolt11"),
    9: .standard(proto: "payment_hash"),
    10: .standard(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._received) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.paymentTime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.expiryTime) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.paymentPreimage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._received {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.status != .unpaid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.paymentTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.paymentTime, fieldNumber: 6)
    }
    if self.expiryTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiryTime, fieldNumber: 7)
    }
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 8)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 9)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentPreimage, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Invoice, rhs: Greenlight_Invoice) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._received != rhs._received {return false}
    if lhs.status != rhs.status {return false}
    if lhs.paymentTime != rhs.paymentTime {return false}
    if lhs.expiryTime != rhs.expiryTime {return false}
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_PayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .same(proto: "amount"),
    3: .same(proto: "timeout"),
    4: .same(proto: "maxfeepercent"),
    5: .same(proto: "maxfee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.maxfeepercent) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxfee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 3)
    }
    if self.maxfeepercent != 0 {
      try visitor.visitSingularDoubleField(value: self.maxfeepercent, fieldNumber: 4)
    }
    try { if let v = self._maxfee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_PayRequest, rhs: Greenlight_PayRequest) -> Bool {
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.maxfeepercent != rhs.maxfeepercent {return false}
    if lhs._maxfee != rhs._maxfee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "payment_hash"),
    3: .standard(proto: "payment_preimage"),
    4: .same(proto: "status"),
    5: .same(proto: "amount"),
    6: .standard(proto: "amount_sent"),
    7: .same(proto: "bolt11"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "completed_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentPreimage) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountSent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.createdAt) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.completedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destination.isEmpty {
      try visitor.visitSingularBytesField(value: self.destination, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 2)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentPreimage, fieldNumber: 3)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._amountSent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 7)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularDoubleField(value: self.createdAt, fieldNumber: 8)
    }
    if self.completedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.completedAt, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Payment, rhs: Greenlight_Payment) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs.status != rhs.status {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._amountSent != rhs._amountSent {return false}
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.completedAt != rhs.completedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_PaymentIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .standard(proto: "payment_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .bolt11(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .paymentHash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .bolt11?: try {
      guard case .bolt11(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .paymentHash?: try {
      guard case .paymentHash(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_PaymentIdentifier, rhs: Greenlight_PaymentIdentifier) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListPaymentsRequest, rhs: Greenlight_ListPaymentsRequest) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListPaymentsResponse, rhs: Greenlight_ListPaymentsResponse) -> Bool {
    if lhs.payments != rhs.payments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_InvoiceIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "invstring"),
    3: .standard(proto: "payment_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .label(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .invstring(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .paymentHash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .label?: try {
      guard case .label(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .invstring?: try {
      guard case .invstring(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .paymentHash?: try {
      guard case .paymentHash(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_InvoiceIdentifier, rhs: Greenlight_InvoiceIdentifier) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListInvoicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListInvoicesRequest, rhs: Greenlight_ListInvoicesRequest) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StreamIncomingFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamIncomingFilter"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StreamIncomingFilter, rhs: Greenlight_StreamIncomingFilter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_ListInvoicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invoices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invoices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_ListInvoicesResponse, rhs: Greenlight_ListInvoicesResponse) -> Bool {
    if lhs.invoices != rhs.invoices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_TlvField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TlvField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularUInt64Field(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_TlvField, rhs: Greenlight_TlvField) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_OffChainPayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OffChainPayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "preimage"),
    3: .same(proto: "amount"),
    4: .same(proto: "extratlvs"),
    5: .standard(proto: "payment_hash"),
    6: .same(proto: "bolt11"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.extratlvs) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.extratlvs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extratlvs, fieldNumber: 4)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 5)
    }
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_OffChainPayment, rhs: Greenlight_OffChainPayment) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.extratlvs != rhs.extratlvs {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_IncomingPayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IncomingPayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offchain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Greenlight_OffChainPayment?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .offchain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .offchain(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .offchain(let v)? = self.details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_IncomingPayment, rhs: Greenlight_IncomingPayment) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_RoutehintHop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutehintHop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "short_channel_id"),
    3: .standard(proto: "fee_base"),
    4: .standard(proto: "fee_prop"),
    5: .standard(proto: "cltv_expiry_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shortChannelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.feeBase) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.feeProp) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.cltvExpiryDelta) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.shortChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.shortChannelID, fieldNumber: 2)
    }
    if self.feeBase != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeBase, fieldNumber: 3)
    }
    if self.feeProp != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeProp, fieldNumber: 4)
    }
    if self.cltvExpiryDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvExpiryDelta, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_RoutehintHop, rhs: Greenlight_RoutehintHop) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.shortChannelID != rhs.shortChannelID {return false}
    if lhs.feeBase != rhs.feeBase {return false}
    if lhs.feeProp != rhs.feeProp {return false}
    if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Routehint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Routehint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Routehint, rhs: Greenlight_Routehint) -> Bool {
    if lhs.hops != rhs.hops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_KeysendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeysendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "amount"),
    3: .same(proto: "label"),
    4: .same(proto: "routehints"),
    5: .same(proto: "extratlvs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.routehints) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.extratlvs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    if !self.routehints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routehints, fieldNumber: 4)
    }
    if !self.extratlvs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extratlvs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_KeysendRequest, rhs: Greenlight_KeysendRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.label != rhs.label {return false}
    if lhs.routehints != rhs.routehints {return false}
    if lhs.extratlvs != rhs.extratlvs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StreamLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamLogRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StreamLogRequest, rhs: Greenlight_StreamLogRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_LogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.line) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.line.isEmpty {
      try visitor.visitSingularStringField(value: self.line, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_LogEntry, rhs: Greenlight_LogEntry) -> Bool {
    if lhs.line != rhs.line {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_SignerStateEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerStateEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_SignerStateEntry, rhs: Greenlight_SignerStateEntry) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_PendingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "uri"),
    3: .same(proto: "signature"),
    4: .same(proto: "pubkey"),
    5: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.request) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.request.isEmpty {
      try visitor.visitSingularBytesField(value: self.request, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_PendingRequest, rhs: Greenlight_PendingRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_NodeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startupmsgs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.startupmsgs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startupmsgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.startupmsgs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_NodeConfig, rhs: Greenlight_NodeConfig) -> Bool {
    if lhs.startupmsgs != rhs.startupmsgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StartupMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartupMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.request) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.request.isEmpty {
      try visitor.visitSingularBytesField(value: self.request, fieldNumber: 1)
    }
    if !self.response.isEmpty {
      try visitor.visitSingularBytesField(value: self.response, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StartupMessage, rhs: Greenlight_StartupMessage) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_StreamCustommsgRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamCustommsgRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_StreamCustommsgRequest, rhs: Greenlight_StreamCustommsgRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Greenlight_Custommsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Custommsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Greenlight_Custommsg, rhs: Greenlight_Custommsg) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
