//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: greenlight.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// The node service represents your node running on greenlight's
/// infrastructure. You can use the exposed RPC methods to interact
/// with your node. The URI used to connect to the node depends on
/// where the node is being scheduled and is returned by the
/// `Scheduler.Schedule()` RPC call.
///
/// Notice that in order to connect to the node the caller must use the
/// node-specific mTLS keypair returned by `Scheduler.Register()` or
/// `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
/// rejected by the node.
///
/// Deprecated methods are being replaced by the standardized and
/// automatically managed cln-grpc protocol you can find in
/// `node.proto`
///
/// Usage: instantiate `Greenlight_NodeClient`, then call methods of this protocol to make API calls.
internal protocol Greenlight_NodeClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? { get }

  func streamIncoming(
    _ request: Greenlight_StreamIncomingFilter,
    callOptions: CallOptions?,
    handler: @escaping (Greenlight_IncomingPayment) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment>

  func streamLog(
    _ request: Greenlight_StreamLogRequest,
    callOptions: CallOptions?,
    handler: @escaping (Greenlight_LogEntry) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamLogRequest, Greenlight_LogEntry>

  func streamCustommsg(
    _ request: Greenlight_StreamCustommsgRequest,
    callOptions: CallOptions?,
    handler: @escaping (Greenlight_Custommsg) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg>

  func streamHsmRequests(
    _ request: Greenlight_Empty,
    callOptions: CallOptions?,
    handler: @escaping (Greenlight_HsmRequest) -> Void
  ) -> ServerStreamingCall<Greenlight_Empty, Greenlight_HsmRequest>

  func respondHsmRequest(
    _ request: Greenlight_HsmResponse,
    callOptions: CallOptions?
  ) -> UnaryCall<Greenlight_HsmResponse, Greenlight_Empty>
}

extension Greenlight_NodeClientProtocol {
  internal var serviceName: String {
    return "greenlight.Node"
  }

  /// Stream incoming payments
  ///
  /// Currently includes off-chain payments received matching an
  /// invoice or spontaneus paymens through keysend.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamIncoming.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamIncoming(
    _ request: Greenlight_StreamIncomingFilter,
    callOptions: CallOptions? = nil,
    handler: @escaping (Greenlight_IncomingPayment) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment> {
    return self.makeServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamIncoming.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamIncomingInterceptors() ?? [],
      handler: handler
    )
  }

  /// Stream the logs as they are produced by the node
  ///
  /// Mainly intended for debugging clients by tailing the log as
  /// they are written on the node. The logs start streaming from
  /// the first beginning, in order to allow inspection of events
  /// after an error occurred, That also means that the logs can
  /// be rather large, and should not be streamed onto
  /// resource-constrained devices.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamLog.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamLog(
    _ request: Greenlight_StreamLogRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Greenlight_LogEntry) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamLogRequest, Greenlight_LogEntry> {
    return self.makeServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
      handler: handler
    )
  }

  /// Listen for incoming `custommsg` messages from peers.
  ///
  /// The messages are forwarded as they come in, and will not be
  /// replayed if the stream is interrupted.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamCustommsg.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamCustommsg(
    _ request: Greenlight_StreamCustommsgRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Greenlight_Custommsg) -> Void
  ) -> ServerStreamingCall<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg> {
    return self.makeServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamCustommsg.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamCustommsgInterceptors() ?? [],
      handler: handler
    )
  }

  ///////////////////////////////// HSM Messages ////////////////////////
  ///
  /// The following messages are related to communicating HSM
  /// requests back and forth. Chances are you won't need to
  /// interact with these at all, unless you want to embed the
  /// hsmd into your client. We recommend using a standalone hsmd
  /// such as hagrid, keeper of keys, to get started.
  ///
  /// Stream requests from the node to any key device that can
  /// respond to them.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamHsmRequests.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamHsmRequests(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil,
    handler: @escaping (Greenlight_HsmRequest) -> Void
  ) -> ServerStreamingCall<Greenlight_Empty, Greenlight_HsmRequest> {
    return self.makeServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamHsmRequests.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamHsmRequestsInterceptors() ?? [],
      handler: handler
    )
  }

  /// Unary call to RespondHsmRequest
  ///
  /// - Parameters:
  ///   - request: Request to send to RespondHsmRequest.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func respondHsmRequest(
    _ request: Greenlight_HsmResponse,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Greenlight_HsmResponse, Greenlight_Empty> {
    return self.makeUnaryCall(
      path: Greenlight_NodeClientMetadata.Methods.respondHsmRequest.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRespondHsmRequestInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Greenlight_NodeClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Greenlight_NodeNIOClient")
internal final class Greenlight_NodeClient: Greenlight_NodeClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Greenlight_NodeClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the greenlight.Node service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Greenlight_NodeNIOClient: Greenlight_NodeClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol?

  /// Creates a client for the greenlight.Node service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The node service represents your node running on greenlight's
/// infrastructure. You can use the exposed RPC methods to interact
/// with your node. The URI used to connect to the node depends on
/// where the node is being scheduled and is returned by the
/// `Scheduler.Schedule()` RPC call.
///
/// Notice that in order to connect to the node the caller must use the
/// node-specific mTLS keypair returned by `Scheduler.Register()` or
/// `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
/// rejected by the node.
///
/// Deprecated methods are being replaced by the standardized and
/// automatically managed cln-grpc protocol you can find in
/// `node.proto`
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Greenlight_NodeAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? { get }

  func makeStreamIncomingCall(
    _ request: Greenlight_StreamIncomingFilter,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment>

  func makeStreamLogCall(
    _ request: Greenlight_StreamLogRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamLogRequest, Greenlight_LogEntry>

  func makeStreamCustommsgCall(
    _ request: Greenlight_StreamCustommsgRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg>

  func makeStreamHsmRequestsCall(
    _ request: Greenlight_Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Greenlight_Empty, Greenlight_HsmRequest>

  func makeRespondHsmRequestCall(
    _ request: Greenlight_HsmResponse,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Greenlight_HsmResponse, Greenlight_Empty>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_NodeAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Greenlight_NodeClientMetadata.serviceDescriptor
  }

  internal var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeStreamIncomingCall(
    _ request: Greenlight_StreamIncomingFilter,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment> {
    return self.makeAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamIncoming.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamIncomingInterceptors() ?? []
    )
  }

  internal func makeStreamLogCall(
    _ request: Greenlight_StreamLogRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamLogRequest, Greenlight_LogEntry> {
    return self.makeAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? []
    )
  }

  internal func makeStreamCustommsgCall(
    _ request: Greenlight_StreamCustommsgRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg> {
    return self.makeAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamCustommsg.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamCustommsgInterceptors() ?? []
    )
  }

  internal func makeStreamHsmRequestsCall(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Greenlight_Empty, Greenlight_HsmRequest> {
    return self.makeAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamHsmRequests.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamHsmRequestsInterceptors() ?? []
    )
  }

  internal func makeRespondHsmRequestCall(
    _ request: Greenlight_HsmResponse,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Greenlight_HsmResponse, Greenlight_Empty> {
    return self.makeAsyncUnaryCall(
      path: Greenlight_NodeClientMetadata.Methods.respondHsmRequest.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRespondHsmRequestInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_NodeAsyncClientProtocol {
  internal func streamIncoming(
    _ request: Greenlight_StreamIncomingFilter,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Greenlight_IncomingPayment> {
    return self.performAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamIncoming.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamIncomingInterceptors() ?? []
    )
  }

  internal func streamLog(
    _ request: Greenlight_StreamLogRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Greenlight_LogEntry> {
    return self.performAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? []
    )
  }

  internal func streamCustommsg(
    _ request: Greenlight_StreamCustommsgRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Greenlight_Custommsg> {
    return self.performAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamCustommsg.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamCustommsgInterceptors() ?? []
    )
  }

  internal func streamHsmRequests(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Greenlight_HsmRequest> {
    return self.performAsyncServerStreamingCall(
      path: Greenlight_NodeClientMetadata.Methods.streamHsmRequests.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamHsmRequestsInterceptors() ?? []
    )
  }

  internal func respondHsmRequest(
    _ request: Greenlight_HsmResponse,
    callOptions: CallOptions? = nil
  ) async throws -> Greenlight_Empty {
    return try await self.performAsyncUnaryCall(
      path: Greenlight_NodeClientMetadata.Methods.respondHsmRequest.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRespondHsmRequestInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Greenlight_NodeAsyncClient: Greenlight_NodeAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Greenlight_NodeClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_NodeClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

internal protocol Greenlight_NodeClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'streamIncoming'.
  func makeStreamIncomingInterceptors() -> [ClientInterceptor<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment>]

  /// - Returns: Interceptors to use when invoking 'streamLog'.
  func makeStreamLogInterceptors() -> [ClientInterceptor<Greenlight_StreamLogRequest, Greenlight_LogEntry>]

  /// - Returns: Interceptors to use when invoking 'streamCustommsg'.
  func makeStreamCustommsgInterceptors() -> [ClientInterceptor<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg>]

  /// - Returns: Interceptors to use when invoking 'streamHsmRequests'.
  func makeStreamHsmRequestsInterceptors() -> [ClientInterceptor<Greenlight_Empty, Greenlight_HsmRequest>]

  /// - Returns: Interceptors to use when invoking 'respondHsmRequest'.
  func makeRespondHsmRequestInterceptors() -> [ClientInterceptor<Greenlight_HsmResponse, Greenlight_Empty>]
}

internal enum Greenlight_NodeClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Node",
    fullName: "greenlight.Node",
    methods: [
      Greenlight_NodeClientMetadata.Methods.streamIncoming,
      Greenlight_NodeClientMetadata.Methods.streamLog,
      Greenlight_NodeClientMetadata.Methods.streamCustommsg,
      Greenlight_NodeClientMetadata.Methods.streamHsmRequests,
      Greenlight_NodeClientMetadata.Methods.respondHsmRequest,
    ]
  )

  internal enum Methods {
    internal static let streamIncoming = GRPCMethodDescriptor(
      name: "StreamIncoming",
      path: "/greenlight.Node/StreamIncoming",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamLog = GRPCMethodDescriptor(
      name: "StreamLog",
      path: "/greenlight.Node/StreamLog",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamCustommsg = GRPCMethodDescriptor(
      name: "StreamCustommsg",
      path: "/greenlight.Node/StreamCustommsg",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamHsmRequests = GRPCMethodDescriptor(
      name: "StreamHsmRequests",
      path: "/greenlight.Node/StreamHsmRequests",
      type: GRPCCallType.serverStreaming
    )

    internal static let respondHsmRequest = GRPCMethodDescriptor(
      name: "RespondHsmRequest",
      path: "/greenlight.Node/RespondHsmRequest",
      type: GRPCCallType.unary
    )
  }
}

/// Usage: instantiate `Greenlight_HsmClient`, then call methods of this protocol to make API calls.
internal protocol Greenlight_HsmClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? { get }

  func request(
    _ request: Greenlight_HsmRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Greenlight_HsmRequest, Greenlight_HsmResponse>

  func ping(
    _ request: Greenlight_Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Greenlight_Empty, Greenlight_Empty>
}

extension Greenlight_HsmClientProtocol {
  internal var serviceName: String {
    return "greenlight.Hsm"
  }

  /// Unary call to Request
  ///
  /// - Parameters:
  ///   - request: Request to send to Request.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func request(
    _ request: Greenlight_HsmRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Greenlight_HsmRequest, Greenlight_HsmResponse> {
    return self.makeUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.request.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRequestInterceptors() ?? []
    )
  }

  /// Unary call to Ping
  ///
  /// - Parameters:
  ///   - request: Request to send to Ping.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func ping(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Greenlight_Empty, Greenlight_Empty> {
    return self.makeUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.ping.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePingInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Greenlight_HsmClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Greenlight_HsmNIOClient")
internal final class Greenlight_HsmClient: Greenlight_HsmClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Greenlight_HsmClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the greenlight.Hsm service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Greenlight_HsmNIOClient: Greenlight_HsmClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol?

  /// Creates a client for the greenlight.Hsm service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Greenlight_HsmAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? { get }

  func makeRequestCall(
    _ request: Greenlight_HsmRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Greenlight_HsmRequest, Greenlight_HsmResponse>

  func makePingCall(
    _ request: Greenlight_Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Greenlight_Empty, Greenlight_Empty>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_HsmAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Greenlight_HsmClientMetadata.serviceDescriptor
  }

  internal var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeRequestCall(
    _ request: Greenlight_HsmRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Greenlight_HsmRequest, Greenlight_HsmResponse> {
    return self.makeAsyncUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.request.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRequestInterceptors() ?? []
    )
  }

  internal func makePingCall(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Greenlight_Empty, Greenlight_Empty> {
    return self.makeAsyncUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.ping.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePingInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_HsmAsyncClientProtocol {
  internal func request(
    _ request: Greenlight_HsmRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Greenlight_HsmResponse {
    return try await self.performAsyncUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.request.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRequestInterceptors() ?? []
    )
  }

  internal func ping(
    _ request: Greenlight_Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Greenlight_Empty {
    return try await self.performAsyncUnaryCall(
      path: Greenlight_HsmClientMetadata.Methods.ping.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePingInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Greenlight_HsmAsyncClient: Greenlight_HsmAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Greenlight_HsmClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Greenlight_HsmClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

internal protocol Greenlight_HsmClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'request'.
  func makeRequestInterceptors() -> [ClientInterceptor<Greenlight_HsmRequest, Greenlight_HsmResponse>]

  /// - Returns: Interceptors to use when invoking 'ping'.
  func makePingInterceptors() -> [ClientInterceptor<Greenlight_Empty, Greenlight_Empty>]
}

internal enum Greenlight_HsmClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Hsm",
    fullName: "greenlight.Hsm",
    methods: [
      Greenlight_HsmClientMetadata.Methods.request,
      Greenlight_HsmClientMetadata.Methods.ping,
    ]
  )

  internal enum Methods {
    internal static let request = GRPCMethodDescriptor(
      name: "Request",
      path: "/greenlight.Hsm/Request",
      type: GRPCCallType.unary
    )

    internal static let ping = GRPCMethodDescriptor(
      name: "Ping",
      path: "/greenlight.Hsm/Ping",
      type: GRPCCallType.unary
    )
  }
}

/// The node service represents your node running on greenlight's
/// infrastructure. You can use the exposed RPC methods to interact
/// with your node. The URI used to connect to the node depends on
/// where the node is being scheduled and is returned by the
/// `Scheduler.Schedule()` RPC call.
///
/// Notice that in order to connect to the node the caller must use the
/// node-specific mTLS keypair returned by `Scheduler.Register()` or
/// `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
/// rejected by the node.
///
/// Deprecated methods are being replaced by the standardized and
/// automatically managed cln-grpc protocol you can find in
/// `node.proto`
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol Greenlight_NodeProvider: CallHandlerProvider {
  var interceptors: Greenlight_NodeServerInterceptorFactoryProtocol? { get }

  /// Stream incoming payments
  ///
  /// Currently includes off-chain payments received matching an
  /// invoice or spontaneus paymens through keysend.
  func streamIncoming(request: Greenlight_StreamIncomingFilter, context: StreamingResponseCallContext<Greenlight_IncomingPayment>) -> EventLoopFuture<GRPCStatus>

  /// Stream the logs as they are produced by the node
  ///
  /// Mainly intended for debugging clients by tailing the log as
  /// they are written on the node. The logs start streaming from
  /// the first beginning, in order to allow inspection of events
  /// after an error occurred, That also means that the logs can
  /// be rather large, and should not be streamed onto
  /// resource-constrained devices.
  func streamLog(request: Greenlight_StreamLogRequest, context: StreamingResponseCallContext<Greenlight_LogEntry>) -> EventLoopFuture<GRPCStatus>

  /// Listen for incoming `custommsg` messages from peers.
  ///
  /// The messages are forwarded as they come in, and will not be
  /// replayed if the stream is interrupted.
  func streamCustommsg(request: Greenlight_StreamCustommsgRequest, context: StreamingResponseCallContext<Greenlight_Custommsg>) -> EventLoopFuture<GRPCStatus>

  ///////////////////////////////// HSM Messages ////////////////////////
  ///
  /// The following messages are related to communicating HSM
  /// requests back and forth. Chances are you won't need to
  /// interact with these at all, unless you want to embed the
  /// hsmd into your client. We recommend using a standalone hsmd
  /// such as hagrid, keeper of keys, to get started.
  ///
  /// Stream requests from the node to any key device that can
  /// respond to them.
  func streamHsmRequests(request: Greenlight_Empty, context: StreamingResponseCallContext<Greenlight_HsmRequest>) -> EventLoopFuture<GRPCStatus>

  func respondHsmRequest(request: Greenlight_HsmResponse, context: StatusOnlyCallContext) -> EventLoopFuture<Greenlight_Empty>
}

extension Greenlight_NodeProvider {
  internal var serviceName: Substring {
    return Greenlight_NodeServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamIncoming":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamIncomingFilter>(),
        responseSerializer: ProtobufSerializer<Greenlight_IncomingPayment>(),
        interceptors: self.interceptors?.makeStreamIncomingInterceptors() ?? [],
        userFunction: self.streamIncoming(request:context:)
      )

    case "StreamLog":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamLogRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_LogEntry>(),
        interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
        userFunction: self.streamLog(request:context:)
      )

    case "StreamCustommsg":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamCustommsgRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_Custommsg>(),
        interceptors: self.interceptors?.makeStreamCustommsgInterceptors() ?? [],
        userFunction: self.streamCustommsg(request:context:)
      )

    case "StreamHsmRequests":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_Empty>(),
        responseSerializer: ProtobufSerializer<Greenlight_HsmRequest>(),
        interceptors: self.interceptors?.makeStreamHsmRequestsInterceptors() ?? [],
        userFunction: self.streamHsmRequests(request:context:)
      )

    case "RespondHsmRequest":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_HsmResponse>(),
        responseSerializer: ProtobufSerializer<Greenlight_Empty>(),
        interceptors: self.interceptors?.makeRespondHsmRequestInterceptors() ?? [],
        userFunction: self.respondHsmRequest(request:context:)
      )

    default:
      return nil
    }
  }
}

/// The node service represents your node running on greenlight's
/// infrastructure. You can use the exposed RPC methods to interact
/// with your node. The URI used to connect to the node depends on
/// where the node is being scheduled and is returned by the
/// `Scheduler.Schedule()` RPC call.
///
/// Notice that in order to connect to the node the caller must use the
/// node-specific mTLS keypair returned by `Scheduler.Register()` or
/// `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
/// rejected by the node.
///
/// Deprecated methods are being replaced by the standardized and
/// automatically managed cln-grpc protocol you can find in
/// `node.proto`
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Greenlight_NodeAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Greenlight_NodeServerInterceptorFactoryProtocol? { get }

  /// Stream incoming payments
  ///
  /// Currently includes off-chain payments received matching an
  /// invoice or spontaneus paymens through keysend.
  func streamIncoming(
    request: Greenlight_StreamIncomingFilter,
    responseStream: GRPCAsyncResponseStreamWriter<Greenlight_IncomingPayment>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Stream the logs as they are produced by the node
  ///
  /// Mainly intended for debugging clients by tailing the log as
  /// they are written on the node. The logs start streaming from
  /// the first beginning, in order to allow inspection of events
  /// after an error occurred, That also means that the logs can
  /// be rather large, and should not be streamed onto
  /// resource-constrained devices.
  func streamLog(
    request: Greenlight_StreamLogRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Greenlight_LogEntry>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Listen for incoming `custommsg` messages from peers.
  ///
  /// The messages are forwarded as they come in, and will not be
  /// replayed if the stream is interrupted.
  func streamCustommsg(
    request: Greenlight_StreamCustommsgRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Greenlight_Custommsg>,
    context: GRPCAsyncServerCallContext
  ) async throws

  ///////////////////////////////// HSM Messages ////////////////////////
  ///
  /// The following messages are related to communicating HSM
  /// requests back and forth. Chances are you won't need to
  /// interact with these at all, unless you want to embed the
  /// hsmd into your client. We recommend using a standalone hsmd
  /// such as hagrid, keeper of keys, to get started.
  ///
  /// Stream requests from the node to any key device that can
  /// respond to them.
  func streamHsmRequests(
    request: Greenlight_Empty,
    responseStream: GRPCAsyncResponseStreamWriter<Greenlight_HsmRequest>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func respondHsmRequest(
    request: Greenlight_HsmResponse,
    context: GRPCAsyncServerCallContext
  ) async throws -> Greenlight_Empty
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_NodeAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Greenlight_NodeServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Greenlight_NodeServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Greenlight_NodeServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamIncoming":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamIncomingFilter>(),
        responseSerializer: ProtobufSerializer<Greenlight_IncomingPayment>(),
        interceptors: self.interceptors?.makeStreamIncomingInterceptors() ?? [],
        wrapping: { try await self.streamIncoming(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamLog":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamLogRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_LogEntry>(),
        interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
        wrapping: { try await self.streamLog(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamCustommsg":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_StreamCustommsgRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_Custommsg>(),
        interceptors: self.interceptors?.makeStreamCustommsgInterceptors() ?? [],
        wrapping: { try await self.streamCustommsg(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamHsmRequests":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_Empty>(),
        responseSerializer: ProtobufSerializer<Greenlight_HsmRequest>(),
        interceptors: self.interceptors?.makeStreamHsmRequestsInterceptors() ?? [],
        wrapping: { try await self.streamHsmRequests(request: $0, responseStream: $1, context: $2) }
      )

    case "RespondHsmRequest":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_HsmResponse>(),
        responseSerializer: ProtobufSerializer<Greenlight_Empty>(),
        interceptors: self.interceptors?.makeRespondHsmRequestInterceptors() ?? [],
        wrapping: { try await self.respondHsmRequest(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

internal protocol Greenlight_NodeServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'streamIncoming'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamIncomingInterceptors() -> [ServerInterceptor<Greenlight_StreamIncomingFilter, Greenlight_IncomingPayment>]

  /// - Returns: Interceptors to use when handling 'streamLog'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamLogInterceptors() -> [ServerInterceptor<Greenlight_StreamLogRequest, Greenlight_LogEntry>]

  /// - Returns: Interceptors to use when handling 'streamCustommsg'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamCustommsgInterceptors() -> [ServerInterceptor<Greenlight_StreamCustommsgRequest, Greenlight_Custommsg>]

  /// - Returns: Interceptors to use when handling 'streamHsmRequests'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamHsmRequestsInterceptors() -> [ServerInterceptor<Greenlight_Empty, Greenlight_HsmRequest>]

  /// - Returns: Interceptors to use when handling 'respondHsmRequest'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeRespondHsmRequestInterceptors() -> [ServerInterceptor<Greenlight_HsmResponse, Greenlight_Empty>]
}

internal enum Greenlight_NodeServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Node",
    fullName: "greenlight.Node",
    methods: [
      Greenlight_NodeServerMetadata.Methods.streamIncoming,
      Greenlight_NodeServerMetadata.Methods.streamLog,
      Greenlight_NodeServerMetadata.Methods.streamCustommsg,
      Greenlight_NodeServerMetadata.Methods.streamHsmRequests,
      Greenlight_NodeServerMetadata.Methods.respondHsmRequest,
    ]
  )

  internal enum Methods {
    internal static let streamIncoming = GRPCMethodDescriptor(
      name: "StreamIncoming",
      path: "/greenlight.Node/StreamIncoming",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamLog = GRPCMethodDescriptor(
      name: "StreamLog",
      path: "/greenlight.Node/StreamLog",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamCustommsg = GRPCMethodDescriptor(
      name: "StreamCustommsg",
      path: "/greenlight.Node/StreamCustommsg",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamHsmRequests = GRPCMethodDescriptor(
      name: "StreamHsmRequests",
      path: "/greenlight.Node/StreamHsmRequests",
      type: GRPCCallType.serverStreaming
    )

    internal static let respondHsmRequest = GRPCMethodDescriptor(
      name: "RespondHsmRequest",
      path: "/greenlight.Node/RespondHsmRequest",
      type: GRPCCallType.unary
    )
  }
}
/// To build a server, implement a class that conforms to this protocol.
internal protocol Greenlight_HsmProvider: CallHandlerProvider {
  var interceptors: Greenlight_HsmServerInterceptorFactoryProtocol? { get }

  func request(request: Greenlight_HsmRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Greenlight_HsmResponse>

  func ping(request: Greenlight_Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Greenlight_Empty>
}

extension Greenlight_HsmProvider {
  internal var serviceName: Substring {
    return Greenlight_HsmServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "Request":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_HsmRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_HsmResponse>(),
        interceptors: self.interceptors?.makeRequestInterceptors() ?? [],
        userFunction: self.request(request:context:)
      )

    case "Ping":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_Empty>(),
        responseSerializer: ProtobufSerializer<Greenlight_Empty>(),
        interceptors: self.interceptors?.makePingInterceptors() ?? [],
        userFunction: self.ping(request:context:)
      )

    default:
      return nil
    }
  }
}

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Greenlight_HsmAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Greenlight_HsmServerInterceptorFactoryProtocol? { get }

  func request(
    request: Greenlight_HsmRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Greenlight_HsmResponse

  func ping(
    request: Greenlight_Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Greenlight_Empty
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Greenlight_HsmAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Greenlight_HsmServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Greenlight_HsmServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Greenlight_HsmServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "Request":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_HsmRequest>(),
        responseSerializer: ProtobufSerializer<Greenlight_HsmResponse>(),
        interceptors: self.interceptors?.makeRequestInterceptors() ?? [],
        wrapping: { try await self.request(request: $0, context: $1) }
      )

    case "Ping":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Greenlight_Empty>(),
        responseSerializer: ProtobufSerializer<Greenlight_Empty>(),
        interceptors: self.interceptors?.makePingInterceptors() ?? [],
        wrapping: { try await self.ping(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

internal protocol Greenlight_HsmServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'request'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeRequestInterceptors() -> [ServerInterceptor<Greenlight_HsmRequest, Greenlight_HsmResponse>]

  /// - Returns: Interceptors to use when handling 'ping'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makePingInterceptors() -> [ServerInterceptor<Greenlight_Empty, Greenlight_Empty>]
}

internal enum Greenlight_HsmServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Hsm",
    fullName: "greenlight.Hsm",
    methods: [
      Greenlight_HsmServerMetadata.Methods.request,
      Greenlight_HsmServerMetadata.Methods.ping,
    ]
  )

  internal enum Methods {
    internal static let request = GRPCMethodDescriptor(
      name: "Request",
      path: "/greenlight.Hsm/Request",
      type: GRPCCallType.unary
    )

    internal static let ping = GRPCMethodDescriptor(
      name: "Ping",
      path: "/greenlight.Hsm/Ping",
      type: GRPCCallType.unary
    )
  }
}
