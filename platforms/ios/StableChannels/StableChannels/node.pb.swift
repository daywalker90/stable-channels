// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: node.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _3: SwiftProtobuf.ProtobufAPIVersion_3 {}
  typealias Version = _3
}

struct Cln_GetinfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_GetinfoResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var alias: String {
    get {return _storage._alias ?? String()}
    set {_uniqueStorage()._alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return _storage._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {_uniqueStorage()._alias = nil}

  var color: Data {
    get {return _storage._color}
    set {_uniqueStorage()._color = newValue}
  }

  var numPeers: UInt32 {
    get {return _storage._numPeers}
    set {_uniqueStorage()._numPeers = newValue}
  }

  var numPendingChannels: UInt32 {
    get {return _storage._numPendingChannels}
    set {_uniqueStorage()._numPendingChannels = newValue}
  }

  var numActiveChannels: UInt32 {
    get {return _storage._numActiveChannels}
    set {_uniqueStorage()._numActiveChannels = newValue}
  }

  var numInactiveChannels: UInt32 {
    get {return _storage._numInactiveChannels}
    set {_uniqueStorage()._numInactiveChannels = newValue}
  }

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var lightningDir: String {
    get {return _storage._lightningDir}
    set {_uniqueStorage()._lightningDir = newValue}
  }

  var ourFeatures: Cln_GetinfoOur_features {
    get {return _storage._ourFeatures ?? Cln_GetinfoOur_features()}
    set {_uniqueStorage()._ourFeatures = newValue}
  }
  /// Returns true if `ourFeatures` has been explicitly set.
  var hasOurFeatures: Bool {return _storage._ourFeatures != nil}
  /// Clears the value of `ourFeatures`. Subsequent reads from it will return its default value.
  mutating func clearOurFeatures() {_uniqueStorage()._ourFeatures = nil}

  var blockheight: UInt32 {
    get {return _storage._blockheight}
    set {_uniqueStorage()._blockheight = newValue}
  }

  var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  var feesCollectedMsat: Cln_Amount {
    get {return _storage._feesCollectedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._feesCollectedMsat = newValue}
  }
  /// Returns true if `feesCollectedMsat` has been explicitly set.
  var hasFeesCollectedMsat: Bool {return _storage._feesCollectedMsat != nil}
  /// Clears the value of `feesCollectedMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeesCollectedMsat() {_uniqueStorage()._feesCollectedMsat = nil}

  var address: [Cln_GetinfoAddress] {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  var binding: [Cln_GetinfoBinding] {
    get {return _storage._binding}
    set {_uniqueStorage()._binding = newValue}
  }

  var warningBitcoindSync: String {
    get {return _storage._warningBitcoindSync ?? String()}
    set {_uniqueStorage()._warningBitcoindSync = newValue}
  }
  /// Returns true if `warningBitcoindSync` has been explicitly set.
  var hasWarningBitcoindSync: Bool {return _storage._warningBitcoindSync != nil}
  /// Clears the value of `warningBitcoindSync`. Subsequent reads from it will return its default value.
  mutating func clearWarningBitcoindSync() {_uniqueStorage()._warningBitcoindSync = nil}

  var warningLightningdSync: String {
    get {return _storage._warningLightningdSync ?? String()}
    set {_uniqueStorage()._warningLightningdSync = newValue}
  }
  /// Returns true if `warningLightningdSync` has been explicitly set.
  var hasWarningLightningdSync: Bool {return _storage._warningLightningdSync != nil}
  /// Clears the value of `warningLightningdSync`. Subsequent reads from it will return its default value.
  mutating func clearWarningLightningdSync() {_uniqueStorage()._warningLightningdSync = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_GetinfoOur_features: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var init_p: Data = Data()

  var node: Data = Data()

  var channel: Data = Data()

  var invoice: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_GetinfoAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_GetinfoAddress.GetinfoAddressType = .dns

  var port: UInt32 = 0

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Getinfo.address[].type
  enum GetinfoAddressType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case dns // = 0
    case ipv4 // = 1
    case ipv6 // = 2
    case torv2 // = 3
    case torv3 // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .dns
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dns
      case 1: self = .ipv4
      case 2: self = .ipv6
      case 3: self = .torv2
      case 4: self = .torv3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .dns: return 0
      case .ipv4: return 1
      case .ipv6: return 2
      case .torv2: return 3
      case .torv3: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_GetinfoAddress.GetinfoAddressType] = [
      .dns,
      .ipv4,
      .ipv6,
      .torv2,
      .torv3,
    ]

  }

  init() {}

  fileprivate var _address: String? = nil
}

struct Cln_GetinfoBinding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_GetinfoBinding.GetinfoBindingType = .localSocket

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var port: UInt32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var socket: String {
    get {return _socket ?? String()}
    set {_socket = newValue}
  }
  /// Returns true if `socket` has been explicitly set.
  var hasSocket: Bool {return self._socket != nil}
  /// Clears the value of `socket`. Subsequent reads from it will return its default value.
  mutating func clearSocket() {self._socket = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Getinfo.binding[].type
  enum GetinfoBindingType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case localSocket // = 0
    case websocket // = 5
    case ipv4 // = 1
    case ipv6 // = 2
    case torv2 // = 3
    case torv3 // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .localSocket
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .localSocket
      case 1: self = .ipv4
      case 2: self = .ipv6
      case 3: self = .torv2
      case 4: self = .torv3
      case 5: self = .websocket
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .localSocket: return 0
      case .ipv4: return 1
      case .ipv6: return 2
      case .torv2: return 3
      case .torv3: return 4
      case .websocket: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_GetinfoBinding.GetinfoBindingType] = [
      .localSocket,
      .websocket,
      .ipv4,
      .ipv6,
      .torv2,
      .torv3,
    ]

  }

  init() {}

  fileprivate var _address: String? = nil
  fileprivate var _port: UInt32? = nil
  fileprivate var _socket: String? = nil
}

struct Cln_ListpeersRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var level: String {
    get {return _level ?? String()}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _level: String? = nil
}

struct Cln_ListpeersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peers: [Cln_ListpeersPeers] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListpeersPeers: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var connected: Bool = false

  var numChannels: UInt32 {
    get {return _numChannels ?? 0}
    set {_numChannels = newValue}
  }
  /// Returns true if `numChannels` has been explicitly set.
  var hasNumChannels: Bool {return self._numChannels != nil}
  /// Clears the value of `numChannels`. Subsequent reads from it will return its default value.
  mutating func clearNumChannels() {self._numChannels = nil}

  var log: [Cln_ListpeersPeersLog] = []

  var channels: [Cln_ListpeersPeersChannels] = []

  var netaddr: [String] = []

  var remoteAddr: String {
    get {return _remoteAddr ?? String()}
    set {_remoteAddr = newValue}
  }
  /// Returns true if `remoteAddr` has been explicitly set.
  var hasRemoteAddr: Bool {return self._remoteAddr != nil}
  /// Clears the value of `remoteAddr`. Subsequent reads from it will return its default value.
  mutating func clearRemoteAddr() {self._remoteAddr = nil}

  var features: Data {
    get {return _features ?? Data()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numChannels: UInt32? = nil
  fileprivate var _remoteAddr: String? = nil
  fileprivate var _features: Data? = nil
}

struct Cln_ListpeersPeersLog: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_ListpeersPeersLog.ListpeersPeersLogType = .skipped

  var numSkipped: UInt32 {
    get {return _numSkipped ?? 0}
    set {_numSkipped = newValue}
  }
  /// Returns true if `numSkipped` has been explicitly set.
  var hasNumSkipped: Bool {return self._numSkipped != nil}
  /// Clears the value of `numSkipped`. Subsequent reads from it will return its default value.
  mutating func clearNumSkipped() {self._numSkipped = nil}

  var time: String {
    get {return _time ?? String()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var log: String {
    get {return _log ?? String()}
    set {_log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return self._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {self._log = nil}

  var nodeID: Data {
    get {return _nodeID ?? Data()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  mutating func clearNodeID() {self._nodeID = nil}

  var data: Data {
    get {return _data ?? Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPeers.peers[].log[].type
  enum ListpeersPeersLogType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case skipped // = 0
    case broken // = 1
    case unusual // = 2
    case info // = 3
    case debug // = 4
    case ioIn // = 5
    case ioOut // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .skipped
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .skipped
      case 1: self = .broken
      case 2: self = .unusual
      case 3: self = .info
      case 4: self = .debug
      case 5: self = .ioIn
      case 6: self = .ioOut
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .skipped: return 0
      case .broken: return 1
      case .unusual: return 2
      case .info: return 3
      case .debug: return 4
      case .ioIn: return 5
      case .ioOut: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpeersPeersLog.ListpeersPeersLogType] = [
      .skipped,
      .broken,
      .unusual,
      .info,
      .debug,
      .ioIn,
      .ioOut,
    ]

  }

  init() {}

  fileprivate var _numSkipped: UInt32? = nil
  fileprivate var _time: String? = nil
  fileprivate var _source: String? = nil
  fileprivate var _log: String? = nil
  fileprivate var _nodeID: Data? = nil
  fileprivate var _data: Data? = nil
}

struct Cln_ListpeersPeersChannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Cln_ListpeersPeersChannels.ListpeersPeersChannelsState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var scratchTxid: Data {
    get {return _storage._scratchTxid ?? Data()}
    set {_uniqueStorage()._scratchTxid = newValue}
  }
  /// Returns true if `scratchTxid` has been explicitly set.
  var hasScratchTxid: Bool {return _storage._scratchTxid != nil}
  /// Clears the value of `scratchTxid`. Subsequent reads from it will return its default value.
  mutating func clearScratchTxid() {_uniqueStorage()._scratchTxid = nil}

  var feerate: Cln_ListpeersPeersChannelsFeerate {
    get {return _storage._feerate ?? Cln_ListpeersPeersChannelsFeerate()}
    set {_uniqueStorage()._feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return _storage._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {_uniqueStorage()._feerate = nil}

  var owner: String {
    get {return _storage._owner ?? String()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var shortChannelID: String {
    get {return _storage._shortChannelID ?? String()}
    set {_uniqueStorage()._shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return _storage._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {_uniqueStorage()._shortChannelID = nil}

  var channelID: Data {
    get {return _storage._channelID ?? Data()}
    set {_uniqueStorage()._channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return _storage._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {_uniqueStorage()._channelID = nil}

  var fundingTxid: Data {
    get {return _storage._fundingTxid ?? Data()}
    set {_uniqueStorage()._fundingTxid = newValue}
  }
  /// Returns true if `fundingTxid` has been explicitly set.
  var hasFundingTxid: Bool {return _storage._fundingTxid != nil}
  /// Clears the value of `fundingTxid`. Subsequent reads from it will return its default value.
  mutating func clearFundingTxid() {_uniqueStorage()._fundingTxid = nil}

  var fundingOutnum: UInt32 {
    get {return _storage._fundingOutnum ?? 0}
    set {_uniqueStorage()._fundingOutnum = newValue}
  }
  /// Returns true if `fundingOutnum` has been explicitly set.
  var hasFundingOutnum: Bool {return _storage._fundingOutnum != nil}
  /// Clears the value of `fundingOutnum`. Subsequent reads from it will return its default value.
  mutating func clearFundingOutnum() {_uniqueStorage()._fundingOutnum = nil}

  var initialFeerate: String {
    get {return _storage._initialFeerate ?? String()}
    set {_uniqueStorage()._initialFeerate = newValue}
  }
  /// Returns true if `initialFeerate` has been explicitly set.
  var hasInitialFeerate: Bool {return _storage._initialFeerate != nil}
  /// Clears the value of `initialFeerate`. Subsequent reads from it will return its default value.
  mutating func clearInitialFeerate() {_uniqueStorage()._initialFeerate = nil}

  var lastFeerate: String {
    get {return _storage._lastFeerate ?? String()}
    set {_uniqueStorage()._lastFeerate = newValue}
  }
  /// Returns true if `lastFeerate` has been explicitly set.
  var hasLastFeerate: Bool {return _storage._lastFeerate != nil}
  /// Clears the value of `lastFeerate`. Subsequent reads from it will return its default value.
  mutating func clearLastFeerate() {_uniqueStorage()._lastFeerate = nil}

  var nextFeerate: String {
    get {return _storage._nextFeerate ?? String()}
    set {_uniqueStorage()._nextFeerate = newValue}
  }
  /// Returns true if `nextFeerate` has been explicitly set.
  var hasNextFeerate: Bool {return _storage._nextFeerate != nil}
  /// Clears the value of `nextFeerate`. Subsequent reads from it will return its default value.
  mutating func clearNextFeerate() {_uniqueStorage()._nextFeerate = nil}

  var nextFeeStep: UInt32 {
    get {return _storage._nextFeeStep ?? 0}
    set {_uniqueStorage()._nextFeeStep = newValue}
  }
  /// Returns true if `nextFeeStep` has been explicitly set.
  var hasNextFeeStep: Bool {return _storage._nextFeeStep != nil}
  /// Clears the value of `nextFeeStep`. Subsequent reads from it will return its default value.
  mutating func clearNextFeeStep() {_uniqueStorage()._nextFeeStep = nil}

  var inflight: [Cln_ListpeersPeersChannelsInflight] {
    get {return _storage._inflight}
    set {_uniqueStorage()._inflight = newValue}
  }

  var closeTo: Data {
    get {return _storage._closeTo ?? Data()}
    set {_uniqueStorage()._closeTo = newValue}
  }
  /// Returns true if `closeTo` has been explicitly set.
  var hasCloseTo: Bool {return _storage._closeTo != nil}
  /// Clears the value of `closeTo`. Subsequent reads from it will return its default value.
  mutating func clearCloseTo() {_uniqueStorage()._closeTo = nil}

  var `private`: Bool {
    get {return _storage._private ?? false}
    set {_uniqueStorage()._private = newValue}
  }
  /// Returns true if ``private`` has been explicitly set.
  var hasPrivate: Bool {return _storage._private != nil}
  /// Clears the value of ``private``. Subsequent reads from it will return its default value.
  mutating func clearPrivate() {_uniqueStorage()._private = nil}

  var opener: Cln_ChannelSide {
    get {return _storage._opener}
    set {_uniqueStorage()._opener = newValue}
  }

  var closer: Cln_ChannelSide {
    get {return _storage._closer ?? .local}
    set {_uniqueStorage()._closer = newValue}
  }
  /// Returns true if `closer` has been explicitly set.
  var hasCloser: Bool {return _storage._closer != nil}
  /// Clears the value of `closer`. Subsequent reads from it will return its default value.
  mutating func clearCloser() {_uniqueStorage()._closer = nil}

  var features: [String] {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  var funding: Cln_ListpeersPeersChannelsFunding {
    get {return _storage._funding ?? Cln_ListpeersPeersChannelsFunding()}
    set {_uniqueStorage()._funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return _storage._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {_uniqueStorage()._funding = nil}

  var toUsMsat: Cln_Amount {
    get {return _storage._toUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._toUsMsat = newValue}
  }
  /// Returns true if `toUsMsat` has been explicitly set.
  var hasToUsMsat: Bool {return _storage._toUsMsat != nil}
  /// Clears the value of `toUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearToUsMsat() {_uniqueStorage()._toUsMsat = nil}

  var minToUsMsat: Cln_Amount {
    get {return _storage._minToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minToUsMsat = newValue}
  }
  /// Returns true if `minToUsMsat` has been explicitly set.
  var hasMinToUsMsat: Bool {return _storage._minToUsMsat != nil}
  /// Clears the value of `minToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinToUsMsat() {_uniqueStorage()._minToUsMsat = nil}

  var maxToUsMsat: Cln_Amount {
    get {return _storage._maxToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maxToUsMsat = newValue}
  }
  /// Returns true if `maxToUsMsat` has been explicitly set.
  var hasMaxToUsMsat: Bool {return _storage._maxToUsMsat != nil}
  /// Clears the value of `maxToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaxToUsMsat() {_uniqueStorage()._maxToUsMsat = nil}

  var totalMsat: Cln_Amount {
    get {return _storage._totalMsat ?? Cln_Amount()}
    set {_uniqueStorage()._totalMsat = newValue}
  }
  /// Returns true if `totalMsat` has been explicitly set.
  var hasTotalMsat: Bool {return _storage._totalMsat != nil}
  /// Clears the value of `totalMsat`. Subsequent reads from it will return its default value.
  mutating func clearTotalMsat() {_uniqueStorage()._totalMsat = nil}

  var feeBaseMsat: Cln_Amount {
    get {return _storage._feeBaseMsat ?? Cln_Amount()}
    set {_uniqueStorage()._feeBaseMsat = newValue}
  }
  /// Returns true if `feeBaseMsat` has been explicitly set.
  var hasFeeBaseMsat: Bool {return _storage._feeBaseMsat != nil}
  /// Clears the value of `feeBaseMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeBaseMsat() {_uniqueStorage()._feeBaseMsat = nil}

  var feeProportionalMillionths: UInt32 {
    get {return _storage._feeProportionalMillionths ?? 0}
    set {_uniqueStorage()._feeProportionalMillionths = newValue}
  }
  /// Returns true if `feeProportionalMillionths` has been explicitly set.
  var hasFeeProportionalMillionths: Bool {return _storage._feeProportionalMillionths != nil}
  /// Clears the value of `feeProportionalMillionths`. Subsequent reads from it will return its default value.
  mutating func clearFeeProportionalMillionths() {_uniqueStorage()._feeProportionalMillionths = nil}

  var dustLimitMsat: Cln_Amount {
    get {return _storage._dustLimitMsat ?? Cln_Amount()}
    set {_uniqueStorage()._dustLimitMsat = newValue}
  }
  /// Returns true if `dustLimitMsat` has been explicitly set.
  var hasDustLimitMsat: Bool {return _storage._dustLimitMsat != nil}
  /// Clears the value of `dustLimitMsat`. Subsequent reads from it will return its default value.
  mutating func clearDustLimitMsat() {_uniqueStorage()._dustLimitMsat = nil}

  var maxTotalHtlcInMsat: Cln_Amount {
    get {return _storage._maxTotalHtlcInMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maxTotalHtlcInMsat = newValue}
  }
  /// Returns true if `maxTotalHtlcInMsat` has been explicitly set.
  var hasMaxTotalHtlcInMsat: Bool {return _storage._maxTotalHtlcInMsat != nil}
  /// Clears the value of `maxTotalHtlcInMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaxTotalHtlcInMsat() {_uniqueStorage()._maxTotalHtlcInMsat = nil}

  var theirReserveMsat: Cln_Amount {
    get {return _storage._theirReserveMsat ?? Cln_Amount()}
    set {_uniqueStorage()._theirReserveMsat = newValue}
  }
  /// Returns true if `theirReserveMsat` has been explicitly set.
  var hasTheirReserveMsat: Bool {return _storage._theirReserveMsat != nil}
  /// Clears the value of `theirReserveMsat`. Subsequent reads from it will return its default value.
  mutating func clearTheirReserveMsat() {_uniqueStorage()._theirReserveMsat = nil}

  var ourReserveMsat: Cln_Amount {
    get {return _storage._ourReserveMsat ?? Cln_Amount()}
    set {_uniqueStorage()._ourReserveMsat = newValue}
  }
  /// Returns true if `ourReserveMsat` has been explicitly set.
  var hasOurReserveMsat: Bool {return _storage._ourReserveMsat != nil}
  /// Clears the value of `ourReserveMsat`. Subsequent reads from it will return its default value.
  mutating func clearOurReserveMsat() {_uniqueStorage()._ourReserveMsat = nil}

  var spendableMsat: Cln_Amount {
    get {return _storage._spendableMsat ?? Cln_Amount()}
    set {_uniqueStorage()._spendableMsat = newValue}
  }
  /// Returns true if `spendableMsat` has been explicitly set.
  var hasSpendableMsat: Bool {return _storage._spendableMsat != nil}
  /// Clears the value of `spendableMsat`. Subsequent reads from it will return its default value.
  mutating func clearSpendableMsat() {_uniqueStorage()._spendableMsat = nil}

  var receivableMsat: Cln_Amount {
    get {return _storage._receivableMsat ?? Cln_Amount()}
    set {_uniqueStorage()._receivableMsat = newValue}
  }
  /// Returns true if `receivableMsat` has been explicitly set.
  var hasReceivableMsat: Bool {return _storage._receivableMsat != nil}
  /// Clears the value of `receivableMsat`. Subsequent reads from it will return its default value.
  mutating func clearReceivableMsat() {_uniqueStorage()._receivableMsat = nil}

  var minimumHtlcInMsat: Cln_Amount {
    get {return _storage._minimumHtlcInMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minimumHtlcInMsat = newValue}
  }
  /// Returns true if `minimumHtlcInMsat` has been explicitly set.
  var hasMinimumHtlcInMsat: Bool {return _storage._minimumHtlcInMsat != nil}
  /// Clears the value of `minimumHtlcInMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinimumHtlcInMsat() {_uniqueStorage()._minimumHtlcInMsat = nil}

  var minimumHtlcOutMsat: Cln_Amount {
    get {return _storage._minimumHtlcOutMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minimumHtlcOutMsat = newValue}
  }
  /// Returns true if `minimumHtlcOutMsat` has been explicitly set.
  var hasMinimumHtlcOutMsat: Bool {return _storage._minimumHtlcOutMsat != nil}
  /// Clears the value of `minimumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinimumHtlcOutMsat() {_uniqueStorage()._minimumHtlcOutMsat = nil}

  var maximumHtlcOutMsat: Cln_Amount {
    get {return _storage._maximumHtlcOutMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maximumHtlcOutMsat = newValue}
  }
  /// Returns true if `maximumHtlcOutMsat` has been explicitly set.
  var hasMaximumHtlcOutMsat: Bool {return _storage._maximumHtlcOutMsat != nil}
  /// Clears the value of `maximumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaximumHtlcOutMsat() {_uniqueStorage()._maximumHtlcOutMsat = nil}

  var theirToSelfDelay: UInt32 {
    get {return _storage._theirToSelfDelay ?? 0}
    set {_uniqueStorage()._theirToSelfDelay = newValue}
  }
  /// Returns true if `theirToSelfDelay` has been explicitly set.
  var hasTheirToSelfDelay: Bool {return _storage._theirToSelfDelay != nil}
  /// Clears the value of `theirToSelfDelay`. Subsequent reads from it will return its default value.
  mutating func clearTheirToSelfDelay() {_uniqueStorage()._theirToSelfDelay = nil}

  var ourToSelfDelay: UInt32 {
    get {return _storage._ourToSelfDelay ?? 0}
    set {_uniqueStorage()._ourToSelfDelay = newValue}
  }
  /// Returns true if `ourToSelfDelay` has been explicitly set.
  var hasOurToSelfDelay: Bool {return _storage._ourToSelfDelay != nil}
  /// Clears the value of `ourToSelfDelay`. Subsequent reads from it will return its default value.
  mutating func clearOurToSelfDelay() {_uniqueStorage()._ourToSelfDelay = nil}

  var maxAcceptedHtlcs: UInt32 {
    get {return _storage._maxAcceptedHtlcs ?? 0}
    set {_uniqueStorage()._maxAcceptedHtlcs = newValue}
  }
  /// Returns true if `maxAcceptedHtlcs` has been explicitly set.
  var hasMaxAcceptedHtlcs: Bool {return _storage._maxAcceptedHtlcs != nil}
  /// Clears the value of `maxAcceptedHtlcs`. Subsequent reads from it will return its default value.
  mutating func clearMaxAcceptedHtlcs() {_uniqueStorage()._maxAcceptedHtlcs = nil}

  var alias: Cln_ListpeersPeersChannelsAlias {
    get {return _storage._alias ?? Cln_ListpeersPeersChannelsAlias()}
    set {_uniqueStorage()._alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return _storage._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {_uniqueStorage()._alias = nil}

  var status: [String] {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var inPaymentsOffered: UInt64 {
    get {return _storage._inPaymentsOffered ?? 0}
    set {_uniqueStorage()._inPaymentsOffered = newValue}
  }
  /// Returns true if `inPaymentsOffered` has been explicitly set.
  var hasInPaymentsOffered: Bool {return _storage._inPaymentsOffered != nil}
  /// Clears the value of `inPaymentsOffered`. Subsequent reads from it will return its default value.
  mutating func clearInPaymentsOffered() {_uniqueStorage()._inPaymentsOffered = nil}

  var inOfferedMsat: Cln_Amount {
    get {return _storage._inOfferedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._inOfferedMsat = newValue}
  }
  /// Returns true if `inOfferedMsat` has been explicitly set.
  var hasInOfferedMsat: Bool {return _storage._inOfferedMsat != nil}
  /// Clears the value of `inOfferedMsat`. Subsequent reads from it will return its default value.
  mutating func clearInOfferedMsat() {_uniqueStorage()._inOfferedMsat = nil}

  var inPaymentsFulfilled: UInt64 {
    get {return _storage._inPaymentsFulfilled ?? 0}
    set {_uniqueStorage()._inPaymentsFulfilled = newValue}
  }
  /// Returns true if `inPaymentsFulfilled` has been explicitly set.
  var hasInPaymentsFulfilled: Bool {return _storage._inPaymentsFulfilled != nil}
  /// Clears the value of `inPaymentsFulfilled`. Subsequent reads from it will return its default value.
  mutating func clearInPaymentsFulfilled() {_uniqueStorage()._inPaymentsFulfilled = nil}

  var inFulfilledMsat: Cln_Amount {
    get {return _storage._inFulfilledMsat ?? Cln_Amount()}
    set {_uniqueStorage()._inFulfilledMsat = newValue}
  }
  /// Returns true if `inFulfilledMsat` has been explicitly set.
  var hasInFulfilledMsat: Bool {return _storage._inFulfilledMsat != nil}
  /// Clears the value of `inFulfilledMsat`. Subsequent reads from it will return its default value.
  mutating func clearInFulfilledMsat() {_uniqueStorage()._inFulfilledMsat = nil}

  var outPaymentsOffered: UInt64 {
    get {return _storage._outPaymentsOffered ?? 0}
    set {_uniqueStorage()._outPaymentsOffered = newValue}
  }
  /// Returns true if `outPaymentsOffered` has been explicitly set.
  var hasOutPaymentsOffered: Bool {return _storage._outPaymentsOffered != nil}
  /// Clears the value of `outPaymentsOffered`. Subsequent reads from it will return its default value.
  mutating func clearOutPaymentsOffered() {_uniqueStorage()._outPaymentsOffered = nil}

  var outOfferedMsat: Cln_Amount {
    get {return _storage._outOfferedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._outOfferedMsat = newValue}
  }
  /// Returns true if `outOfferedMsat` has been explicitly set.
  var hasOutOfferedMsat: Bool {return _storage._outOfferedMsat != nil}
  /// Clears the value of `outOfferedMsat`. Subsequent reads from it will return its default value.
  mutating func clearOutOfferedMsat() {_uniqueStorage()._outOfferedMsat = nil}

  var outPaymentsFulfilled: UInt64 {
    get {return _storage._outPaymentsFulfilled ?? 0}
    set {_uniqueStorage()._outPaymentsFulfilled = newValue}
  }
  /// Returns true if `outPaymentsFulfilled` has been explicitly set.
  var hasOutPaymentsFulfilled: Bool {return _storage._outPaymentsFulfilled != nil}
  /// Clears the value of `outPaymentsFulfilled`. Subsequent reads from it will return its default value.
  mutating func clearOutPaymentsFulfilled() {_uniqueStorage()._outPaymentsFulfilled = nil}

  var outFulfilledMsat: Cln_Amount {
    get {return _storage._outFulfilledMsat ?? Cln_Amount()}
    set {_uniqueStorage()._outFulfilledMsat = newValue}
  }
  /// Returns true if `outFulfilledMsat` has been explicitly set.
  var hasOutFulfilledMsat: Bool {return _storage._outFulfilledMsat != nil}
  /// Clears the value of `outFulfilledMsat`. Subsequent reads from it will return its default value.
  mutating func clearOutFulfilledMsat() {_uniqueStorage()._outFulfilledMsat = nil}

  var htlcs: [Cln_ListpeersPeersChannelsHtlcs] {
    get {return _storage._htlcs}
    set {_uniqueStorage()._htlcs = newValue}
  }

  var closeToAddr: String {
    get {return _storage._closeToAddr ?? String()}
    set {_uniqueStorage()._closeToAddr = newValue}
  }
  /// Returns true if `closeToAddr` has been explicitly set.
  var hasCloseToAddr: Bool {return _storage._closeToAddr != nil}
  /// Clears the value of `closeToAddr`. Subsequent reads from it will return its default value.
  mutating func clearCloseToAddr() {_uniqueStorage()._closeToAddr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPeers.peers[].channels[].state
  enum ListpeersPeersChannelsState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case openingd // = 0
    case channeldAwaitingLockin // = 1
    case channeldNormal // = 2
    case channeldShuttingDown // = 3
    case closingdSigexchange // = 4
    case closingdComplete // = 5
    case awaitingUnilateral // = 6
    case fundingSpendSeen // = 7
    case onchain // = 8
    case dualopendOpenInit // = 9
    case dualopendAwaitingLockin // = 10
    case UNRECOGNIZED(Int)

    init() {
      self = .openingd
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .openingd
      case 1: self = .channeldAwaitingLockin
      case 2: self = .channeldNormal
      case 3: self = .channeldShuttingDown
      case 4: self = .closingdSigexchange
      case 5: self = .closingdComplete
      case 6: self = .awaitingUnilateral
      case 7: self = .fundingSpendSeen
      case 8: self = .onchain
      case 9: self = .dualopendOpenInit
      case 10: self = .dualopendAwaitingLockin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .openingd: return 0
      case .channeldAwaitingLockin: return 1
      case .channeldNormal: return 2
      case .channeldShuttingDown: return 3
      case .closingdSigexchange: return 4
      case .closingdComplete: return 5
      case .awaitingUnilateral: return 6
      case .fundingSpendSeen: return 7
      case .onchain: return 8
      case .dualopendOpenInit: return 9
      case .dualopendAwaitingLockin: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpeersPeersChannels.ListpeersPeersChannelsState] = [
      .openingd,
      .channeldAwaitingLockin,
      .channeldNormal,
      .channeldShuttingDown,
      .closingdSigexchange,
      .closingdComplete,
      .awaitingUnilateral,
      .fundingSpendSeen,
      .onchain,
      .dualopendOpenInit,
      .dualopendAwaitingLockin,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_ListpeersPeersChannelsFeerate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var perkw: UInt32 = 0

  var perkb: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListpeersPeersChannelsInflight: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundingTxid: Data = Data()

  var fundingOutnum: UInt32 = 0

  var feerate: String = String()

  var totalFundingMsat: Cln_Amount {
    get {return _totalFundingMsat ?? Cln_Amount()}
    set {_totalFundingMsat = newValue}
  }
  /// Returns true if `totalFundingMsat` has been explicitly set.
  var hasTotalFundingMsat: Bool {return self._totalFundingMsat != nil}
  /// Clears the value of `totalFundingMsat`. Subsequent reads from it will return its default value.
  mutating func clearTotalFundingMsat() {self._totalFundingMsat = nil}

  var ourFundingMsat: Cln_Amount {
    get {return _ourFundingMsat ?? Cln_Amount()}
    set {_ourFundingMsat = newValue}
  }
  /// Returns true if `ourFundingMsat` has been explicitly set.
  var hasOurFundingMsat: Bool {return self._ourFundingMsat != nil}
  /// Clears the value of `ourFundingMsat`. Subsequent reads from it will return its default value.
  mutating func clearOurFundingMsat() {self._ourFundingMsat = nil}

  var spliceAmount: Int64 {
    get {return _spliceAmount ?? 0}
    set {_spliceAmount = newValue}
  }
  /// Returns true if `spliceAmount` has been explicitly set.
  var hasSpliceAmount: Bool {return self._spliceAmount != nil}
  /// Clears the value of `spliceAmount`. Subsequent reads from it will return its default value.
  mutating func clearSpliceAmount() {self._spliceAmount = nil}

  var scratchTxid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalFundingMsat: Cln_Amount? = nil
  fileprivate var _ourFundingMsat: Cln_Amount? = nil
  fileprivate var _spliceAmount: Int64? = nil
}

struct Cln_ListpeersPeersChannelsFunding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pushedMsat: Cln_Amount {
    get {return _pushedMsat ?? Cln_Amount()}
    set {_pushedMsat = newValue}
  }
  /// Returns true if `pushedMsat` has been explicitly set.
  var hasPushedMsat: Bool {return self._pushedMsat != nil}
  /// Clears the value of `pushedMsat`. Subsequent reads from it will return its default value.
  mutating func clearPushedMsat() {self._pushedMsat = nil}

  var localFundsMsat: Cln_Amount {
    get {return _localFundsMsat ?? Cln_Amount()}
    set {_localFundsMsat = newValue}
  }
  /// Returns true if `localFundsMsat` has been explicitly set.
  var hasLocalFundsMsat: Bool {return self._localFundsMsat != nil}
  /// Clears the value of `localFundsMsat`. Subsequent reads from it will return its default value.
  mutating func clearLocalFundsMsat() {self._localFundsMsat = nil}

  var remoteFundsMsat: Cln_Amount {
    get {return _remoteFundsMsat ?? Cln_Amount()}
    set {_remoteFundsMsat = newValue}
  }
  /// Returns true if `remoteFundsMsat` has been explicitly set.
  var hasRemoteFundsMsat: Bool {return self._remoteFundsMsat != nil}
  /// Clears the value of `remoteFundsMsat`. Subsequent reads from it will return its default value.
  mutating func clearRemoteFundsMsat() {self._remoteFundsMsat = nil}

  var feePaidMsat: Cln_Amount {
    get {return _feePaidMsat ?? Cln_Amount()}
    set {_feePaidMsat = newValue}
  }
  /// Returns true if `feePaidMsat` has been explicitly set.
  var hasFeePaidMsat: Bool {return self._feePaidMsat != nil}
  /// Clears the value of `feePaidMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeePaidMsat() {self._feePaidMsat = nil}

  var feeRcvdMsat: Cln_Amount {
    get {return _feeRcvdMsat ?? Cln_Amount()}
    set {_feeRcvdMsat = newValue}
  }
  /// Returns true if `feeRcvdMsat` has been explicitly set.
  var hasFeeRcvdMsat: Bool {return self._feeRcvdMsat != nil}
  /// Clears the value of `feeRcvdMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeRcvdMsat() {self._feeRcvdMsat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pushedMsat: Cln_Amount? = nil
  fileprivate var _localFundsMsat: Cln_Amount? = nil
  fileprivate var _remoteFundsMsat: Cln_Amount? = nil
  fileprivate var _feePaidMsat: Cln_Amount? = nil
  fileprivate var _feeRcvdMsat: Cln_Amount? = nil
}

struct Cln_ListpeersPeersChannelsAlias: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var local: String {
    get {return _local ?? String()}
    set {_local = newValue}
  }
  /// Returns true if `local` has been explicitly set.
  var hasLocal: Bool {return self._local != nil}
  /// Clears the value of `local`. Subsequent reads from it will return its default value.
  mutating func clearLocal() {self._local = nil}

  var remote: String {
    get {return _remote ?? String()}
    set {_remote = newValue}
  }
  /// Returns true if `remote` has been explicitly set.
  var hasRemote: Bool {return self._remote != nil}
  /// Clears the value of `remote`. Subsequent reads from it will return its default value.
  mutating func clearRemote() {self._remote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _local: String? = nil
  fileprivate var _remote: String? = nil
}

struct Cln_ListpeersPeersChannelsHtlcs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var direction: Cln_ListpeersPeersChannelsHtlcs.ListpeersPeersChannelsHtlcsDirection = .in

  var id: UInt64 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var expiry: UInt32 = 0

  var paymentHash: Data = Data()

  var localTrimmed: Bool {
    get {return _localTrimmed ?? false}
    set {_localTrimmed = newValue}
  }
  /// Returns true if `localTrimmed` has been explicitly set.
  var hasLocalTrimmed: Bool {return self._localTrimmed != nil}
  /// Clears the value of `localTrimmed`. Subsequent reads from it will return its default value.
  mutating func clearLocalTrimmed() {self._localTrimmed = nil}

  var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var state: Cln_HtlcState = .sentAddHtlc

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPeers.peers[].channels[].htlcs[].direction
  enum ListpeersPeersChannelsHtlcsDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `in` // = 0
    case out // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .in
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .in
      case 1: self = .out
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .in: return 0
      case .out: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpeersPeersChannelsHtlcs.ListpeersPeersChannelsHtlcsDirection] = [
      .in,
      .out,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _localTrimmed: Bool? = nil
  fileprivate var _status: String? = nil
}

struct Cln_ListfundsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spent: Bool {
    get {return _spent ?? false}
    set {_spent = newValue}
  }
  /// Returns true if `spent` has been explicitly set.
  var hasSpent: Bool {return self._spent != nil}
  /// Clears the value of `spent`. Subsequent reads from it will return its default value.
  mutating func clearSpent() {self._spent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _spent: Bool? = nil
}

struct Cln_ListfundsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outputs: [Cln_ListfundsOutputs] = []

  var channels: [Cln_ListfundsChannels] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListfundsOutputs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var output: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var scriptpubkey: Data = Data()

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var redeemscript: Data {
    get {return _redeemscript ?? Data()}
    set {_redeemscript = newValue}
  }
  /// Returns true if `redeemscript` has been explicitly set.
  var hasRedeemscript: Bool {return self._redeemscript != nil}
  /// Clears the value of `redeemscript`. Subsequent reads from it will return its default value.
  mutating func clearRedeemscript() {self._redeemscript = nil}

  var status: Cln_ListfundsOutputs.ListfundsOutputsStatus = .unconfirmed

  var reserved: Bool = false

  var blockheight: UInt32 {
    get {return _blockheight ?? 0}
    set {_blockheight = newValue}
  }
  /// Returns true if `blockheight` has been explicitly set.
  var hasBlockheight: Bool {return self._blockheight != nil}
  /// Clears the value of `blockheight`. Subsequent reads from it will return its default value.
  mutating func clearBlockheight() {self._blockheight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListFunds.outputs[].status
  enum ListfundsOutputsStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unconfirmed // = 0
    case confirmed // = 1
    case spent // = 2
    case immature // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unconfirmed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unconfirmed
      case 1: self = .confirmed
      case 2: self = .spent
      case 3: self = .immature
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unconfirmed: return 0
      case .confirmed: return 1
      case .spent: return 2
      case .immature: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListfundsOutputs.ListfundsOutputsStatus] = [
      .unconfirmed,
      .confirmed,
      .spent,
      .immature,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _address: String? = nil
  fileprivate var _redeemscript: Data? = nil
  fileprivate var _blockheight: UInt32? = nil
}

struct Cln_ListfundsChannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data = Data()

  var ourAmountMsat: Cln_Amount {
    get {return _ourAmountMsat ?? Cln_Amount()}
    set {_ourAmountMsat = newValue}
  }
  /// Returns true if `ourAmountMsat` has been explicitly set.
  var hasOurAmountMsat: Bool {return self._ourAmountMsat != nil}
  /// Clears the value of `ourAmountMsat`. Subsequent reads from it will return its default value.
  mutating func clearOurAmountMsat() {self._ourAmountMsat = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var fundingTxid: Data = Data()

  var fundingOutput: UInt32 = 0

  var connected: Bool = false

  var state: Cln_ChannelState = .openingd

  var channelID: Data {
    get {return _channelID ?? Data()}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {self._channelID = nil}

  var shortChannelID: String {
    get {return _shortChannelID ?? String()}
    set {_shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return self._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {self._shortChannelID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ourAmountMsat: Cln_Amount? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _channelID: Data? = nil
  fileprivate var _shortChannelID: String? = nil
}

struct Cln_SendpayRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var route: [Cln_SendpayRoute] = []

  var paymentHash: Data = Data()

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var paymentSecret: Data {
    get {return _paymentSecret ?? Data()}
    set {_paymentSecret = newValue}
  }
  /// Returns true if `paymentSecret` has been explicitly set.
  var hasPaymentSecret: Bool {return self._paymentSecret != nil}
  /// Clears the value of `paymentSecret`. Subsequent reads from it will return its default value.
  mutating func clearPaymentSecret() {self._paymentSecret = nil}

  var partid: UInt32 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var localinvreqid: Data {
    get {return _localinvreqid ?? Data()}
    set {_localinvreqid = newValue}
  }
  /// Returns true if `localinvreqid` has been explicitly set.
  var hasLocalinvreqid: Bool {return self._localinvreqid != nil}
  /// Clears the value of `localinvreqid`. Subsequent reads from it will return its default value.
  mutating func clearLocalinvreqid() {self._localinvreqid = nil}

  var groupid: UInt64 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _label: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _paymentSecret: Data? = nil
  fileprivate var _partid: UInt32? = nil
  fileprivate var _localinvreqid: Data? = nil
  fileprivate var _groupid: UInt64? = nil
}

struct Cln_SendpayResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var groupid: UInt64 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var paymentHash: Data = Data()

  var status: Cln_SendpayResponse.SendpayStatus = .pending

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var createdAt: UInt64 = 0

  var completedAt: UInt64 {
    get {return _completedAt ?? 0}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  mutating func clearCompletedAt() {self._completedAt = nil}

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var partid: UInt64 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SendPay.status
  enum SendpayStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case complete // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .complete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_SendpayResponse.SendpayStatus] = [
      .pending,
      .complete,
    ]

  }

  init() {}

  fileprivate var _groupid: UInt64? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _destination: Data? = nil
  fileprivate var _completedAt: UInt64? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _partid: UInt64? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _paymentPreimage: Data? = nil
  fileprivate var _message: String? = nil
}

struct Cln_SendpayRoute: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var id: Data = Data()

  var delay: UInt32 = 0

  var channel: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_ListchannelsRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shortChannelID: String {
    get {return _shortChannelID ?? String()}
    set {_shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return self._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {self._shortChannelID = nil}

  var source: Data {
    get {return _source ?? Data()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shortChannelID: String? = nil
  fileprivate var _source: Data? = nil
  fileprivate var _destination: Data? = nil
}

struct Cln_ListchannelsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Cln_ListchannelsChannels] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListchannelsChannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Data = Data()

  var destination: Data = Data()

  var shortChannelID: String = String()

  var direction: UInt32 = 0

  var `public`: Bool = false

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var messageFlags: UInt32 = 0

  var channelFlags: UInt32 = 0

  var active: Bool = false

  var lastUpdate: UInt32 = 0

  var baseFeeMillisatoshi: UInt32 = 0

  var feePerMillionth: UInt32 = 0

  var delay: UInt32 = 0

  var htlcMinimumMsat: Cln_Amount {
    get {return _htlcMinimumMsat ?? Cln_Amount()}
    set {_htlcMinimumMsat = newValue}
  }
  /// Returns true if `htlcMinimumMsat` has been explicitly set.
  var hasHtlcMinimumMsat: Bool {return self._htlcMinimumMsat != nil}
  /// Clears the value of `htlcMinimumMsat`. Subsequent reads from it will return its default value.
  mutating func clearHtlcMinimumMsat() {self._htlcMinimumMsat = nil}

  var htlcMaximumMsat: Cln_Amount {
    get {return _htlcMaximumMsat ?? Cln_Amount()}
    set {_htlcMaximumMsat = newValue}
  }
  /// Returns true if `htlcMaximumMsat` has been explicitly set.
  var hasHtlcMaximumMsat: Bool {return self._htlcMaximumMsat != nil}
  /// Clears the value of `htlcMaximumMsat`. Subsequent reads from it will return its default value.
  mutating func clearHtlcMaximumMsat() {self._htlcMaximumMsat = nil}

  var features: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _htlcMinimumMsat: Cln_Amount? = nil
  fileprivate var _htlcMaximumMsat: Cln_Amount? = nil
}

struct Cln_AddgossipRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_AddgossipResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_AutocleaninvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expiredBy: UInt64 {
    get {return _expiredBy ?? 0}
    set {_expiredBy = newValue}
  }
  /// Returns true if `expiredBy` has been explicitly set.
  var hasExpiredBy: Bool {return self._expiredBy != nil}
  /// Clears the value of `expiredBy`. Subsequent reads from it will return its default value.
  mutating func clearExpiredBy() {self._expiredBy = nil}

  var cycleSeconds: UInt64 {
    get {return _cycleSeconds ?? 0}
    set {_cycleSeconds = newValue}
  }
  /// Returns true if `cycleSeconds` has been explicitly set.
  var hasCycleSeconds: Bool {return self._cycleSeconds != nil}
  /// Clears the value of `cycleSeconds`. Subsequent reads from it will return its default value.
  mutating func clearCycleSeconds() {self._cycleSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiredBy: UInt64? = nil
  fileprivate var _cycleSeconds: UInt64? = nil
}

struct Cln_AutocleaninvoiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var expiredBy: UInt64 {
    get {return _expiredBy ?? 0}
    set {_expiredBy = newValue}
  }
  /// Returns true if `expiredBy` has been explicitly set.
  var hasExpiredBy: Bool {return self._expiredBy != nil}
  /// Clears the value of `expiredBy`. Subsequent reads from it will return its default value.
  mutating func clearExpiredBy() {self._expiredBy = nil}

  var cycleSeconds: UInt64 {
    get {return _cycleSeconds ?? 0}
    set {_cycleSeconds = newValue}
  }
  /// Returns true if `cycleSeconds` has been explicitly set.
  var hasCycleSeconds: Bool {return self._cycleSeconds != nil}
  /// Clears the value of `cycleSeconds`. Subsequent reads from it will return its default value.
  mutating func clearCycleSeconds() {self._cycleSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiredBy: UInt64? = nil
  fileprivate var _cycleSeconds: UInt64? = nil
}

struct Cln_CheckmessageRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var zbase: String = String()

  var pubkey: Data {
    get {return _pubkey ?? Data()}
    set {_pubkey = newValue}
  }
  /// Returns true if `pubkey` has been explicitly set.
  var hasPubkey: Bool {return self._pubkey != nil}
  /// Clears the value of `pubkey`. Subsequent reads from it will return its default value.
  mutating func clearPubkey() {self._pubkey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pubkey: Data? = nil
}

struct Cln_CheckmessageResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var verified: Bool = false

  var pubkey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_CloseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unilateraltimeout: UInt32 {
    get {return _unilateraltimeout ?? 0}
    set {_unilateraltimeout = newValue}
  }
  /// Returns true if `unilateraltimeout` has been explicitly set.
  var hasUnilateraltimeout: Bool {return self._unilateraltimeout != nil}
  /// Clears the value of `unilateraltimeout`. Subsequent reads from it will return its default value.
  mutating func clearUnilateraltimeout() {self._unilateraltimeout = nil}

  var destination: String {
    get {return _destination ?? String()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var feeNegotiationStep: String {
    get {return _feeNegotiationStep ?? String()}
    set {_feeNegotiationStep = newValue}
  }
  /// Returns true if `feeNegotiationStep` has been explicitly set.
  var hasFeeNegotiationStep: Bool {return self._feeNegotiationStep != nil}
  /// Clears the value of `feeNegotiationStep`. Subsequent reads from it will return its default value.
  mutating func clearFeeNegotiationStep() {self._feeNegotiationStep = nil}

  var wrongFunding: Cln_Outpoint {
    get {return _wrongFunding ?? Cln_Outpoint()}
    set {_wrongFunding = newValue}
  }
  /// Returns true if `wrongFunding` has been explicitly set.
  var hasWrongFunding: Bool {return self._wrongFunding != nil}
  /// Clears the value of `wrongFunding`. Subsequent reads from it will return its default value.
  mutating func clearWrongFunding() {self._wrongFunding = nil}

  var forceLeaseClosed: Bool {
    get {return _forceLeaseClosed ?? false}
    set {_forceLeaseClosed = newValue}
  }
  /// Returns true if `forceLeaseClosed` has been explicitly set.
  var hasForceLeaseClosed: Bool {return self._forceLeaseClosed != nil}
  /// Clears the value of `forceLeaseClosed`. Subsequent reads from it will return its default value.
  mutating func clearForceLeaseClosed() {self._forceLeaseClosed = nil}

  var feerange: [Cln_Feerate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unilateraltimeout: UInt32? = nil
  fileprivate var _destination: String? = nil
  fileprivate var _feeNegotiationStep: String? = nil
  fileprivate var _wrongFunding: Cln_Outpoint? = nil
  fileprivate var _forceLeaseClosed: Bool? = nil
}

struct Cln_CloseResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_CloseResponse.CloseType = .mutual

  var tx: Data {
    get {return _tx ?? Data()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var txid: Data {
    get {return _txid ?? Data()}
    set {_txid = newValue}
  }
  /// Returns true if `txid` has been explicitly set.
  var hasTxid: Bool {return self._txid != nil}
  /// Clears the value of `txid`. Subsequent reads from it will return its default value.
  mutating func clearTxid() {self._txid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Close.type
  enum CloseType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case mutual // = 0
    case unilateral // = 1
    case unopened // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .mutual
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mutual
      case 1: self = .unilateral
      case 2: self = .unopened
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .mutual: return 0
      case .unilateral: return 1
      case .unopened: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_CloseResponse.CloseType] = [
      .mutual,
      .unilateral,
      .unopened,
    ]

  }

  init() {}

  fileprivate var _tx: Data? = nil
  fileprivate var _txid: Data? = nil
}

struct Cln_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var host: String {
    get {return _host ?? String()}
    set {_host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return self._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {self._host = nil}

  var port: UInt32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _host: String? = nil
  fileprivate var _port: UInt32? = nil
}

struct Cln_ConnectResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var features: Data = Data()

  var direction: Cln_ConnectResponse.ConnectDirection = .in

  var address: Cln_ConnectAddress {
    get {return _address ?? Cln_ConnectAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Connect.direction
  enum ConnectDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `in` // = 0
    case out // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .in
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .in
      case 1: self = .out
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .in: return 0
      case .out: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ConnectResponse.ConnectDirection] = [
      .in,
      .out,
    ]

  }

  init() {}

  fileprivate var _address: Cln_ConnectAddress? = nil
}

struct Cln_ConnectAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_ConnectAddress.ConnectAddressType = .localSocket

  var socket: String {
    get {return _socket ?? String()}
    set {_socket = newValue}
  }
  /// Returns true if `socket` has been explicitly set.
  var hasSocket: Bool {return self._socket != nil}
  /// Clears the value of `socket`. Subsequent reads from it will return its default value.
  mutating func clearSocket() {self._socket = nil}

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var port: UInt32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Connect.address.type
  enum ConnectAddressType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case localSocket // = 0
    case ipv4 // = 1
    case ipv6 // = 2
    case torv2 // = 3
    case torv3 // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .localSocket
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .localSocket
      case 1: self = .ipv4
      case 2: self = .ipv6
      case 3: self = .torv2
      case 4: self = .torv3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .localSocket: return 0
      case .ipv4: return 1
      case .ipv6: return 2
      case .torv2: return 3
      case .torv3: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ConnectAddress.ConnectAddressType] = [
      .localSocket,
      .ipv4,
      .ipv6,
      .torv2,
      .torv3,
    ]

  }

  init() {}

  fileprivate var _socket: String? = nil
  fileprivate var _address: String? = nil
  fileprivate var _port: UInt32? = nil
}

struct Cln_CreateinvoiceRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invstring: String = String()

  var label: String = String()

  var preimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_CreateinvoiceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var paymentHash: Data = Data()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var status: Cln_CreateinvoiceResponse.CreateinvoiceStatus = .paid

  var description_p: String = String()

  var expiresAt: UInt64 = 0

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var payIndex: UInt64 {
    get {return _payIndex ?? 0}
    set {_payIndex = newValue}
  }
  /// Returns true if `payIndex` has been explicitly set.
  var hasPayIndex: Bool {return self._payIndex != nil}
  /// Clears the value of `payIndex`. Subsequent reads from it will return its default value.
  mutating func clearPayIndex() {self._payIndex = nil}

  var amountReceivedMsat: Cln_Amount {
    get {return _amountReceivedMsat ?? Cln_Amount()}
    set {_amountReceivedMsat = newValue}
  }
  /// Returns true if `amountReceivedMsat` has been explicitly set.
  var hasAmountReceivedMsat: Bool {return self._amountReceivedMsat != nil}
  /// Clears the value of `amountReceivedMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountReceivedMsat() {self._amountReceivedMsat = nil}

  var paidAt: UInt64 {
    get {return _paidAt ?? 0}
    set {_paidAt = newValue}
  }
  /// Returns true if `paidAt` has been explicitly set.
  var hasPaidAt: Bool {return self._paidAt != nil}
  /// Clears the value of `paidAt`. Subsequent reads from it will return its default value.
  mutating func clearPaidAt() {self._paidAt = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var localOfferID: Data {
    get {return _localOfferID ?? Data()}
    set {_localOfferID = newValue}
  }
  /// Returns true if `localOfferID` has been explicitly set.
  var hasLocalOfferID: Bool {return self._localOfferID != nil}
  /// Clears the value of `localOfferID`. Subsequent reads from it will return its default value.
  mutating func clearLocalOfferID() {self._localOfferID = nil}

  var invreqPayerNote: String {
    get {return _invreqPayerNote ?? String()}
    set {_invreqPayerNote = newValue}
  }
  /// Returns true if `invreqPayerNote` has been explicitly set.
  var hasInvreqPayerNote: Bool {return self._invreqPayerNote != nil}
  /// Clears the value of `invreqPayerNote`. Subsequent reads from it will return its default value.
  mutating func clearInvreqPayerNote() {self._invreqPayerNote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// CreateInvoice.status
  enum CreateinvoiceStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case paid // = 0
    case expired // = 1
    case unpaid // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .paid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .paid
      case 1: self = .expired
      case 2: self = .unpaid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .paid: return 0
      case .expired: return 1
      case .unpaid: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_CreateinvoiceResponse.CreateinvoiceStatus] = [
      .paid,
      .expired,
      .unpaid,
    ]

  }

  init() {}

  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _payIndex: UInt64? = nil
  fileprivate var _amountReceivedMsat: Cln_Amount? = nil
  fileprivate var _paidAt: UInt64? = nil
  fileprivate var _paymentPreimage: Data? = nil
  fileprivate var _localOfferID: Data? = nil
  fileprivate var _invreqPayerNote: String? = nil
}

struct Cln_DatastoreRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating func clearString() {self._string = nil}

  var hex: Data {
    get {return _hex ?? Data()}
    set {_hex = newValue}
  }
  /// Returns true if `hex` has been explicitly set.
  var hasHex: Bool {return self._hex != nil}
  /// Clears the value of `hex`. Subsequent reads from it will return its default value.
  mutating func clearHex() {self._hex = nil}

  var mode: Cln_DatastoreRequest.DatastoreMode {
    get {return _mode ?? .mustCreate}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var generation: UInt64 {
    get {return _generation ?? 0}
    set {_generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return self._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {self._generation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Datastore.mode
  enum DatastoreMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case mustCreate // = 0
    case mustReplace // = 1
    case createOrReplace // = 2
    case mustAppend // = 3
    case createOrAppend // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .mustCreate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mustCreate
      case 1: self = .mustReplace
      case 2: self = .createOrReplace
      case 3: self = .mustAppend
      case 4: self = .createOrAppend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .mustCreate: return 0
      case .mustReplace: return 1
      case .createOrReplace: return 2
      case .mustAppend: return 3
      case .createOrAppend: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_DatastoreRequest.DatastoreMode] = [
      .mustCreate,
      .mustReplace,
      .createOrReplace,
      .mustAppend,
      .createOrAppend,
    ]

  }

  init() {}

  fileprivate var _string: String? = nil
  fileprivate var _hex: Data? = nil
  fileprivate var _mode: Cln_DatastoreRequest.DatastoreMode? = nil
  fileprivate var _generation: UInt64? = nil
}

struct Cln_DatastoreResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var generation: UInt64 {
    get {return _generation ?? 0}
    set {_generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return self._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {self._generation = nil}

  var hex: Data {
    get {return _hex ?? Data()}
    set {_hex = newValue}
  }
  /// Returns true if `hex` has been explicitly set.
  var hasHex: Bool {return self._hex != nil}
  /// Clears the value of `hex`. Subsequent reads from it will return its default value.
  mutating func clearHex() {self._hex = nil}

  var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating func clearString() {self._string = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _generation: UInt64? = nil
  fileprivate var _hex: Data? = nil
  fileprivate var _string: String? = nil
}

struct Cln_CreateonionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hops: [Cln_CreateonionHops] = []

  var assocdata: Data = Data()

  var sessionKey: Data {
    get {return _sessionKey ?? Data()}
    set {_sessionKey = newValue}
  }
  /// Returns true if `sessionKey` has been explicitly set.
  var hasSessionKey: Bool {return self._sessionKey != nil}
  /// Clears the value of `sessionKey`. Subsequent reads from it will return its default value.
  mutating func clearSessionKey() {self._sessionKey = nil}

  var onionSize: UInt32 {
    get {return _onionSize ?? 0}
    set {_onionSize = newValue}
  }
  /// Returns true if `onionSize` has been explicitly set.
  var hasOnionSize: Bool {return self._onionSize != nil}
  /// Clears the value of `onionSize`. Subsequent reads from it will return its default value.
  mutating func clearOnionSize() {self._onionSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionKey: Data? = nil
  fileprivate var _onionSize: UInt32? = nil
}

struct Cln_CreateonionResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var onion: Data = Data()

  var sharedSecrets: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_CreateonionHops: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubkey: Data = Data()

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DeldatastoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var generation: UInt64 {
    get {return _generation ?? 0}
    set {_generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return self._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {self._generation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _generation: UInt64? = nil
}

struct Cln_DeldatastoreResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var generation: UInt64 {
    get {return _generation ?? 0}
    set {_generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return self._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {self._generation = nil}

  var hex: Data {
    get {return _hex ?? Data()}
    set {_hex = newValue}
  }
  /// Returns true if `hex` has been explicitly set.
  var hasHex: Bool {return self._hex != nil}
  /// Clears the value of `hex`. Subsequent reads from it will return its default value.
  mutating func clearHex() {self._hex = nil}

  var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating func clearString() {self._string = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _generation: UInt64? = nil
  fileprivate var _hex: Data? = nil
  fileprivate var _string: String? = nil
}

struct Cln_DelexpiredinvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxexpirytime: UInt64 {
    get {return _maxexpirytime ?? 0}
    set {_maxexpirytime = newValue}
  }
  /// Returns true if `maxexpirytime` has been explicitly set.
  var hasMaxexpirytime: Bool {return self._maxexpirytime != nil}
  /// Clears the value of `maxexpirytime`. Subsequent reads from it will return its default value.
  mutating func clearMaxexpirytime() {self._maxexpirytime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxexpirytime: UInt64? = nil
}

struct Cln_DelexpiredinvoiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DelinvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var status: Cln_DelinvoiceRequest.DelinvoiceStatus = .paid

  var desconly: Bool {
    get {return _desconly ?? false}
    set {_desconly = newValue}
  }
  /// Returns true if `desconly` has been explicitly set.
  var hasDesconly: Bool {return self._desconly != nil}
  /// Clears the value of `desconly`. Subsequent reads from it will return its default value.
  mutating func clearDesconly() {self._desconly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DelInvoice.status
  enum DelinvoiceStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case paid // = 0
    case expired // = 1
    case unpaid // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .paid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .paid
      case 1: self = .expired
      case 2: self = .unpaid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .paid: return 0
      case .expired: return 1
      case .unpaid: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_DelinvoiceRequest.DelinvoiceStatus] = [
      .paid,
      .expired,
      .unpaid,
    ]

  }

  init() {}

  fileprivate var _desconly: Bool? = nil
}

struct Cln_DelinvoiceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var paymentHash: Data = Data()

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var updatedIndex: UInt64 {
    get {return _updatedIndex ?? 0}
    set {_updatedIndex = newValue}
  }
  /// Returns true if `updatedIndex` has been explicitly set.
  var hasUpdatedIndex: Bool {return self._updatedIndex != nil}
  /// Clears the value of `updatedIndex`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedIndex() {self._updatedIndex = nil}

  var status: Cln_DelinvoiceResponse.DelinvoiceStatus = .paid

  var expiresAt: UInt64 = 0

  var localOfferID: Data {
    get {return _localOfferID ?? Data()}
    set {_localOfferID = newValue}
  }
  /// Returns true if `localOfferID` has been explicitly set.
  var hasLocalOfferID: Bool {return self._localOfferID != nil}
  /// Clears the value of `localOfferID`. Subsequent reads from it will return its default value.
  mutating func clearLocalOfferID() {self._localOfferID = nil}

  var invreqPayerNote: String {
    get {return _invreqPayerNote ?? String()}
    set {_invreqPayerNote = newValue}
  }
  /// Returns true if `invreqPayerNote` has been explicitly set.
  var hasInvreqPayerNote: Bool {return self._invreqPayerNote != nil}
  /// Clears the value of `invreqPayerNote`. Subsequent reads from it will return its default value.
  mutating func clearInvreqPayerNote() {self._invreqPayerNote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DelInvoice.status
  enum DelinvoiceStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case paid // = 0
    case expired // = 1
    case unpaid // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .paid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .paid
      case 1: self = .expired
      case 2: self = .unpaid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .paid: return 0
      case .expired: return 1
      case .unpaid: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_DelinvoiceResponse.DelinvoiceStatus] = [
      .paid,
      .expired,
      .unpaid,
    ]

  }

  init() {}

  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _updatedIndex: UInt64? = nil
  fileprivate var _localOfferID: Data? = nil
  fileprivate var _invreqPayerNote: String? = nil
}

struct Cln_InvoiceRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amountMsat: Cln_AmountOrAny {
    get {return _amountMsat ?? Cln_AmountOrAny()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var description_p: String = String()

  var label: String = String()

  var expiry: UInt64 {
    get {return _expiry ?? 0}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  mutating func clearExpiry() {self._expiry = nil}

  var fallbacks: [String] = []

  var preimage: Data {
    get {return _preimage ?? Data()}
    set {_preimage = newValue}
  }
  /// Returns true if `preimage` has been explicitly set.
  var hasPreimage: Bool {return self._preimage != nil}
  /// Clears the value of `preimage`. Subsequent reads from it will return its default value.
  mutating func clearPreimage() {self._preimage = nil}

  var cltv: UInt32 {
    get {return _cltv ?? 0}
    set {_cltv = newValue}
  }
  /// Returns true if `cltv` has been explicitly set.
  var hasCltv: Bool {return self._cltv != nil}
  /// Clears the value of `cltv`. Subsequent reads from it will return its default value.
  mutating func clearCltv() {self._cltv = nil}

  var deschashonly: Bool {
    get {return _deschashonly ?? false}
    set {_deschashonly = newValue}
  }
  /// Returns true if `deschashonly` has been explicitly set.
  var hasDeschashonly: Bool {return self._deschashonly != nil}
  /// Clears the value of `deschashonly`. Subsequent reads from it will return its default value.
  mutating func clearDeschashonly() {self._deschashonly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_AmountOrAny? = nil
  fileprivate var _expiry: UInt64? = nil
  fileprivate var _preimage: Data? = nil
  fileprivate var _cltv: UInt32? = nil
  fileprivate var _deschashonly: Bool? = nil
}

struct Cln_InvoiceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String = String()

  var paymentHash: Data = Data()

  var paymentSecret: Data = Data()

  var expiresAt: UInt64 = 0

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var warningCapacity: String {
    get {return _warningCapacity ?? String()}
    set {_warningCapacity = newValue}
  }
  /// Returns true if `warningCapacity` has been explicitly set.
  var hasWarningCapacity: Bool {return self._warningCapacity != nil}
  /// Clears the value of `warningCapacity`. Subsequent reads from it will return its default value.
  mutating func clearWarningCapacity() {self._warningCapacity = nil}

  var warningOffline: String {
    get {return _warningOffline ?? String()}
    set {_warningOffline = newValue}
  }
  /// Returns true if `warningOffline` has been explicitly set.
  var hasWarningOffline: Bool {return self._warningOffline != nil}
  /// Clears the value of `warningOffline`. Subsequent reads from it will return its default value.
  mutating func clearWarningOffline() {self._warningOffline = nil}

  var warningDeadends: String {
    get {return _warningDeadends ?? String()}
    set {_warningDeadends = newValue}
  }
  /// Returns true if `warningDeadends` has been explicitly set.
  var hasWarningDeadends: Bool {return self._warningDeadends != nil}
  /// Clears the value of `warningDeadends`. Subsequent reads from it will return its default value.
  mutating func clearWarningDeadends() {self._warningDeadends = nil}

  var warningPrivateUnused: String {
    get {return _warningPrivateUnused ?? String()}
    set {_warningPrivateUnused = newValue}
  }
  /// Returns true if `warningPrivateUnused` has been explicitly set.
  var hasWarningPrivateUnused: Bool {return self._warningPrivateUnused != nil}
  /// Clears the value of `warningPrivateUnused`. Subsequent reads from it will return its default value.
  mutating func clearWarningPrivateUnused() {self._warningPrivateUnused = nil}

  var warningMpp: String {
    get {return _warningMpp ?? String()}
    set {_warningMpp = newValue}
  }
  /// Returns true if `warningMpp` has been explicitly set.
  var hasWarningMpp: Bool {return self._warningMpp != nil}
  /// Clears the value of `warningMpp`. Subsequent reads from it will return its default value.
  mutating func clearWarningMpp() {self._warningMpp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _warningCapacity: String? = nil
  fileprivate var _warningOffline: String? = nil
  fileprivate var _warningDeadends: String? = nil
  fileprivate var _warningPrivateUnused: String? = nil
  fileprivate var _warningMpp: String? = nil
}

struct Cln_ListdatastoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListdatastoreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var datastore: [Cln_ListdatastoreDatastore] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListdatastoreDatastore: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [String] = []

  var generation: UInt64 {
    get {return _generation ?? 0}
    set {_generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return self._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {self._generation = nil}

  var hex: Data {
    get {return _hex ?? Data()}
    set {_hex = newValue}
  }
  /// Returns true if `hex` has been explicitly set.
  var hasHex: Bool {return self._hex != nil}
  /// Clears the value of `hex`. Subsequent reads from it will return its default value.
  mutating func clearHex() {self._hex = nil}

  var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating func clearString() {self._string = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _generation: UInt64? = nil
  fileprivate var _hex: Data? = nil
  fileprivate var _string: String? = nil
}

struct Cln_ListinvoicesRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var invstring: String {
    get {return _invstring ?? String()}
    set {_invstring = newValue}
  }
  /// Returns true if `invstring` has been explicitly set.
  var hasInvstring: Bool {return self._invstring != nil}
  /// Clears the value of `invstring`. Subsequent reads from it will return its default value.
  mutating func clearInvstring() {self._invstring = nil}

  var paymentHash: Data {
    get {return _paymentHash ?? Data()}
    set {_paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return self._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {self._paymentHash = nil}

  var offerID: String {
    get {return _offerID ?? String()}
    set {_offerID = newValue}
  }
  /// Returns true if `offerID` has been explicitly set.
  var hasOfferID: Bool {return self._offerID != nil}
  /// Clears the value of `offerID`. Subsequent reads from it will return its default value.
  mutating func clearOfferID() {self._offerID = nil}

  var index: Cln_ListinvoicesRequest.ListinvoicesIndex {
    get {return _index ?? .created}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var start: UInt64 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var limit: UInt32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListInvoices.index
  enum ListinvoicesIndex: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case created // = 0
    case updated // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .created
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .created
      case 1: self = .updated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .created: return 0
      case .updated: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListinvoicesRequest.ListinvoicesIndex] = [
      .created,
      .updated,
    ]

  }

  init() {}

  fileprivate var _label: String? = nil
  fileprivate var _invstring: String? = nil
  fileprivate var _paymentHash: Data? = nil
  fileprivate var _offerID: String? = nil
  fileprivate var _index: Cln_ListinvoicesRequest.ListinvoicesIndex? = nil
  fileprivate var _start: UInt64? = nil
  fileprivate var _limit: UInt32? = nil
}

struct Cln_ListinvoicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invoices: [Cln_ListinvoicesInvoices] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListinvoicesInvoices: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var paymentHash: Data = Data()

  var status: Cln_ListinvoicesInvoices.ListinvoicesInvoicesStatus = .unpaid

  var expiresAt: UInt64 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var localOfferID: Data {
    get {return _localOfferID ?? Data()}
    set {_localOfferID = newValue}
  }
  /// Returns true if `localOfferID` has been explicitly set.
  var hasLocalOfferID: Bool {return self._localOfferID != nil}
  /// Clears the value of `localOfferID`. Subsequent reads from it will return its default value.
  mutating func clearLocalOfferID() {self._localOfferID = nil}

  var invreqPayerNote: String {
    get {return _invreqPayerNote ?? String()}
    set {_invreqPayerNote = newValue}
  }
  /// Returns true if `invreqPayerNote` has been explicitly set.
  var hasInvreqPayerNote: Bool {return self._invreqPayerNote != nil}
  /// Clears the value of `invreqPayerNote`. Subsequent reads from it will return its default value.
  mutating func clearInvreqPayerNote() {self._invreqPayerNote = nil}

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var updatedIndex: UInt64 {
    get {return _updatedIndex ?? 0}
    set {_updatedIndex = newValue}
  }
  /// Returns true if `updatedIndex` has been explicitly set.
  var hasUpdatedIndex: Bool {return self._updatedIndex != nil}
  /// Clears the value of `updatedIndex`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedIndex() {self._updatedIndex = nil}

  var payIndex: UInt64 {
    get {return _payIndex ?? 0}
    set {_payIndex = newValue}
  }
  /// Returns true if `payIndex` has been explicitly set.
  var hasPayIndex: Bool {return self._payIndex != nil}
  /// Clears the value of `payIndex`. Subsequent reads from it will return its default value.
  mutating func clearPayIndex() {self._payIndex = nil}

  var amountReceivedMsat: Cln_Amount {
    get {return _amountReceivedMsat ?? Cln_Amount()}
    set {_amountReceivedMsat = newValue}
  }
  /// Returns true if `amountReceivedMsat` has been explicitly set.
  var hasAmountReceivedMsat: Bool {return self._amountReceivedMsat != nil}
  /// Clears the value of `amountReceivedMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountReceivedMsat() {self._amountReceivedMsat = nil}

  var paidAt: UInt64 {
    get {return _paidAt ?? 0}
    set {_paidAt = newValue}
  }
  /// Returns true if `paidAt` has been explicitly set.
  var hasPaidAt: Bool {return self._paidAt != nil}
  /// Clears the value of `paidAt`. Subsequent reads from it will return its default value.
  mutating func clearPaidAt() {self._paidAt = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListInvoices.invoices[].status
  enum ListinvoicesInvoicesStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unpaid // = 0
    case paid // = 1
    case expired // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unpaid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unpaid
      case 1: self = .paid
      case 2: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unpaid: return 0
      case .paid: return 1
      case .expired: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListinvoicesInvoices.ListinvoicesInvoicesStatus] = [
      .unpaid,
      .paid,
      .expired,
    ]

  }

  init() {}

  fileprivate var _description_p: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _localOfferID: Data? = nil
  fileprivate var _invreqPayerNote: String? = nil
  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _updatedIndex: UInt64? = nil
  fileprivate var _payIndex: UInt64? = nil
  fileprivate var _amountReceivedMsat: Cln_Amount? = nil
  fileprivate var _paidAt: UInt64? = nil
  fileprivate var _paymentPreimage: Data? = nil
}

struct Cln_SendonionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var onion: Data = Data()

  var firstHop: Cln_SendonionFirst_hop {
    get {return _firstHop ?? Cln_SendonionFirst_hop()}
    set {_firstHop = newValue}
  }
  /// Returns true if `firstHop` has been explicitly set.
  var hasFirstHop: Bool {return self._firstHop != nil}
  /// Clears the value of `firstHop`. Subsequent reads from it will return its default value.
  mutating func clearFirstHop() {self._firstHop = nil}

  var paymentHash: Data = Data()

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var sharedSecrets: [Data] = []

  var partid: UInt32 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var localinvreqid: Data {
    get {return _localinvreqid ?? Data()}
    set {_localinvreqid = newValue}
  }
  /// Returns true if `localinvreqid` has been explicitly set.
  var hasLocalinvreqid: Bool {return self._localinvreqid != nil}
  /// Clears the value of `localinvreqid`. Subsequent reads from it will return its default value.
  mutating func clearLocalinvreqid() {self._localinvreqid = nil}

  var groupid: UInt64 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _firstHop: Cln_SendonionFirst_hop? = nil
  fileprivate var _label: String? = nil
  fileprivate var _partid: UInt32? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _destination: Data? = nil
  fileprivate var _localinvreqid: Data? = nil
  fileprivate var _groupid: UInt64? = nil
}

struct Cln_SendonionResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var paymentHash: Data = Data()

  var status: Cln_SendonionResponse.SendonionStatus = .pending

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var createdAt: UInt64 = 0

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var partid: UInt64 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SendOnion.status
  enum SendonionStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case complete // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .complete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_SendonionResponse.SendonionStatus] = [
      .pending,
      .complete,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _destination: Data? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _partid: UInt64? = nil
  fileprivate var _paymentPreimage: Data? = nil
  fileprivate var _message: String? = nil
}

struct Cln_SendonionFirst_hop: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var delay: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_ListsendpaysRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var paymentHash: Data {
    get {return _paymentHash ?? Data()}
    set {_paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return self._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {self._paymentHash = nil}

  var status: Cln_ListsendpaysRequest.ListsendpaysStatus {
    get {return _status ?? .pending}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListSendPays.status
  enum ListsendpaysStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case complete // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .complete
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .complete: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListsendpaysRequest.ListsendpaysStatus] = [
      .pending,
      .complete,
      .failed,
    ]

  }

  init() {}

  fileprivate var _bolt11: String? = nil
  fileprivate var _paymentHash: Data? = nil
  fileprivate var _status: Cln_ListsendpaysRequest.ListsendpaysStatus? = nil
}

struct Cln_ListsendpaysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payments: [Cln_ListsendpaysPayments] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListsendpaysPayments: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var groupid: UInt64 = 0

  var partid: UInt64 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var paymentHash: Data = Data()

  var status: Cln_ListsendpaysPayments.ListsendpaysPaymentsStatus = .pending

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var createdAt: UInt64 = 0

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var erroronion: Data {
    get {return _erroronion ?? Data()}
    set {_erroronion = newValue}
  }
  /// Returns true if `erroronion` has been explicitly set.
  var hasErroronion: Bool {return self._erroronion != nil}
  /// Clears the value of `erroronion`. Subsequent reads from it will return its default value.
  mutating func clearErroronion() {self._erroronion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListSendPays.payments[].status
  enum ListsendpaysPaymentsStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case failed // = 1
    case complete // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .failed
      case 2: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .failed: return 1
      case .complete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListsendpaysPayments.ListsendpaysPaymentsStatus] = [
      .pending,
      .failed,
      .complete,
    ]

  }

  init() {}

  fileprivate var _partid: UInt64? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _destination: Data? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _paymentPreimage: Data? = nil
  fileprivate var _erroronion: Data? = nil
}

struct Cln_ListtransactionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListtransactionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Cln_ListtransactionsTransactions] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListtransactionsTransactions: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Data = Data()

  var rawtx: Data = Data()

  var blockheight: UInt32 = 0

  var txindex: UInt32 = 0

  var locktime: UInt32 = 0

  var version: UInt32 = 0

  var inputs: [Cln_ListtransactionsTransactionsInputs] = []

  var outputs: [Cln_ListtransactionsTransactionsOutputs] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListtransactionsTransactionsInputs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var index: UInt32 = 0

  var sequence: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListtransactionsTransactionsOutputs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var scriptPubKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_PayRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String = String()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var riskfactor: Double {
    get {return _riskfactor ?? 0}
    set {_riskfactor = newValue}
  }
  /// Returns true if `riskfactor` has been explicitly set.
  var hasRiskfactor: Bool {return self._riskfactor != nil}
  /// Clears the value of `riskfactor`. Subsequent reads from it will return its default value.
  mutating func clearRiskfactor() {self._riskfactor = nil}

  var maxfeepercent: Double {
    get {return _maxfeepercent ?? 0}
    set {_maxfeepercent = newValue}
  }
  /// Returns true if `maxfeepercent` has been explicitly set.
  var hasMaxfeepercent: Bool {return self._maxfeepercent != nil}
  /// Clears the value of `maxfeepercent`. Subsequent reads from it will return its default value.
  mutating func clearMaxfeepercent() {self._maxfeepercent = nil}

  var retryFor: UInt32 {
    get {return _retryFor ?? 0}
    set {_retryFor = newValue}
  }
  /// Returns true if `retryFor` has been explicitly set.
  var hasRetryFor: Bool {return self._retryFor != nil}
  /// Clears the value of `retryFor`. Subsequent reads from it will return its default value.
  mutating func clearRetryFor() {self._retryFor = nil}

  var maxdelay: UInt32 {
    get {return _maxdelay ?? 0}
    set {_maxdelay = newValue}
  }
  /// Returns true if `maxdelay` has been explicitly set.
  var hasMaxdelay: Bool {return self._maxdelay != nil}
  /// Clears the value of `maxdelay`. Subsequent reads from it will return its default value.
  mutating func clearMaxdelay() {self._maxdelay = nil}

  var exemptfee: Cln_Amount {
    get {return _exemptfee ?? Cln_Amount()}
    set {_exemptfee = newValue}
  }
  /// Returns true if `exemptfee` has been explicitly set.
  var hasExemptfee: Bool {return self._exemptfee != nil}
  /// Clears the value of `exemptfee`. Subsequent reads from it will return its default value.
  mutating func clearExemptfee() {self._exemptfee = nil}

  var localinvreqid: Data {
    get {return _localinvreqid ?? Data()}
    set {_localinvreqid = newValue}
  }
  /// Returns true if `localinvreqid` has been explicitly set.
  var hasLocalinvreqid: Bool {return self._localinvreqid != nil}
  /// Clears the value of `localinvreqid`. Subsequent reads from it will return its default value.
  mutating func clearLocalinvreqid() {self._localinvreqid = nil}

  var exclude: [String] = []

  var maxfee: Cln_Amount {
    get {return _maxfee ?? Cln_Amount()}
    set {_maxfee = newValue}
  }
  /// Returns true if `maxfee` has been explicitly set.
  var hasMaxfee: Bool {return self._maxfee != nil}
  /// Clears the value of `maxfee`. Subsequent reads from it will return its default value.
  mutating func clearMaxfee() {self._maxfee = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _riskfactor: Double? = nil
  fileprivate var _maxfeepercent: Double? = nil
  fileprivate var _retryFor: UInt32? = nil
  fileprivate var _maxdelay: UInt32? = nil
  fileprivate var _exemptfee: Cln_Amount? = nil
  fileprivate var _localinvreqid: Data? = nil
  fileprivate var _maxfee: Cln_Amount? = nil
  fileprivate var _description_p: String? = nil
}

struct Cln_PayResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentPreimage: Data = Data()

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var paymentHash: Data = Data()

  var createdAt: Double = 0

  var parts: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var warningPartialCompletion: String {
    get {return _warningPartialCompletion ?? String()}
    set {_warningPartialCompletion = newValue}
  }
  /// Returns true if `warningPartialCompletion` has been explicitly set.
  var hasWarningPartialCompletion: Bool {return self._warningPartialCompletion != nil}
  /// Clears the value of `warningPartialCompletion`. Subsequent reads from it will return its default value.
  mutating func clearWarningPartialCompletion() {self._warningPartialCompletion = nil}

  var status: Cln_PayResponse.PayStatus = .complete

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Pay.status
  enum PayStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case complete // = 0
    case pending // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .complete
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .complete
      case 1: self = .pending
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .complete: return 0
      case .pending: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_PayResponse.PayStatus] = [
      .complete,
      .pending,
      .failed,
    ]

  }

  init() {}

  fileprivate var _destination: Data? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _warningPartialCompletion: String? = nil
}

struct Cln_ListnodesRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
}

struct Cln_ListnodesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [Cln_ListnodesNodes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListnodesNodes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeid: Data = Data()

  var lastTimestamp: UInt32 {
    get {return _lastTimestamp ?? 0}
    set {_lastTimestamp = newValue}
  }
  /// Returns true if `lastTimestamp` has been explicitly set.
  var hasLastTimestamp: Bool {return self._lastTimestamp != nil}
  /// Clears the value of `lastTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastTimestamp() {self._lastTimestamp = nil}

  var alias: String {
    get {return _alias ?? String()}
    set {_alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return self._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {self._alias = nil}

  var color: Data {
    get {return _color ?? Data()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var features: Data {
    get {return _features ?? Data()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var addresses: [Cln_ListnodesNodesAddresses] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastTimestamp: UInt32? = nil
  fileprivate var _alias: String? = nil
  fileprivate var _color: Data? = nil
  fileprivate var _features: Data? = nil
}

struct Cln_ListnodesNodesAddresses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_ListnodesNodesAddresses.ListnodesNodesAddressesType = .dns

  var port: UInt32 = 0

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListNodes.nodes[].addresses[].type
  enum ListnodesNodesAddressesType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case dns // = 0
    case ipv4 // = 1
    case ipv6 // = 2
    case torv2 // = 3
    case torv3 // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .dns
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dns
      case 1: self = .ipv4
      case 2: self = .ipv6
      case 3: self = .torv2
      case 4: self = .torv3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .dns: return 0
      case .ipv4: return 1
      case .ipv6: return 2
      case .torv2: return 3
      case .torv3: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListnodesNodesAddresses.ListnodesNodesAddressesType] = [
      .dns,
      .ipv4,
      .ipv6,
      .torv2,
      .torv3,
    ]

  }

  init() {}

  fileprivate var _address: String? = nil
}

struct Cln_WaitanyinvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastpayIndex: UInt64 {
    get {return _lastpayIndex ?? 0}
    set {_lastpayIndex = newValue}
  }
  /// Returns true if `lastpayIndex` has been explicitly set.
  var hasLastpayIndex: Bool {return self._lastpayIndex != nil}
  /// Clears the value of `lastpayIndex`. Subsequent reads from it will return its default value.
  mutating func clearLastpayIndex() {self._lastpayIndex = nil}

  var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastpayIndex: UInt64? = nil
  fileprivate var _timeout: UInt64? = nil
}

struct Cln_WaitanyinvoiceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var description_p: String = String()

  var paymentHash: Data = Data()

  var status: Cln_WaitanyinvoiceResponse.WaitanyinvoiceStatus = .paid

  var expiresAt: UInt64 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var updatedIndex: UInt64 {
    get {return _updatedIndex ?? 0}
    set {_updatedIndex = newValue}
  }
  /// Returns true if `updatedIndex` has been explicitly set.
  var hasUpdatedIndex: Bool {return self._updatedIndex != nil}
  /// Clears the value of `updatedIndex`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedIndex() {self._updatedIndex = nil}

  var payIndex: UInt64 {
    get {return _payIndex ?? 0}
    set {_payIndex = newValue}
  }
  /// Returns true if `payIndex` has been explicitly set.
  var hasPayIndex: Bool {return self._payIndex != nil}
  /// Clears the value of `payIndex`. Subsequent reads from it will return its default value.
  mutating func clearPayIndex() {self._payIndex = nil}

  var amountReceivedMsat: Cln_Amount {
    get {return _amountReceivedMsat ?? Cln_Amount()}
    set {_amountReceivedMsat = newValue}
  }
  /// Returns true if `amountReceivedMsat` has been explicitly set.
  var hasAmountReceivedMsat: Bool {return self._amountReceivedMsat != nil}
  /// Clears the value of `amountReceivedMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountReceivedMsat() {self._amountReceivedMsat = nil}

  var paidAt: UInt64 {
    get {return _paidAt ?? 0}
    set {_paidAt = newValue}
  }
  /// Returns true if `paidAt` has been explicitly set.
  var hasPaidAt: Bool {return self._paidAt != nil}
  /// Clears the value of `paidAt`. Subsequent reads from it will return its default value.
  mutating func clearPaidAt() {self._paidAt = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// WaitAnyInvoice.status
  enum WaitanyinvoiceStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case paid // = 0
    case expired // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .paid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .paid
      case 1: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .paid: return 0
      case .expired: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_WaitanyinvoiceResponse.WaitanyinvoiceStatus] = [
      .paid,
      .expired,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _updatedIndex: UInt64? = nil
  fileprivate var _payIndex: UInt64? = nil
  fileprivate var _amountReceivedMsat: Cln_Amount? = nil
  fileprivate var _paidAt: UInt64? = nil
  fileprivate var _paymentPreimage: Data? = nil
}

struct Cln_WaitinvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_WaitinvoiceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var description_p: String = String()

  var paymentHash: Data = Data()

  var status: Cln_WaitinvoiceResponse.WaitinvoiceStatus = .paid

  var expiresAt: UInt64 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var createdIndex: UInt64 {
    get {return _createdIndex ?? 0}
    set {_createdIndex = newValue}
  }
  /// Returns true if `createdIndex` has been explicitly set.
  var hasCreatedIndex: Bool {return self._createdIndex != nil}
  /// Clears the value of `createdIndex`. Subsequent reads from it will return its default value.
  mutating func clearCreatedIndex() {self._createdIndex = nil}

  var updatedIndex: UInt64 {
    get {return _updatedIndex ?? 0}
    set {_updatedIndex = newValue}
  }
  /// Returns true if `updatedIndex` has been explicitly set.
  var hasUpdatedIndex: Bool {return self._updatedIndex != nil}
  /// Clears the value of `updatedIndex`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedIndex() {self._updatedIndex = nil}

  var payIndex: UInt64 {
    get {return _payIndex ?? 0}
    set {_payIndex = newValue}
  }
  /// Returns true if `payIndex` has been explicitly set.
  var hasPayIndex: Bool {return self._payIndex != nil}
  /// Clears the value of `payIndex`. Subsequent reads from it will return its default value.
  mutating func clearPayIndex() {self._payIndex = nil}

  var amountReceivedMsat: Cln_Amount {
    get {return _amountReceivedMsat ?? Cln_Amount()}
    set {_amountReceivedMsat = newValue}
  }
  /// Returns true if `amountReceivedMsat` has been explicitly set.
  var hasAmountReceivedMsat: Bool {return self._amountReceivedMsat != nil}
  /// Clears the value of `amountReceivedMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountReceivedMsat() {self._amountReceivedMsat = nil}

  var paidAt: UInt64 {
    get {return _paidAt ?? 0}
    set {_paidAt = newValue}
  }
  /// Returns true if `paidAt` has been explicitly set.
  var hasPaidAt: Bool {return self._paidAt != nil}
  /// Clears the value of `paidAt`. Subsequent reads from it will return its default value.
  mutating func clearPaidAt() {self._paidAt = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// WaitInvoice.status
  enum WaitinvoiceStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case paid // = 0
    case expired // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .paid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .paid
      case 1: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .paid: return 0
      case .expired: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_WaitinvoiceResponse.WaitinvoiceStatus] = [
      .paid,
      .expired,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _createdIndex: UInt64? = nil
  fileprivate var _updatedIndex: UInt64? = nil
  fileprivate var _payIndex: UInt64? = nil
  fileprivate var _amountReceivedMsat: Cln_Amount? = nil
  fileprivate var _paidAt: UInt64? = nil
  fileprivate var _paymentPreimage: Data? = nil
}

struct Cln_WaitsendpayRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentHash: Data = Data()

  var timeout: UInt32 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var partid: UInt64 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var groupid: UInt64 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeout: UInt32? = nil
  fileprivate var _partid: UInt64? = nil
  fileprivate var _groupid: UInt64? = nil
}

struct Cln_WaitsendpayResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var groupid: UInt64 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var paymentHash: Data = Data()

  var status: Cln_WaitsendpayResponse.WaitsendpayStatus = .complete

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var createdAt: UInt64 = 0

  var completedAt: Double {
    get {return _completedAt ?? 0}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  mutating func clearCompletedAt() {self._completedAt = nil}

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var partid: UInt64 {
    get {return _partid ?? 0}
    set {_partid = newValue}
  }
  /// Returns true if `partid` has been explicitly set.
  var hasPartid: Bool {return self._partid != nil}
  /// Clears the value of `partid`. Subsequent reads from it will return its default value.
  mutating func clearPartid() {self._partid = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var paymentPreimage: Data {
    get {return _paymentPreimage ?? Data()}
    set {_paymentPreimage = newValue}
  }
  /// Returns true if `paymentPreimage` has been explicitly set.
  var hasPaymentPreimage: Bool {return self._paymentPreimage != nil}
  /// Clears the value of `paymentPreimage`. Subsequent reads from it will return its default value.
  mutating func clearPaymentPreimage() {self._paymentPreimage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// WaitSendPay.status
  enum WaitsendpayStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case complete // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .complete
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .complete: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_WaitsendpayResponse.WaitsendpayStatus] = [
      .complete,
    ]

  }

  init() {}

  fileprivate var _groupid: UInt64? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _destination: Data? = nil
  fileprivate var _completedAt: Double? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _partid: UInt64? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _paymentPreimage: Data? = nil
}

struct Cln_NewaddrRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresstype: Cln_NewaddrRequest.NewaddrAddresstype {
    get {return _addresstype ?? .bech32}
    set {_addresstype = newValue}
  }
  /// Returns true if `addresstype` has been explicitly set.
  var hasAddresstype: Bool {return self._addresstype != nil}
  /// Clears the value of `addresstype`. Subsequent reads from it will return its default value.
  mutating func clearAddresstype() {self._addresstype = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NewAddr.addresstype
  enum NewaddrAddresstype: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case bech32 // = 0
    case p2Tr // = 3
    case all // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .bech32
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bech32
      case 2: self = .all
      case 3: self = .p2Tr
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .bech32: return 0
      case .all: return 2
      case .p2Tr: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_NewaddrRequest.NewaddrAddresstype] = [
      .bech32,
      .p2Tr,
      .all,
    ]

  }

  init() {}

  fileprivate var _addresstype: Cln_NewaddrRequest.NewaddrAddresstype? = nil
}

struct Cln_NewaddrResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var p2Tr: String {
    get {return _p2Tr ?? String()}
    set {_p2Tr = newValue}
  }
  /// Returns true if `p2Tr` has been explicitly set.
  var hasP2Tr: Bool {return self._p2Tr != nil}
  /// Clears the value of `p2Tr`. Subsequent reads from it will return its default value.
  mutating func clearP2Tr() {self._p2Tr = nil}

  var bech32: String {
    get {return _bech32 ?? String()}
    set {_bech32 = newValue}
  }
  /// Returns true if `bech32` has been explicitly set.
  var hasBech32: Bool {return self._bech32 != nil}
  /// Clears the value of `bech32`. Subsequent reads from it will return its default value.
  mutating func clearBech32() {self._bech32 = nil}

  var p2ShSegwit: String {
    get {return _p2ShSegwit ?? String()}
    set {_p2ShSegwit = newValue}
  }
  /// Returns true if `p2ShSegwit` has been explicitly set.
  var hasP2ShSegwit: Bool {return self._p2ShSegwit != nil}
  /// Clears the value of `p2ShSegwit`. Subsequent reads from it will return its default value.
  mutating func clearP2ShSegwit() {self._p2ShSegwit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _p2Tr: String? = nil
  fileprivate var _bech32: String? = nil
  fileprivate var _p2ShSegwit: String? = nil
}

struct Cln_WithdrawRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String = String()

  var satoshi: Cln_AmountOrAll {
    get {return _satoshi ?? Cln_AmountOrAll()}
    set {_satoshi = newValue}
  }
  /// Returns true if `satoshi` has been explicitly set.
  var hasSatoshi: Bool {return self._satoshi != nil}
  /// Clears the value of `satoshi`. Subsequent reads from it will return its default value.
  mutating func clearSatoshi() {self._satoshi = nil}

  var feerate: Cln_Feerate {
    get {return _feerate ?? Cln_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var minconf: UInt32 {
    get {return _minconf ?? 0}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var utxos: [Cln_Outpoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _satoshi: Cln_AmountOrAll? = nil
  fileprivate var _feerate: Cln_Feerate? = nil
  fileprivate var _minconf: UInt32? = nil
}

struct Cln_WithdrawResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var txid: Data = Data()

  var psbt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_KeysendRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: Data = Data()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var maxfeepercent: Double {
    get {return _maxfeepercent ?? 0}
    set {_maxfeepercent = newValue}
  }
  /// Returns true if `maxfeepercent` has been explicitly set.
  var hasMaxfeepercent: Bool {return self._maxfeepercent != nil}
  /// Clears the value of `maxfeepercent`. Subsequent reads from it will return its default value.
  mutating func clearMaxfeepercent() {self._maxfeepercent = nil}

  var retryFor: UInt32 {
    get {return _retryFor ?? 0}
    set {_retryFor = newValue}
  }
  /// Returns true if `retryFor` has been explicitly set.
  var hasRetryFor: Bool {return self._retryFor != nil}
  /// Clears the value of `retryFor`. Subsequent reads from it will return its default value.
  mutating func clearRetryFor() {self._retryFor = nil}

  var maxdelay: UInt32 {
    get {return _maxdelay ?? 0}
    set {_maxdelay = newValue}
  }
  /// Returns true if `maxdelay` has been explicitly set.
  var hasMaxdelay: Bool {return self._maxdelay != nil}
  /// Clears the value of `maxdelay`. Subsequent reads from it will return its default value.
  mutating func clearMaxdelay() {self._maxdelay = nil}

  var exemptfee: Cln_Amount {
    get {return _exemptfee ?? Cln_Amount()}
    set {_exemptfee = newValue}
  }
  /// Returns true if `exemptfee` has been explicitly set.
  var hasExemptfee: Bool {return self._exemptfee != nil}
  /// Clears the value of `exemptfee`. Subsequent reads from it will return its default value.
  mutating func clearExemptfee() {self._exemptfee = nil}

  var routehints: Cln_RoutehintList {
    get {return _routehints ?? Cln_RoutehintList()}
    set {_routehints = newValue}
  }
  /// Returns true if `routehints` has been explicitly set.
  var hasRoutehints: Bool {return self._routehints != nil}
  /// Clears the value of `routehints`. Subsequent reads from it will return its default value.
  mutating func clearRoutehints() {self._routehints = nil}

  var extratlvs: Cln_TlvStream {
    get {return _extratlvs ?? Cln_TlvStream()}
    set {_extratlvs = newValue}
  }
  /// Returns true if `extratlvs` has been explicitly set.
  var hasExtratlvs: Bool {return self._extratlvs != nil}
  /// Clears the value of `extratlvs`. Subsequent reads from it will return its default value.
  mutating func clearExtratlvs() {self._extratlvs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _label: String? = nil
  fileprivate var _maxfeepercent: Double? = nil
  fileprivate var _retryFor: UInt32? = nil
  fileprivate var _maxdelay: UInt32? = nil
  fileprivate var _exemptfee: Cln_Amount? = nil
  fileprivate var _routehints: Cln_RoutehintList? = nil
  fileprivate var _extratlvs: Cln_TlvStream? = nil
}

struct Cln_KeysendResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentPreimage: Data = Data()

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var paymentHash: Data = Data()

  var createdAt: Double = 0

  var parts: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var warningPartialCompletion: String {
    get {return _warningPartialCompletion ?? String()}
    set {_warningPartialCompletion = newValue}
  }
  /// Returns true if `warningPartialCompletion` has been explicitly set.
  var hasWarningPartialCompletion: Bool {return self._warningPartialCompletion != nil}
  /// Clears the value of `warningPartialCompletion`. Subsequent reads from it will return its default value.
  mutating func clearWarningPartialCompletion() {self._warningPartialCompletion = nil}

  var status: Cln_KeysendResponse.KeysendStatus = .complete

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// KeySend.status
  enum KeysendStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case complete // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .complete
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .complete: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_KeysendResponse.KeysendStatus] = [
      .complete,
    ]

  }

  init() {}

  fileprivate var _destination: Data? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _warningPartialCompletion: String? = nil
}

struct Cln_FundpsbtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var satoshi: Cln_AmountOrAll {
    get {return _satoshi ?? Cln_AmountOrAll()}
    set {_satoshi = newValue}
  }
  /// Returns true if `satoshi` has been explicitly set.
  var hasSatoshi: Bool {return self._satoshi != nil}
  /// Clears the value of `satoshi`. Subsequent reads from it will return its default value.
  mutating func clearSatoshi() {self._satoshi = nil}

  var feerate: Cln_Feerate {
    get {return _feerate ?? Cln_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var startweight: UInt32 = 0

  var minconf: UInt32 {
    get {return _minconf ?? 0}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var reserve: UInt32 {
    get {return _reserve ?? 0}
    set {_reserve = newValue}
  }
  /// Returns true if `reserve` has been explicitly set.
  var hasReserve: Bool {return self._reserve != nil}
  /// Clears the value of `reserve`. Subsequent reads from it will return its default value.
  mutating func clearReserve() {self._reserve = nil}

  var locktime: UInt32 {
    get {return _locktime ?? 0}
    set {_locktime = newValue}
  }
  /// Returns true if `locktime` has been explicitly set.
  var hasLocktime: Bool {return self._locktime != nil}
  /// Clears the value of `locktime`. Subsequent reads from it will return its default value.
  mutating func clearLocktime() {self._locktime = nil}

  var minWitnessWeight: UInt32 {
    get {return _minWitnessWeight ?? 0}
    set {_minWitnessWeight = newValue}
  }
  /// Returns true if `minWitnessWeight` has been explicitly set.
  var hasMinWitnessWeight: Bool {return self._minWitnessWeight != nil}
  /// Clears the value of `minWitnessWeight`. Subsequent reads from it will return its default value.
  mutating func clearMinWitnessWeight() {self._minWitnessWeight = nil}

  var excessAsChange: Bool {
    get {return _excessAsChange ?? false}
    set {_excessAsChange = newValue}
  }
  /// Returns true if `excessAsChange` has been explicitly set.
  var hasExcessAsChange: Bool {return self._excessAsChange != nil}
  /// Clears the value of `excessAsChange`. Subsequent reads from it will return its default value.
  mutating func clearExcessAsChange() {self._excessAsChange = nil}

  var nonwrapped: Bool {
    get {return _nonwrapped ?? false}
    set {_nonwrapped = newValue}
  }
  /// Returns true if `nonwrapped` has been explicitly set.
  var hasNonwrapped: Bool {return self._nonwrapped != nil}
  /// Clears the value of `nonwrapped`. Subsequent reads from it will return its default value.
  mutating func clearNonwrapped() {self._nonwrapped = nil}

  var openingAnchorChannel: Bool {
    get {return _openingAnchorChannel ?? false}
    set {_openingAnchorChannel = newValue}
  }
  /// Returns true if `openingAnchorChannel` has been explicitly set.
  var hasOpeningAnchorChannel: Bool {return self._openingAnchorChannel != nil}
  /// Clears the value of `openingAnchorChannel`. Subsequent reads from it will return its default value.
  mutating func clearOpeningAnchorChannel() {self._openingAnchorChannel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _satoshi: Cln_AmountOrAll? = nil
  fileprivate var _feerate: Cln_Feerate? = nil
  fileprivate var _minconf: UInt32? = nil
  fileprivate var _reserve: UInt32? = nil
  fileprivate var _locktime: UInt32? = nil
  fileprivate var _minWitnessWeight: UInt32? = nil
  fileprivate var _excessAsChange: Bool? = nil
  fileprivate var _nonwrapped: Bool? = nil
  fileprivate var _openingAnchorChannel: Bool? = nil
}

struct Cln_FundpsbtResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var feeratePerKw: UInt32 = 0

  var estimatedFinalWeight: UInt32 = 0

  var excessMsat: Cln_Amount {
    get {return _excessMsat ?? Cln_Amount()}
    set {_excessMsat = newValue}
  }
  /// Returns true if `excessMsat` has been explicitly set.
  var hasExcessMsat: Bool {return self._excessMsat != nil}
  /// Clears the value of `excessMsat`. Subsequent reads from it will return its default value.
  mutating func clearExcessMsat() {self._excessMsat = nil}

  var changeOutnum: UInt32 {
    get {return _changeOutnum ?? 0}
    set {_changeOutnum = newValue}
  }
  /// Returns true if `changeOutnum` has been explicitly set.
  var hasChangeOutnum: Bool {return self._changeOutnum != nil}
  /// Clears the value of `changeOutnum`. Subsequent reads from it will return its default value.
  mutating func clearChangeOutnum() {self._changeOutnum = nil}

  var reservations: [Cln_FundpsbtReservations] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _excessMsat: Cln_Amount? = nil
  fileprivate var _changeOutnum: UInt32? = nil
}

struct Cln_FundpsbtReservations: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var vout: UInt32 = 0

  var wasReserved: Bool = false

  var reserved: Bool = false

  var reservedToBlock: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SendpsbtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var reserve: Bool {
    get {return _reserve ?? false}
    set {_reserve = newValue}
  }
  /// Returns true if `reserve` has been explicitly set.
  var hasReserve: Bool {return self._reserve != nil}
  /// Clears the value of `reserve`. Subsequent reads from it will return its default value.
  mutating func clearReserve() {self._reserve = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reserve: Bool? = nil
}

struct Cln_SendpsbtResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SignpsbtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var signonly: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SignpsbtResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signedPsbt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_UtxopsbtRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var satoshi: Cln_Amount {
    get {return _satoshi ?? Cln_Amount()}
    set {_satoshi = newValue}
  }
  /// Returns true if `satoshi` has been explicitly set.
  var hasSatoshi: Bool {return self._satoshi != nil}
  /// Clears the value of `satoshi`. Subsequent reads from it will return its default value.
  mutating func clearSatoshi() {self._satoshi = nil}

  var feerate: Cln_Feerate {
    get {return _feerate ?? Cln_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var startweight: UInt32 = 0

  var utxos: [Cln_Outpoint] = []

  var reserve: UInt32 {
    get {return _reserve ?? 0}
    set {_reserve = newValue}
  }
  /// Returns true if `reserve` has been explicitly set.
  var hasReserve: Bool {return self._reserve != nil}
  /// Clears the value of `reserve`. Subsequent reads from it will return its default value.
  mutating func clearReserve() {self._reserve = nil}

  var reservedok: Bool {
    get {return _reservedok ?? false}
    set {_reservedok = newValue}
  }
  /// Returns true if `reservedok` has been explicitly set.
  var hasReservedok: Bool {return self._reservedok != nil}
  /// Clears the value of `reservedok`. Subsequent reads from it will return its default value.
  mutating func clearReservedok() {self._reservedok = nil}

  var locktime: UInt32 {
    get {return _locktime ?? 0}
    set {_locktime = newValue}
  }
  /// Returns true if `locktime` has been explicitly set.
  var hasLocktime: Bool {return self._locktime != nil}
  /// Clears the value of `locktime`. Subsequent reads from it will return its default value.
  mutating func clearLocktime() {self._locktime = nil}

  var minWitnessWeight: UInt32 {
    get {return _minWitnessWeight ?? 0}
    set {_minWitnessWeight = newValue}
  }
  /// Returns true if `minWitnessWeight` has been explicitly set.
  var hasMinWitnessWeight: Bool {return self._minWitnessWeight != nil}
  /// Clears the value of `minWitnessWeight`. Subsequent reads from it will return its default value.
  mutating func clearMinWitnessWeight() {self._minWitnessWeight = nil}

  var excessAsChange: Bool {
    get {return _excessAsChange ?? false}
    set {_excessAsChange = newValue}
  }
  /// Returns true if `excessAsChange` has been explicitly set.
  var hasExcessAsChange: Bool {return self._excessAsChange != nil}
  /// Clears the value of `excessAsChange`. Subsequent reads from it will return its default value.
  mutating func clearExcessAsChange() {self._excessAsChange = nil}

  var openingAnchorChannel: Bool {
    get {return _openingAnchorChannel ?? false}
    set {_openingAnchorChannel = newValue}
  }
  /// Returns true if `openingAnchorChannel` has been explicitly set.
  var hasOpeningAnchorChannel: Bool {return self._openingAnchorChannel != nil}
  /// Clears the value of `openingAnchorChannel`. Subsequent reads from it will return its default value.
  mutating func clearOpeningAnchorChannel() {self._openingAnchorChannel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _satoshi: Cln_Amount? = nil
  fileprivate var _feerate: Cln_Feerate? = nil
  fileprivate var _reserve: UInt32? = nil
  fileprivate var _reservedok: Bool? = nil
  fileprivate var _locktime: UInt32? = nil
  fileprivate var _minWitnessWeight: UInt32? = nil
  fileprivate var _excessAsChange: Bool? = nil
  fileprivate var _openingAnchorChannel: Bool? = nil
}

struct Cln_UtxopsbtResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var feeratePerKw: UInt32 = 0

  var estimatedFinalWeight: UInt32 = 0

  var excessMsat: Cln_Amount {
    get {return _excessMsat ?? Cln_Amount()}
    set {_excessMsat = newValue}
  }
  /// Returns true if `excessMsat` has been explicitly set.
  var hasExcessMsat: Bool {return self._excessMsat != nil}
  /// Clears the value of `excessMsat`. Subsequent reads from it will return its default value.
  mutating func clearExcessMsat() {self._excessMsat = nil}

  var changeOutnum: UInt32 {
    get {return _changeOutnum ?? 0}
    set {_changeOutnum = newValue}
  }
  /// Returns true if `changeOutnum` has been explicitly set.
  var hasChangeOutnum: Bool {return self._changeOutnum != nil}
  /// Clears the value of `changeOutnum`. Subsequent reads from it will return its default value.
  mutating func clearChangeOutnum() {self._changeOutnum = nil}

  var reservations: [Cln_UtxopsbtReservations] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _excessMsat: Cln_Amount? = nil
  fileprivate var _changeOutnum: UInt32? = nil
}

struct Cln_UtxopsbtReservations: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var vout: UInt32 = 0

  var wasReserved: Bool = false

  var reserved: Bool = false

  var reservedToBlock: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_TxdiscardRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_TxdiscardResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unsignedTx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_TxprepareRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outputs: [Cln_OutputDesc] = []

  var feerate: Cln_Feerate {
    get {return _feerate ?? Cln_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var minconf: UInt32 {
    get {return _minconf ?? 0}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var utxos: [Cln_Outpoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _feerate: Cln_Feerate? = nil
  fileprivate var _minconf: UInt32? = nil
}

struct Cln_TxprepareResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var unsignedTx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_TxsendRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_TxsendResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var psbt: String = String()

  var tx: Data = Data()

  var txid: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListpeerchannelsRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
}

struct Cln_ListpeerchannelsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Cln_ListpeerchannelsChannels] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListpeerchannelsChannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data {
    get {return _storage._peerID ?? Data()}
    set {_uniqueStorage()._peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  var hasPeerID: Bool {return _storage._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  mutating func clearPeerID() {_uniqueStorage()._peerID = nil}

  var peerConnected: Bool {
    get {return _storage._peerConnected ?? false}
    set {_uniqueStorage()._peerConnected = newValue}
  }
  /// Returns true if `peerConnected` has been explicitly set.
  var hasPeerConnected: Bool {return _storage._peerConnected != nil}
  /// Clears the value of `peerConnected`. Subsequent reads from it will return its default value.
  mutating func clearPeerConnected() {_uniqueStorage()._peerConnected = nil}

  var state: Cln_ListpeerchannelsChannels.ListpeerchannelsChannelsState {
    get {return _storage._state ?? .openingd}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var scratchTxid: Data {
    get {return _storage._scratchTxid ?? Data()}
    set {_uniqueStorage()._scratchTxid = newValue}
  }
  /// Returns true if `scratchTxid` has been explicitly set.
  var hasScratchTxid: Bool {return _storage._scratchTxid != nil}
  /// Clears the value of `scratchTxid`. Subsequent reads from it will return its default value.
  mutating func clearScratchTxid() {_uniqueStorage()._scratchTxid = nil}

  var ignoreFeeLimits: Bool {
    get {return _storage._ignoreFeeLimits ?? false}
    set {_uniqueStorage()._ignoreFeeLimits = newValue}
  }
  /// Returns true if `ignoreFeeLimits` has been explicitly set.
  var hasIgnoreFeeLimits: Bool {return _storage._ignoreFeeLimits != nil}
  /// Clears the value of `ignoreFeeLimits`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreFeeLimits() {_uniqueStorage()._ignoreFeeLimits = nil}

  var feerate: Cln_ListpeerchannelsChannelsFeerate {
    get {return _storage._feerate ?? Cln_ListpeerchannelsChannelsFeerate()}
    set {_uniqueStorage()._feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return _storage._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {_uniqueStorage()._feerate = nil}

  var owner: String {
    get {return _storage._owner ?? String()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var shortChannelID: String {
    get {return _storage._shortChannelID ?? String()}
    set {_uniqueStorage()._shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return _storage._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {_uniqueStorage()._shortChannelID = nil}

  var channelID: Data {
    get {return _storage._channelID ?? Data()}
    set {_uniqueStorage()._channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return _storage._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {_uniqueStorage()._channelID = nil}

  var fundingTxid: Data {
    get {return _storage._fundingTxid ?? Data()}
    set {_uniqueStorage()._fundingTxid = newValue}
  }
  /// Returns true if `fundingTxid` has been explicitly set.
  var hasFundingTxid: Bool {return _storage._fundingTxid != nil}
  /// Clears the value of `fundingTxid`. Subsequent reads from it will return its default value.
  mutating func clearFundingTxid() {_uniqueStorage()._fundingTxid = nil}

  var fundingOutnum: UInt32 {
    get {return _storage._fundingOutnum ?? 0}
    set {_uniqueStorage()._fundingOutnum = newValue}
  }
  /// Returns true if `fundingOutnum` has been explicitly set.
  var hasFundingOutnum: Bool {return _storage._fundingOutnum != nil}
  /// Clears the value of `fundingOutnum`. Subsequent reads from it will return its default value.
  mutating func clearFundingOutnum() {_uniqueStorage()._fundingOutnum = nil}

  var initialFeerate: String {
    get {return _storage._initialFeerate ?? String()}
    set {_uniqueStorage()._initialFeerate = newValue}
  }
  /// Returns true if `initialFeerate` has been explicitly set.
  var hasInitialFeerate: Bool {return _storage._initialFeerate != nil}
  /// Clears the value of `initialFeerate`. Subsequent reads from it will return its default value.
  mutating func clearInitialFeerate() {_uniqueStorage()._initialFeerate = nil}

  var lastFeerate: String {
    get {return _storage._lastFeerate ?? String()}
    set {_uniqueStorage()._lastFeerate = newValue}
  }
  /// Returns true if `lastFeerate` has been explicitly set.
  var hasLastFeerate: Bool {return _storage._lastFeerate != nil}
  /// Clears the value of `lastFeerate`. Subsequent reads from it will return its default value.
  mutating func clearLastFeerate() {_uniqueStorage()._lastFeerate = nil}

  var nextFeerate: String {
    get {return _storage._nextFeerate ?? String()}
    set {_uniqueStorage()._nextFeerate = newValue}
  }
  /// Returns true if `nextFeerate` has been explicitly set.
  var hasNextFeerate: Bool {return _storage._nextFeerate != nil}
  /// Clears the value of `nextFeerate`. Subsequent reads from it will return its default value.
  mutating func clearNextFeerate() {_uniqueStorage()._nextFeerate = nil}

  var nextFeeStep: UInt32 {
    get {return _storage._nextFeeStep ?? 0}
    set {_uniqueStorage()._nextFeeStep = newValue}
  }
  /// Returns true if `nextFeeStep` has been explicitly set.
  var hasNextFeeStep: Bool {return _storage._nextFeeStep != nil}
  /// Clears the value of `nextFeeStep`. Subsequent reads from it will return its default value.
  mutating func clearNextFeeStep() {_uniqueStorage()._nextFeeStep = nil}

  var inflight: [Cln_ListpeerchannelsChannelsInflight] {
    get {return _storage._inflight}
    set {_uniqueStorage()._inflight = newValue}
  }

  var closeTo: Data {
    get {return _storage._closeTo ?? Data()}
    set {_uniqueStorage()._closeTo = newValue}
  }
  /// Returns true if `closeTo` has been explicitly set.
  var hasCloseTo: Bool {return _storage._closeTo != nil}
  /// Clears the value of `closeTo`. Subsequent reads from it will return its default value.
  mutating func clearCloseTo() {_uniqueStorage()._closeTo = nil}

  var `private`: Bool {
    get {return _storage._private ?? false}
    set {_uniqueStorage()._private = newValue}
  }
  /// Returns true if ``private`` has been explicitly set.
  var hasPrivate: Bool {return _storage._private != nil}
  /// Clears the value of ``private``. Subsequent reads from it will return its default value.
  mutating func clearPrivate() {_uniqueStorage()._private = nil}

  var opener: Cln_ChannelSide {
    get {return _storage._opener ?? .local}
    set {_uniqueStorage()._opener = newValue}
  }
  /// Returns true if `opener` has been explicitly set.
  var hasOpener: Bool {return _storage._opener != nil}
  /// Clears the value of `opener`. Subsequent reads from it will return its default value.
  mutating func clearOpener() {_uniqueStorage()._opener = nil}

  var closer: Cln_ChannelSide {
    get {return _storage._closer ?? .local}
    set {_uniqueStorage()._closer = newValue}
  }
  /// Returns true if `closer` has been explicitly set.
  var hasCloser: Bool {return _storage._closer != nil}
  /// Clears the value of `closer`. Subsequent reads from it will return its default value.
  mutating func clearCloser() {_uniqueStorage()._closer = nil}

  var funding: Cln_ListpeerchannelsChannelsFunding {
    get {return _storage._funding ?? Cln_ListpeerchannelsChannelsFunding()}
    set {_uniqueStorage()._funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return _storage._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {_uniqueStorage()._funding = nil}

  var toUsMsat: Cln_Amount {
    get {return _storage._toUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._toUsMsat = newValue}
  }
  /// Returns true if `toUsMsat` has been explicitly set.
  var hasToUsMsat: Bool {return _storage._toUsMsat != nil}
  /// Clears the value of `toUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearToUsMsat() {_uniqueStorage()._toUsMsat = nil}

  var minToUsMsat: Cln_Amount {
    get {return _storage._minToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minToUsMsat = newValue}
  }
  /// Returns true if `minToUsMsat` has been explicitly set.
  var hasMinToUsMsat: Bool {return _storage._minToUsMsat != nil}
  /// Clears the value of `minToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinToUsMsat() {_uniqueStorage()._minToUsMsat = nil}

  var maxToUsMsat: Cln_Amount {
    get {return _storage._maxToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maxToUsMsat = newValue}
  }
  /// Returns true if `maxToUsMsat` has been explicitly set.
  var hasMaxToUsMsat: Bool {return _storage._maxToUsMsat != nil}
  /// Clears the value of `maxToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaxToUsMsat() {_uniqueStorage()._maxToUsMsat = nil}

  var totalMsat: Cln_Amount {
    get {return _storage._totalMsat ?? Cln_Amount()}
    set {_uniqueStorage()._totalMsat = newValue}
  }
  /// Returns true if `totalMsat` has been explicitly set.
  var hasTotalMsat: Bool {return _storage._totalMsat != nil}
  /// Clears the value of `totalMsat`. Subsequent reads from it will return its default value.
  mutating func clearTotalMsat() {_uniqueStorage()._totalMsat = nil}

  var feeBaseMsat: Cln_Amount {
    get {return _storage._feeBaseMsat ?? Cln_Amount()}
    set {_uniqueStorage()._feeBaseMsat = newValue}
  }
  /// Returns true if `feeBaseMsat` has been explicitly set.
  var hasFeeBaseMsat: Bool {return _storage._feeBaseMsat != nil}
  /// Clears the value of `feeBaseMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeBaseMsat() {_uniqueStorage()._feeBaseMsat = nil}

  var feeProportionalMillionths: UInt32 {
    get {return _storage._feeProportionalMillionths ?? 0}
    set {_uniqueStorage()._feeProportionalMillionths = newValue}
  }
  /// Returns true if `feeProportionalMillionths` has been explicitly set.
  var hasFeeProportionalMillionths: Bool {return _storage._feeProportionalMillionths != nil}
  /// Clears the value of `feeProportionalMillionths`. Subsequent reads from it will return its default value.
  mutating func clearFeeProportionalMillionths() {_uniqueStorage()._feeProportionalMillionths = nil}

  var dustLimitMsat: Cln_Amount {
    get {return _storage._dustLimitMsat ?? Cln_Amount()}
    set {_uniqueStorage()._dustLimitMsat = newValue}
  }
  /// Returns true if `dustLimitMsat` has been explicitly set.
  var hasDustLimitMsat: Bool {return _storage._dustLimitMsat != nil}
  /// Clears the value of `dustLimitMsat`. Subsequent reads from it will return its default value.
  mutating func clearDustLimitMsat() {_uniqueStorage()._dustLimitMsat = nil}

  var maxTotalHtlcInMsat: Cln_Amount {
    get {return _storage._maxTotalHtlcInMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maxTotalHtlcInMsat = newValue}
  }
  /// Returns true if `maxTotalHtlcInMsat` has been explicitly set.
  var hasMaxTotalHtlcInMsat: Bool {return _storage._maxTotalHtlcInMsat != nil}
  /// Clears the value of `maxTotalHtlcInMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaxTotalHtlcInMsat() {_uniqueStorage()._maxTotalHtlcInMsat = nil}

  var theirReserveMsat: Cln_Amount {
    get {return _storage._theirReserveMsat ?? Cln_Amount()}
    set {_uniqueStorage()._theirReserveMsat = newValue}
  }
  /// Returns true if `theirReserveMsat` has been explicitly set.
  var hasTheirReserveMsat: Bool {return _storage._theirReserveMsat != nil}
  /// Clears the value of `theirReserveMsat`. Subsequent reads from it will return its default value.
  mutating func clearTheirReserveMsat() {_uniqueStorage()._theirReserveMsat = nil}

  var ourReserveMsat: Cln_Amount {
    get {return _storage._ourReserveMsat ?? Cln_Amount()}
    set {_uniqueStorage()._ourReserveMsat = newValue}
  }
  /// Returns true if `ourReserveMsat` has been explicitly set.
  var hasOurReserveMsat: Bool {return _storage._ourReserveMsat != nil}
  /// Clears the value of `ourReserveMsat`. Subsequent reads from it will return its default value.
  mutating func clearOurReserveMsat() {_uniqueStorage()._ourReserveMsat = nil}

  var spendableMsat: Cln_Amount {
    get {return _storage._spendableMsat ?? Cln_Amount()}
    set {_uniqueStorage()._spendableMsat = newValue}
  }
  /// Returns true if `spendableMsat` has been explicitly set.
  var hasSpendableMsat: Bool {return _storage._spendableMsat != nil}
  /// Clears the value of `spendableMsat`. Subsequent reads from it will return its default value.
  mutating func clearSpendableMsat() {_uniqueStorage()._spendableMsat = nil}

  var receivableMsat: Cln_Amount {
    get {return _storage._receivableMsat ?? Cln_Amount()}
    set {_uniqueStorage()._receivableMsat = newValue}
  }
  /// Returns true if `receivableMsat` has been explicitly set.
  var hasReceivableMsat: Bool {return _storage._receivableMsat != nil}
  /// Clears the value of `receivableMsat`. Subsequent reads from it will return its default value.
  mutating func clearReceivableMsat() {_uniqueStorage()._receivableMsat = nil}

  var minimumHtlcInMsat: Cln_Amount {
    get {return _storage._minimumHtlcInMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minimumHtlcInMsat = newValue}
  }
  /// Returns true if `minimumHtlcInMsat` has been explicitly set.
  var hasMinimumHtlcInMsat: Bool {return _storage._minimumHtlcInMsat != nil}
  /// Clears the value of `minimumHtlcInMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinimumHtlcInMsat() {_uniqueStorage()._minimumHtlcInMsat = nil}

  var minimumHtlcOutMsat: Cln_Amount {
    get {return _storage._minimumHtlcOutMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minimumHtlcOutMsat = newValue}
  }
  /// Returns true if `minimumHtlcOutMsat` has been explicitly set.
  var hasMinimumHtlcOutMsat: Bool {return _storage._minimumHtlcOutMsat != nil}
  /// Clears the value of `minimumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinimumHtlcOutMsat() {_uniqueStorage()._minimumHtlcOutMsat = nil}

  var maximumHtlcOutMsat: Cln_Amount {
    get {return _storage._maximumHtlcOutMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maximumHtlcOutMsat = newValue}
  }
  /// Returns true if `maximumHtlcOutMsat` has been explicitly set.
  var hasMaximumHtlcOutMsat: Bool {return _storage._maximumHtlcOutMsat != nil}
  /// Clears the value of `maximumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaximumHtlcOutMsat() {_uniqueStorage()._maximumHtlcOutMsat = nil}

  var theirToSelfDelay: UInt32 {
    get {return _storage._theirToSelfDelay ?? 0}
    set {_uniqueStorage()._theirToSelfDelay = newValue}
  }
  /// Returns true if `theirToSelfDelay` has been explicitly set.
  var hasTheirToSelfDelay: Bool {return _storage._theirToSelfDelay != nil}
  /// Clears the value of `theirToSelfDelay`. Subsequent reads from it will return its default value.
  mutating func clearTheirToSelfDelay() {_uniqueStorage()._theirToSelfDelay = nil}

  var ourToSelfDelay: UInt32 {
    get {return _storage._ourToSelfDelay ?? 0}
    set {_uniqueStorage()._ourToSelfDelay = newValue}
  }
  /// Returns true if `ourToSelfDelay` has been explicitly set.
  var hasOurToSelfDelay: Bool {return _storage._ourToSelfDelay != nil}
  /// Clears the value of `ourToSelfDelay`. Subsequent reads from it will return its default value.
  mutating func clearOurToSelfDelay() {_uniqueStorage()._ourToSelfDelay = nil}

  var maxAcceptedHtlcs: UInt32 {
    get {return _storage._maxAcceptedHtlcs ?? 0}
    set {_uniqueStorage()._maxAcceptedHtlcs = newValue}
  }
  /// Returns true if `maxAcceptedHtlcs` has been explicitly set.
  var hasMaxAcceptedHtlcs: Bool {return _storage._maxAcceptedHtlcs != nil}
  /// Clears the value of `maxAcceptedHtlcs`. Subsequent reads from it will return its default value.
  mutating func clearMaxAcceptedHtlcs() {_uniqueStorage()._maxAcceptedHtlcs = nil}

  var alias: Cln_ListpeerchannelsChannelsAlias {
    get {return _storage._alias ?? Cln_ListpeerchannelsChannelsAlias()}
    set {_uniqueStorage()._alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return _storage._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {_uniqueStorage()._alias = nil}

  var status: [String] {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var inPaymentsOffered: UInt64 {
    get {return _storage._inPaymentsOffered ?? 0}
    set {_uniqueStorage()._inPaymentsOffered = newValue}
  }
  /// Returns true if `inPaymentsOffered` has been explicitly set.
  var hasInPaymentsOffered: Bool {return _storage._inPaymentsOffered != nil}
  /// Clears the value of `inPaymentsOffered`. Subsequent reads from it will return its default value.
  mutating func clearInPaymentsOffered() {_uniqueStorage()._inPaymentsOffered = nil}

  var inOfferedMsat: Cln_Amount {
    get {return _storage._inOfferedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._inOfferedMsat = newValue}
  }
  /// Returns true if `inOfferedMsat` has been explicitly set.
  var hasInOfferedMsat: Bool {return _storage._inOfferedMsat != nil}
  /// Clears the value of `inOfferedMsat`. Subsequent reads from it will return its default value.
  mutating func clearInOfferedMsat() {_uniqueStorage()._inOfferedMsat = nil}

  var inPaymentsFulfilled: UInt64 {
    get {return _storage._inPaymentsFulfilled ?? 0}
    set {_uniqueStorage()._inPaymentsFulfilled = newValue}
  }
  /// Returns true if `inPaymentsFulfilled` has been explicitly set.
  var hasInPaymentsFulfilled: Bool {return _storage._inPaymentsFulfilled != nil}
  /// Clears the value of `inPaymentsFulfilled`. Subsequent reads from it will return its default value.
  mutating func clearInPaymentsFulfilled() {_uniqueStorage()._inPaymentsFulfilled = nil}

  var inFulfilledMsat: Cln_Amount {
    get {return _storage._inFulfilledMsat ?? Cln_Amount()}
    set {_uniqueStorage()._inFulfilledMsat = newValue}
  }
  /// Returns true if `inFulfilledMsat` has been explicitly set.
  var hasInFulfilledMsat: Bool {return _storage._inFulfilledMsat != nil}
  /// Clears the value of `inFulfilledMsat`. Subsequent reads from it will return its default value.
  mutating func clearInFulfilledMsat() {_uniqueStorage()._inFulfilledMsat = nil}

  var outPaymentsOffered: UInt64 {
    get {return _storage._outPaymentsOffered ?? 0}
    set {_uniqueStorage()._outPaymentsOffered = newValue}
  }
  /// Returns true if `outPaymentsOffered` has been explicitly set.
  var hasOutPaymentsOffered: Bool {return _storage._outPaymentsOffered != nil}
  /// Clears the value of `outPaymentsOffered`. Subsequent reads from it will return its default value.
  mutating func clearOutPaymentsOffered() {_uniqueStorage()._outPaymentsOffered = nil}

  var outOfferedMsat: Cln_Amount {
    get {return _storage._outOfferedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._outOfferedMsat = newValue}
  }
  /// Returns true if `outOfferedMsat` has been explicitly set.
  var hasOutOfferedMsat: Bool {return _storage._outOfferedMsat != nil}
  /// Clears the value of `outOfferedMsat`. Subsequent reads from it will return its default value.
  mutating func clearOutOfferedMsat() {_uniqueStorage()._outOfferedMsat = nil}

  var outPaymentsFulfilled: UInt64 {
    get {return _storage._outPaymentsFulfilled ?? 0}
    set {_uniqueStorage()._outPaymentsFulfilled = newValue}
  }
  /// Returns true if `outPaymentsFulfilled` has been explicitly set.
  var hasOutPaymentsFulfilled: Bool {return _storage._outPaymentsFulfilled != nil}
  /// Clears the value of `outPaymentsFulfilled`. Subsequent reads from it will return its default value.
  mutating func clearOutPaymentsFulfilled() {_uniqueStorage()._outPaymentsFulfilled = nil}

  var outFulfilledMsat: Cln_Amount {
    get {return _storage._outFulfilledMsat ?? Cln_Amount()}
    set {_uniqueStorage()._outFulfilledMsat = newValue}
  }
  /// Returns true if `outFulfilledMsat` has been explicitly set.
  var hasOutFulfilledMsat: Bool {return _storage._outFulfilledMsat != nil}
  /// Clears the value of `outFulfilledMsat`. Subsequent reads from it will return its default value.
  mutating func clearOutFulfilledMsat() {_uniqueStorage()._outFulfilledMsat = nil}

  var htlcs: [Cln_ListpeerchannelsChannelsHtlcs] {
    get {return _storage._htlcs}
    set {_uniqueStorage()._htlcs = newValue}
  }

  var closeToAddr: String {
    get {return _storage._closeToAddr ?? String()}
    set {_uniqueStorage()._closeToAddr = newValue}
  }
  /// Returns true if `closeToAddr` has been explicitly set.
  var hasCloseToAddr: Bool {return _storage._closeToAddr != nil}
  /// Clears the value of `closeToAddr`. Subsequent reads from it will return its default value.
  mutating func clearCloseToAddr() {_uniqueStorage()._closeToAddr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPeerChannels.channels[].state
  enum ListpeerchannelsChannelsState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case openingd // = 0
    case channeldAwaitingLockin // = 1
    case channeldNormal // = 2
    case channeldShuttingDown // = 3
    case closingdSigexchange // = 4
    case closingdComplete // = 5
    case awaitingUnilateral // = 6
    case fundingSpendSeen // = 7
    case onchain // = 8
    case dualopendOpenInit // = 9
    case dualopendAwaitingLockin // = 10
    case channeldAwaitingSplice // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .openingd
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .openingd
      case 1: self = .channeldAwaitingLockin
      case 2: self = .channeldNormal
      case 3: self = .channeldShuttingDown
      case 4: self = .closingdSigexchange
      case 5: self = .closingdComplete
      case 6: self = .awaitingUnilateral
      case 7: self = .fundingSpendSeen
      case 8: self = .onchain
      case 9: self = .dualopendOpenInit
      case 10: self = .dualopendAwaitingLockin
      case 11: self = .channeldAwaitingSplice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .openingd: return 0
      case .channeldAwaitingLockin: return 1
      case .channeldNormal: return 2
      case .channeldShuttingDown: return 3
      case .closingdSigexchange: return 4
      case .closingdComplete: return 5
      case .awaitingUnilateral: return 6
      case .fundingSpendSeen: return 7
      case .onchain: return 8
      case .dualopendOpenInit: return 9
      case .dualopendAwaitingLockin: return 10
      case .channeldAwaitingSplice: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpeerchannelsChannels.ListpeerchannelsChannelsState] = [
      .openingd,
      .channeldAwaitingLockin,
      .channeldNormal,
      .channeldShuttingDown,
      .closingdSigexchange,
      .closingdComplete,
      .awaitingUnilateral,
      .fundingSpendSeen,
      .onchain,
      .dualopendOpenInit,
      .dualopendAwaitingLockin,
      .channeldAwaitingSplice,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_ListpeerchannelsChannelsFeerate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var perkw: UInt32 {
    get {return _perkw ?? 0}
    set {_perkw = newValue}
  }
  /// Returns true if `perkw` has been explicitly set.
  var hasPerkw: Bool {return self._perkw != nil}
  /// Clears the value of `perkw`. Subsequent reads from it will return its default value.
  mutating func clearPerkw() {self._perkw = nil}

  var perkb: UInt32 {
    get {return _perkb ?? 0}
    set {_perkb = newValue}
  }
  /// Returns true if `perkb` has been explicitly set.
  var hasPerkb: Bool {return self._perkb != nil}
  /// Clears the value of `perkb`. Subsequent reads from it will return its default value.
  mutating func clearPerkb() {self._perkb = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _perkw: UInt32? = nil
  fileprivate var _perkb: UInt32? = nil
}

struct Cln_ListpeerchannelsChannelsInflight: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundingTxid: Data {
    get {return _fundingTxid ?? Data()}
    set {_fundingTxid = newValue}
  }
  /// Returns true if `fundingTxid` has been explicitly set.
  var hasFundingTxid: Bool {return self._fundingTxid != nil}
  /// Clears the value of `fundingTxid`. Subsequent reads from it will return its default value.
  mutating func clearFundingTxid() {self._fundingTxid = nil}

  var fundingOutnum: UInt32 {
    get {return _fundingOutnum ?? 0}
    set {_fundingOutnum = newValue}
  }
  /// Returns true if `fundingOutnum` has been explicitly set.
  var hasFundingOutnum: Bool {return self._fundingOutnum != nil}
  /// Clears the value of `fundingOutnum`. Subsequent reads from it will return its default value.
  mutating func clearFundingOutnum() {self._fundingOutnum = nil}

  var feerate: String {
    get {return _feerate ?? String()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var totalFundingMsat: Cln_Amount {
    get {return _totalFundingMsat ?? Cln_Amount()}
    set {_totalFundingMsat = newValue}
  }
  /// Returns true if `totalFundingMsat` has been explicitly set.
  var hasTotalFundingMsat: Bool {return self._totalFundingMsat != nil}
  /// Clears the value of `totalFundingMsat`. Subsequent reads from it will return its default value.
  mutating func clearTotalFundingMsat() {self._totalFundingMsat = nil}

  var spliceAmount: Int64 {
    get {return _spliceAmount ?? 0}
    set {_spliceAmount = newValue}
  }
  /// Returns true if `spliceAmount` has been explicitly set.
  var hasSpliceAmount: Bool {return self._spliceAmount != nil}
  /// Clears the value of `spliceAmount`. Subsequent reads from it will return its default value.
  mutating func clearSpliceAmount() {self._spliceAmount = nil}

  var ourFundingMsat: Cln_Amount {
    get {return _ourFundingMsat ?? Cln_Amount()}
    set {_ourFundingMsat = newValue}
  }
  /// Returns true if `ourFundingMsat` has been explicitly set.
  var hasOurFundingMsat: Bool {return self._ourFundingMsat != nil}
  /// Clears the value of `ourFundingMsat`. Subsequent reads from it will return its default value.
  mutating func clearOurFundingMsat() {self._ourFundingMsat = nil}

  var scratchTxid: Data {
    get {return _scratchTxid ?? Data()}
    set {_scratchTxid = newValue}
  }
  /// Returns true if `scratchTxid` has been explicitly set.
  var hasScratchTxid: Bool {return self._scratchTxid != nil}
  /// Clears the value of `scratchTxid`. Subsequent reads from it will return its default value.
  mutating func clearScratchTxid() {self._scratchTxid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fundingTxid: Data? = nil
  fileprivate var _fundingOutnum: UInt32? = nil
  fileprivate var _feerate: String? = nil
  fileprivate var _totalFundingMsat: Cln_Amount? = nil
  fileprivate var _spliceAmount: Int64? = nil
  fileprivate var _ourFundingMsat: Cln_Amount? = nil
  fileprivate var _scratchTxid: Data? = nil
}

struct Cln_ListpeerchannelsChannelsFunding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pushedMsat: Cln_Amount {
    get {return _pushedMsat ?? Cln_Amount()}
    set {_pushedMsat = newValue}
  }
  /// Returns true if `pushedMsat` has been explicitly set.
  var hasPushedMsat: Bool {return self._pushedMsat != nil}
  /// Clears the value of `pushedMsat`. Subsequent reads from it will return its default value.
  mutating func clearPushedMsat() {self._pushedMsat = nil}

  var localFundsMsat: Cln_Amount {
    get {return _localFundsMsat ?? Cln_Amount()}
    set {_localFundsMsat = newValue}
  }
  /// Returns true if `localFundsMsat` has been explicitly set.
  var hasLocalFundsMsat: Bool {return self._localFundsMsat != nil}
  /// Clears the value of `localFundsMsat`. Subsequent reads from it will return its default value.
  mutating func clearLocalFundsMsat() {self._localFundsMsat = nil}

  var remoteFundsMsat: Cln_Amount {
    get {return _remoteFundsMsat ?? Cln_Amount()}
    set {_remoteFundsMsat = newValue}
  }
  /// Returns true if `remoteFundsMsat` has been explicitly set.
  var hasRemoteFundsMsat: Bool {return self._remoteFundsMsat != nil}
  /// Clears the value of `remoteFundsMsat`. Subsequent reads from it will return its default value.
  mutating func clearRemoteFundsMsat() {self._remoteFundsMsat = nil}

  var feePaidMsat: Cln_Amount {
    get {return _feePaidMsat ?? Cln_Amount()}
    set {_feePaidMsat = newValue}
  }
  /// Returns true if `feePaidMsat` has been explicitly set.
  var hasFeePaidMsat: Bool {return self._feePaidMsat != nil}
  /// Clears the value of `feePaidMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeePaidMsat() {self._feePaidMsat = nil}

  var feeRcvdMsat: Cln_Amount {
    get {return _feeRcvdMsat ?? Cln_Amount()}
    set {_feeRcvdMsat = newValue}
  }
  /// Returns true if `feeRcvdMsat` has been explicitly set.
  var hasFeeRcvdMsat: Bool {return self._feeRcvdMsat != nil}
  /// Clears the value of `feeRcvdMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeRcvdMsat() {self._feeRcvdMsat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pushedMsat: Cln_Amount? = nil
  fileprivate var _localFundsMsat: Cln_Amount? = nil
  fileprivate var _remoteFundsMsat: Cln_Amount? = nil
  fileprivate var _feePaidMsat: Cln_Amount? = nil
  fileprivate var _feeRcvdMsat: Cln_Amount? = nil
}

struct Cln_ListpeerchannelsChannelsAlias: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var local: String {
    get {return _local ?? String()}
    set {_local = newValue}
  }
  /// Returns true if `local` has been explicitly set.
  var hasLocal: Bool {return self._local != nil}
  /// Clears the value of `local`. Subsequent reads from it will return its default value.
  mutating func clearLocal() {self._local = nil}

  var remote: String {
    get {return _remote ?? String()}
    set {_remote = newValue}
  }
  /// Returns true if `remote` has been explicitly set.
  var hasRemote: Bool {return self._remote != nil}
  /// Clears the value of `remote`. Subsequent reads from it will return its default value.
  mutating func clearRemote() {self._remote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _local: String? = nil
  fileprivate var _remote: String? = nil
}

struct Cln_ListpeerchannelsChannelsHtlcs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var direction: Cln_ListpeerchannelsChannelsHtlcs.ListpeerchannelsChannelsHtlcsDirection {
    get {return _direction ?? .in}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var expiry: UInt32 {
    get {return _expiry ?? 0}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  mutating func clearExpiry() {self._expiry = nil}

  var paymentHash: Data {
    get {return _paymentHash ?? Data()}
    set {_paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return self._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {self._paymentHash = nil}

  var localTrimmed: Bool {
    get {return _localTrimmed ?? false}
    set {_localTrimmed = newValue}
  }
  /// Returns true if `localTrimmed` has been explicitly set.
  var hasLocalTrimmed: Bool {return self._localTrimmed != nil}
  /// Clears the value of `localTrimmed`. Subsequent reads from it will return its default value.
  mutating func clearLocalTrimmed() {self._localTrimmed = nil}

  var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var state: Cln_HtlcState {
    get {return _state ?? .sentAddHtlc}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPeerChannels.channels[].htlcs[].direction
  enum ListpeerchannelsChannelsHtlcsDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `in` // = 0
    case out // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .in
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .in
      case 1: self = .out
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .in: return 0
      case .out: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpeerchannelsChannelsHtlcs.ListpeerchannelsChannelsHtlcsDirection] = [
      .in,
      .out,
    ]

  }

  init() {}

  fileprivate var _direction: Cln_ListpeerchannelsChannelsHtlcs.ListpeerchannelsChannelsHtlcsDirection? = nil
  fileprivate var _id: UInt64? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _expiry: UInt32? = nil
  fileprivate var _paymentHash: Data? = nil
  fileprivate var _localTrimmed: Bool? = nil
  fileprivate var _status: String? = nil
  fileprivate var _state: Cln_HtlcState? = nil
}

struct Cln_ListclosedchannelsRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Data? = nil
}

struct Cln_ListclosedchannelsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closedchannels: [Cln_ListclosedchannelsClosedchannels] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListclosedchannelsClosedchannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data {
    get {return _storage._peerID ?? Data()}
    set {_uniqueStorage()._peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  var hasPeerID: Bool {return _storage._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  mutating func clearPeerID() {_uniqueStorage()._peerID = nil}

  var channelID: Data {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  var shortChannelID: String {
    get {return _storage._shortChannelID ?? String()}
    set {_uniqueStorage()._shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return _storage._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {_uniqueStorage()._shortChannelID = nil}

  var alias: Cln_ListclosedchannelsClosedchannelsAlias {
    get {return _storage._alias ?? Cln_ListclosedchannelsClosedchannelsAlias()}
    set {_uniqueStorage()._alias = newValue}
  }
  /// Returns true if `alias` has been explicitly set.
  var hasAlias: Bool {return _storage._alias != nil}
  /// Clears the value of `alias`. Subsequent reads from it will return its default value.
  mutating func clearAlias() {_uniqueStorage()._alias = nil}

  var opener: Cln_ChannelSide {
    get {return _storage._opener}
    set {_uniqueStorage()._opener = newValue}
  }

  var closer: Cln_ChannelSide {
    get {return _storage._closer ?? .local}
    set {_uniqueStorage()._closer = newValue}
  }
  /// Returns true if `closer` has been explicitly set.
  var hasCloser: Bool {return _storage._closer != nil}
  /// Clears the value of `closer`. Subsequent reads from it will return its default value.
  mutating func clearCloser() {_uniqueStorage()._closer = nil}

  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  var totalLocalCommitments: UInt64 {
    get {return _storage._totalLocalCommitments}
    set {_uniqueStorage()._totalLocalCommitments = newValue}
  }

  var totalRemoteCommitments: UInt64 {
    get {return _storage._totalRemoteCommitments}
    set {_uniqueStorage()._totalRemoteCommitments = newValue}
  }

  var totalHtlcsSent: UInt64 {
    get {return _storage._totalHtlcsSent}
    set {_uniqueStorage()._totalHtlcsSent = newValue}
  }

  var fundingTxid: Data {
    get {return _storage._fundingTxid}
    set {_uniqueStorage()._fundingTxid = newValue}
  }

  var fundingOutnum: UInt32 {
    get {return _storage._fundingOutnum}
    set {_uniqueStorage()._fundingOutnum = newValue}
  }

  var leased: Bool {
    get {return _storage._leased}
    set {_uniqueStorage()._leased = newValue}
  }

  var fundingFeePaidMsat: Cln_Amount {
    get {return _storage._fundingFeePaidMsat ?? Cln_Amount()}
    set {_uniqueStorage()._fundingFeePaidMsat = newValue}
  }
  /// Returns true if `fundingFeePaidMsat` has been explicitly set.
  var hasFundingFeePaidMsat: Bool {return _storage._fundingFeePaidMsat != nil}
  /// Clears the value of `fundingFeePaidMsat`. Subsequent reads from it will return its default value.
  mutating func clearFundingFeePaidMsat() {_uniqueStorage()._fundingFeePaidMsat = nil}

  var fundingFeeRcvdMsat: Cln_Amount {
    get {return _storage._fundingFeeRcvdMsat ?? Cln_Amount()}
    set {_uniqueStorage()._fundingFeeRcvdMsat = newValue}
  }
  /// Returns true if `fundingFeeRcvdMsat` has been explicitly set.
  var hasFundingFeeRcvdMsat: Bool {return _storage._fundingFeeRcvdMsat != nil}
  /// Clears the value of `fundingFeeRcvdMsat`. Subsequent reads from it will return its default value.
  mutating func clearFundingFeeRcvdMsat() {_uniqueStorage()._fundingFeeRcvdMsat = nil}

  var fundingPushedMsat: Cln_Amount {
    get {return _storage._fundingPushedMsat ?? Cln_Amount()}
    set {_uniqueStorage()._fundingPushedMsat = newValue}
  }
  /// Returns true if `fundingPushedMsat` has been explicitly set.
  var hasFundingPushedMsat: Bool {return _storage._fundingPushedMsat != nil}
  /// Clears the value of `fundingPushedMsat`. Subsequent reads from it will return its default value.
  mutating func clearFundingPushedMsat() {_uniqueStorage()._fundingPushedMsat = nil}

  var totalMsat: Cln_Amount {
    get {return _storage._totalMsat ?? Cln_Amount()}
    set {_uniqueStorage()._totalMsat = newValue}
  }
  /// Returns true if `totalMsat` has been explicitly set.
  var hasTotalMsat: Bool {return _storage._totalMsat != nil}
  /// Clears the value of `totalMsat`. Subsequent reads from it will return its default value.
  mutating func clearTotalMsat() {_uniqueStorage()._totalMsat = nil}

  var finalToUsMsat: Cln_Amount {
    get {return _storage._finalToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._finalToUsMsat = newValue}
  }
  /// Returns true if `finalToUsMsat` has been explicitly set.
  var hasFinalToUsMsat: Bool {return _storage._finalToUsMsat != nil}
  /// Clears the value of `finalToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearFinalToUsMsat() {_uniqueStorage()._finalToUsMsat = nil}

  var minToUsMsat: Cln_Amount {
    get {return _storage._minToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._minToUsMsat = newValue}
  }
  /// Returns true if `minToUsMsat` has been explicitly set.
  var hasMinToUsMsat: Bool {return _storage._minToUsMsat != nil}
  /// Clears the value of `minToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinToUsMsat() {_uniqueStorage()._minToUsMsat = nil}

  var maxToUsMsat: Cln_Amount {
    get {return _storage._maxToUsMsat ?? Cln_Amount()}
    set {_uniqueStorage()._maxToUsMsat = newValue}
  }
  /// Returns true if `maxToUsMsat` has been explicitly set.
  var hasMaxToUsMsat: Bool {return _storage._maxToUsMsat != nil}
  /// Clears the value of `maxToUsMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaxToUsMsat() {_uniqueStorage()._maxToUsMsat = nil}

  var lastCommitmentTxid: Data {
    get {return _storage._lastCommitmentTxid ?? Data()}
    set {_uniqueStorage()._lastCommitmentTxid = newValue}
  }
  /// Returns true if `lastCommitmentTxid` has been explicitly set.
  var hasLastCommitmentTxid: Bool {return _storage._lastCommitmentTxid != nil}
  /// Clears the value of `lastCommitmentTxid`. Subsequent reads from it will return its default value.
  mutating func clearLastCommitmentTxid() {_uniqueStorage()._lastCommitmentTxid = nil}

  var lastCommitmentFeeMsat: Cln_Amount {
    get {return _storage._lastCommitmentFeeMsat ?? Cln_Amount()}
    set {_uniqueStorage()._lastCommitmentFeeMsat = newValue}
  }
  /// Returns true if `lastCommitmentFeeMsat` has been explicitly set.
  var hasLastCommitmentFeeMsat: Bool {return _storage._lastCommitmentFeeMsat != nil}
  /// Clears the value of `lastCommitmentFeeMsat`. Subsequent reads from it will return its default value.
  mutating func clearLastCommitmentFeeMsat() {_uniqueStorage()._lastCommitmentFeeMsat = nil}

  var closeCause: Cln_ListclosedchannelsClosedchannels.ListclosedchannelsClosedchannelsClose_cause {
    get {return _storage._closeCause}
    set {_uniqueStorage()._closeCause = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListClosedChannels.closedchannels[].close_cause
  enum ListclosedchannelsClosedchannelsClose_cause: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case local // = 1
    case user // = 2
    case remote // = 3
    case `protocol` // = 4
    case onchain // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .local
      case 2: self = .user
      case 3: self = .remote
      case 4: self = .protocol
      case 5: self = .onchain
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .local: return 1
      case .user: return 2
      case .remote: return 3
      case .protocol: return 4
      case .onchain: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListclosedchannelsClosedchannels.ListclosedchannelsClosedchannelsClose_cause] = [
      .unknown,
      .local,
      .user,
      .remote,
      .protocol,
      .onchain,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_ListclosedchannelsClosedchannelsAlias: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var local: String {
    get {return _local ?? String()}
    set {_local = newValue}
  }
  /// Returns true if `local` has been explicitly set.
  var hasLocal: Bool {return self._local != nil}
  /// Clears the value of `local`. Subsequent reads from it will return its default value.
  mutating func clearLocal() {self._local = nil}

  var remote: String {
    get {return _remote ?? String()}
    set {_remote = newValue}
  }
  /// Returns true if `remote` has been explicitly set.
  var hasRemote: Bool {return self._remote != nil}
  /// Clears the value of `remote`. Subsequent reads from it will return its default value.
  mutating func clearRemote() {self._remote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _local: String? = nil
  fileprivate var _remote: String? = nil
}

struct Cln_DecodepayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String = String()

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: String? = nil
}

struct Cln_DecodepayResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currency: String = String()

  var createdAt: UInt64 = 0

  var expiry: UInt64 = 0

  var payee: Data = Data()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var paymentHash: Data = Data()

  var signature: String = String()

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var descriptionHash: Data {
    get {return _descriptionHash ?? Data()}
    set {_descriptionHash = newValue}
  }
  /// Returns true if `descriptionHash` has been explicitly set.
  var hasDescriptionHash: Bool {return self._descriptionHash != nil}
  /// Clears the value of `descriptionHash`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionHash() {self._descriptionHash = nil}

  var minFinalCltvExpiry: UInt32 = 0

  var paymentSecret: Data {
    get {return _paymentSecret ?? Data()}
    set {_paymentSecret = newValue}
  }
  /// Returns true if `paymentSecret` has been explicitly set.
  var hasPaymentSecret: Bool {return self._paymentSecret != nil}
  /// Clears the value of `paymentSecret`. Subsequent reads from it will return its default value.
  mutating func clearPaymentSecret() {self._paymentSecret = nil}

  var features: Data {
    get {return _features ?? Data()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  var paymentMetadata: Data {
    get {return _paymentMetadata ?? Data()}
    set {_paymentMetadata = newValue}
  }
  /// Returns true if `paymentMetadata` has been explicitly set.
  var hasPaymentMetadata: Bool {return self._paymentMetadata != nil}
  /// Clears the value of `paymentMetadata`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMetadata() {self._paymentMetadata = nil}

  var fallbacks: [Cln_DecodepayFallbacks] = []

  var extra: [Cln_DecodepayExtra] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _descriptionHash: Data? = nil
  fileprivate var _paymentSecret: Data? = nil
  fileprivate var _features: Data? = nil
  fileprivate var _paymentMetadata: Data? = nil
}

struct Cln_DecodepayFallbacks: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_DecodepayFallbacks.DecodepayFallbacksType = .p2Pkh

  var addr: String {
    get {return _addr ?? String()}
    set {_addr = newValue}
  }
  /// Returns true if `addr` has been explicitly set.
  var hasAddr: Bool {return self._addr != nil}
  /// Clears the value of `addr`. Subsequent reads from it will return its default value.
  mutating func clearAddr() {self._addr = nil}

  var hex: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DecodePay.fallbacks[].type
  enum DecodepayFallbacksType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case p2Pkh // = 0
    case p2Sh // = 1
    case p2Wpkh // = 2
    case p2Wsh // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .p2Pkh
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .p2Pkh
      case 1: self = .p2Sh
      case 2: self = .p2Wpkh
      case 3: self = .p2Wsh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .p2Pkh: return 0
      case .p2Sh: return 1
      case .p2Wpkh: return 2
      case .p2Wsh: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_DecodepayFallbacks.DecodepayFallbacksType] = [
      .p2Pkh,
      .p2Sh,
      .p2Wpkh,
      .p2Wsh,
    ]

  }

  init() {}

  fileprivate var _addr: String? = nil
}

struct Cln_DecodepayExtra: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: String = String()

  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DecodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DecodeResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var itemType: Cln_DecodeResponse.DecodeType {
    get {return _storage._itemType}
    set {_uniqueStorage()._itemType = newValue}
  }

  var valid: Bool {
    get {return _storage._valid}
    set {_uniqueStorage()._valid = newValue}
  }

  var offerID: Data {
    get {return _storage._offerID ?? Data()}
    set {_uniqueStorage()._offerID = newValue}
  }
  /// Returns true if `offerID` has been explicitly set.
  var hasOfferID: Bool {return _storage._offerID != nil}
  /// Clears the value of `offerID`. Subsequent reads from it will return its default value.
  mutating func clearOfferID() {_uniqueStorage()._offerID = nil}

  var offerChains: [Data] {
    get {return _storage._offerChains}
    set {_uniqueStorage()._offerChains = newValue}
  }

  var offerMetadata: Data {
    get {return _storage._offerMetadata ?? Data()}
    set {_uniqueStorage()._offerMetadata = newValue}
  }
  /// Returns true if `offerMetadata` has been explicitly set.
  var hasOfferMetadata: Bool {return _storage._offerMetadata != nil}
  /// Clears the value of `offerMetadata`. Subsequent reads from it will return its default value.
  mutating func clearOfferMetadata() {_uniqueStorage()._offerMetadata = nil}

  var offerCurrency: String {
    get {return _storage._offerCurrency ?? String()}
    set {_uniqueStorage()._offerCurrency = newValue}
  }
  /// Returns true if `offerCurrency` has been explicitly set.
  var hasOfferCurrency: Bool {return _storage._offerCurrency != nil}
  /// Clears the value of `offerCurrency`. Subsequent reads from it will return its default value.
  mutating func clearOfferCurrency() {_uniqueStorage()._offerCurrency = nil}

  var warningUnknownOfferCurrency: String {
    get {return _storage._warningUnknownOfferCurrency ?? String()}
    set {_uniqueStorage()._warningUnknownOfferCurrency = newValue}
  }
  /// Returns true if `warningUnknownOfferCurrency` has been explicitly set.
  var hasWarningUnknownOfferCurrency: Bool {return _storage._warningUnknownOfferCurrency != nil}
  /// Clears the value of `warningUnknownOfferCurrency`. Subsequent reads from it will return its default value.
  mutating func clearWarningUnknownOfferCurrency() {_uniqueStorage()._warningUnknownOfferCurrency = nil}

  var currencyMinorUnit: UInt32 {
    get {return _storage._currencyMinorUnit ?? 0}
    set {_uniqueStorage()._currencyMinorUnit = newValue}
  }
  /// Returns true if `currencyMinorUnit` has been explicitly set.
  var hasCurrencyMinorUnit: Bool {return _storage._currencyMinorUnit != nil}
  /// Clears the value of `currencyMinorUnit`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyMinorUnit() {_uniqueStorage()._currencyMinorUnit = nil}

  var offerAmount: UInt64 {
    get {return _storage._offerAmount ?? 0}
    set {_uniqueStorage()._offerAmount = newValue}
  }
  /// Returns true if `offerAmount` has been explicitly set.
  var hasOfferAmount: Bool {return _storage._offerAmount != nil}
  /// Clears the value of `offerAmount`. Subsequent reads from it will return its default value.
  mutating func clearOfferAmount() {_uniqueStorage()._offerAmount = nil}

  var offerAmountMsat: Cln_Amount {
    get {return _storage._offerAmountMsat ?? Cln_Amount()}
    set {_uniqueStorage()._offerAmountMsat = newValue}
  }
  /// Returns true if `offerAmountMsat` has been explicitly set.
  var hasOfferAmountMsat: Bool {return _storage._offerAmountMsat != nil}
  /// Clears the value of `offerAmountMsat`. Subsequent reads from it will return its default value.
  mutating func clearOfferAmountMsat() {_uniqueStorage()._offerAmountMsat = nil}

  var offerDescription: String {
    get {return _storage._offerDescription ?? String()}
    set {_uniqueStorage()._offerDescription = newValue}
  }
  /// Returns true if `offerDescription` has been explicitly set.
  var hasOfferDescription: Bool {return _storage._offerDescription != nil}
  /// Clears the value of `offerDescription`. Subsequent reads from it will return its default value.
  mutating func clearOfferDescription() {_uniqueStorage()._offerDescription = nil}

  var offerIssuer: String {
    get {return _storage._offerIssuer ?? String()}
    set {_uniqueStorage()._offerIssuer = newValue}
  }
  /// Returns true if `offerIssuer` has been explicitly set.
  var hasOfferIssuer: Bool {return _storage._offerIssuer != nil}
  /// Clears the value of `offerIssuer`. Subsequent reads from it will return its default value.
  mutating func clearOfferIssuer() {_uniqueStorage()._offerIssuer = nil}

  var offerFeatures: Data {
    get {return _storage._offerFeatures ?? Data()}
    set {_uniqueStorage()._offerFeatures = newValue}
  }
  /// Returns true if `offerFeatures` has been explicitly set.
  var hasOfferFeatures: Bool {return _storage._offerFeatures != nil}
  /// Clears the value of `offerFeatures`. Subsequent reads from it will return its default value.
  mutating func clearOfferFeatures() {_uniqueStorage()._offerFeatures = nil}

  var offerAbsoluteExpiry: UInt64 {
    get {return _storage._offerAbsoluteExpiry ?? 0}
    set {_uniqueStorage()._offerAbsoluteExpiry = newValue}
  }
  /// Returns true if `offerAbsoluteExpiry` has been explicitly set.
  var hasOfferAbsoluteExpiry: Bool {return _storage._offerAbsoluteExpiry != nil}
  /// Clears the value of `offerAbsoluteExpiry`. Subsequent reads from it will return its default value.
  mutating func clearOfferAbsoluteExpiry() {_uniqueStorage()._offerAbsoluteExpiry = nil}

  var offerQuantityMax: UInt64 {
    get {return _storage._offerQuantityMax ?? 0}
    set {_uniqueStorage()._offerQuantityMax = newValue}
  }
  /// Returns true if `offerQuantityMax` has been explicitly set.
  var hasOfferQuantityMax: Bool {return _storage._offerQuantityMax != nil}
  /// Clears the value of `offerQuantityMax`. Subsequent reads from it will return its default value.
  mutating func clearOfferQuantityMax() {_uniqueStorage()._offerQuantityMax = nil}

  var offerPaths: [Cln_DecodeOffer_paths] {
    get {return _storage._offerPaths}
    set {_uniqueStorage()._offerPaths = newValue}
  }

  var offerNodeID: Data {
    get {return _storage._offerNodeID ?? Data()}
    set {_uniqueStorage()._offerNodeID = newValue}
  }
  /// Returns true if `offerNodeID` has been explicitly set.
  var hasOfferNodeID: Bool {return _storage._offerNodeID != nil}
  /// Clears the value of `offerNodeID`. Subsequent reads from it will return its default value.
  mutating func clearOfferNodeID() {_uniqueStorage()._offerNodeID = nil}

  var warningMissingOfferNodeID: String {
    get {return _storage._warningMissingOfferNodeID ?? String()}
    set {_uniqueStorage()._warningMissingOfferNodeID = newValue}
  }
  /// Returns true if `warningMissingOfferNodeID` has been explicitly set.
  var hasWarningMissingOfferNodeID: Bool {return _storage._warningMissingOfferNodeID != nil}
  /// Clears the value of `warningMissingOfferNodeID`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingOfferNodeID() {_uniqueStorage()._warningMissingOfferNodeID = nil}

  var warningInvalidOfferDescription: String {
    get {return _storage._warningInvalidOfferDescription ?? String()}
    set {_uniqueStorage()._warningInvalidOfferDescription = newValue}
  }
  /// Returns true if `warningInvalidOfferDescription` has been explicitly set.
  var hasWarningInvalidOfferDescription: Bool {return _storage._warningInvalidOfferDescription != nil}
  /// Clears the value of `warningInvalidOfferDescription`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidOfferDescription() {_uniqueStorage()._warningInvalidOfferDescription = nil}

  var warningMissingOfferDescription: String {
    get {return _storage._warningMissingOfferDescription ?? String()}
    set {_uniqueStorage()._warningMissingOfferDescription = newValue}
  }
  /// Returns true if `warningMissingOfferDescription` has been explicitly set.
  var hasWarningMissingOfferDescription: Bool {return _storage._warningMissingOfferDescription != nil}
  /// Clears the value of `warningMissingOfferDescription`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingOfferDescription() {_uniqueStorage()._warningMissingOfferDescription = nil}

  var warningInvalidOfferCurrency: String {
    get {return _storage._warningInvalidOfferCurrency ?? String()}
    set {_uniqueStorage()._warningInvalidOfferCurrency = newValue}
  }
  /// Returns true if `warningInvalidOfferCurrency` has been explicitly set.
  var hasWarningInvalidOfferCurrency: Bool {return _storage._warningInvalidOfferCurrency != nil}
  /// Clears the value of `warningInvalidOfferCurrency`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidOfferCurrency() {_uniqueStorage()._warningInvalidOfferCurrency = nil}

  var warningInvalidOfferIssuer: String {
    get {return _storage._warningInvalidOfferIssuer ?? String()}
    set {_uniqueStorage()._warningInvalidOfferIssuer = newValue}
  }
  /// Returns true if `warningInvalidOfferIssuer` has been explicitly set.
  var hasWarningInvalidOfferIssuer: Bool {return _storage._warningInvalidOfferIssuer != nil}
  /// Clears the value of `warningInvalidOfferIssuer`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidOfferIssuer() {_uniqueStorage()._warningInvalidOfferIssuer = nil}

  var invreqMetadata: Data {
    get {return _storage._invreqMetadata ?? Data()}
    set {_uniqueStorage()._invreqMetadata = newValue}
  }
  /// Returns true if `invreqMetadata` has been explicitly set.
  var hasInvreqMetadata: Bool {return _storage._invreqMetadata != nil}
  /// Clears the value of `invreqMetadata`. Subsequent reads from it will return its default value.
  mutating func clearInvreqMetadata() {_uniqueStorage()._invreqMetadata = nil}

  var invreqPayerID: Data {
    get {return _storage._invreqPayerID ?? Data()}
    set {_uniqueStorage()._invreqPayerID = newValue}
  }
  /// Returns true if `invreqPayerID` has been explicitly set.
  var hasInvreqPayerID: Bool {return _storage._invreqPayerID != nil}
  /// Clears the value of `invreqPayerID`. Subsequent reads from it will return its default value.
  mutating func clearInvreqPayerID() {_uniqueStorage()._invreqPayerID = nil}

  var invreqChain: Data {
    get {return _storage._invreqChain ?? Data()}
    set {_uniqueStorage()._invreqChain = newValue}
  }
  /// Returns true if `invreqChain` has been explicitly set.
  var hasInvreqChain: Bool {return _storage._invreqChain != nil}
  /// Clears the value of `invreqChain`. Subsequent reads from it will return its default value.
  mutating func clearInvreqChain() {_uniqueStorage()._invreqChain = nil}

  var invreqAmountMsat: Cln_Amount {
    get {return _storage._invreqAmountMsat ?? Cln_Amount()}
    set {_uniqueStorage()._invreqAmountMsat = newValue}
  }
  /// Returns true if `invreqAmountMsat` has been explicitly set.
  var hasInvreqAmountMsat: Bool {return _storage._invreqAmountMsat != nil}
  /// Clears the value of `invreqAmountMsat`. Subsequent reads from it will return its default value.
  mutating func clearInvreqAmountMsat() {_uniqueStorage()._invreqAmountMsat = nil}

  var invreqFeatures: Data {
    get {return _storage._invreqFeatures ?? Data()}
    set {_uniqueStorage()._invreqFeatures = newValue}
  }
  /// Returns true if `invreqFeatures` has been explicitly set.
  var hasInvreqFeatures: Bool {return _storage._invreqFeatures != nil}
  /// Clears the value of `invreqFeatures`. Subsequent reads from it will return its default value.
  mutating func clearInvreqFeatures() {_uniqueStorage()._invreqFeatures = nil}

  var invreqQuantity: UInt64 {
    get {return _storage._invreqQuantity ?? 0}
    set {_uniqueStorage()._invreqQuantity = newValue}
  }
  /// Returns true if `invreqQuantity` has been explicitly set.
  var hasInvreqQuantity: Bool {return _storage._invreqQuantity != nil}
  /// Clears the value of `invreqQuantity`. Subsequent reads from it will return its default value.
  mutating func clearInvreqQuantity() {_uniqueStorage()._invreqQuantity = nil}

  var invreqPayerNote: String {
    get {return _storage._invreqPayerNote ?? String()}
    set {_uniqueStorage()._invreqPayerNote = newValue}
  }
  /// Returns true if `invreqPayerNote` has been explicitly set.
  var hasInvreqPayerNote: Bool {return _storage._invreqPayerNote != nil}
  /// Clears the value of `invreqPayerNote`. Subsequent reads from it will return its default value.
  mutating func clearInvreqPayerNote() {_uniqueStorage()._invreqPayerNote = nil}

  var invreqRecurrenceCounter: UInt32 {
    get {return _storage._invreqRecurrenceCounter ?? 0}
    set {_uniqueStorage()._invreqRecurrenceCounter = newValue}
  }
  /// Returns true if `invreqRecurrenceCounter` has been explicitly set.
  var hasInvreqRecurrenceCounter: Bool {return _storage._invreqRecurrenceCounter != nil}
  /// Clears the value of `invreqRecurrenceCounter`. Subsequent reads from it will return its default value.
  mutating func clearInvreqRecurrenceCounter() {_uniqueStorage()._invreqRecurrenceCounter = nil}

  var invreqRecurrenceStart: UInt32 {
    get {return _storage._invreqRecurrenceStart ?? 0}
    set {_uniqueStorage()._invreqRecurrenceStart = newValue}
  }
  /// Returns true if `invreqRecurrenceStart` has been explicitly set.
  var hasInvreqRecurrenceStart: Bool {return _storage._invreqRecurrenceStart != nil}
  /// Clears the value of `invreqRecurrenceStart`. Subsequent reads from it will return its default value.
  mutating func clearInvreqRecurrenceStart() {_uniqueStorage()._invreqRecurrenceStart = nil}

  var warningMissingInvreqMetadata: String {
    get {return _storage._warningMissingInvreqMetadata ?? String()}
    set {_uniqueStorage()._warningMissingInvreqMetadata = newValue}
  }
  /// Returns true if `warningMissingInvreqMetadata` has been explicitly set.
  var hasWarningMissingInvreqMetadata: Bool {return _storage._warningMissingInvreqMetadata != nil}
  /// Clears the value of `warningMissingInvreqMetadata`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvreqMetadata() {_uniqueStorage()._warningMissingInvreqMetadata = nil}

  var warningMissingInvreqPayerID: String {
    get {return _storage._warningMissingInvreqPayerID ?? String()}
    set {_uniqueStorage()._warningMissingInvreqPayerID = newValue}
  }
  /// Returns true if `warningMissingInvreqPayerID` has been explicitly set.
  var hasWarningMissingInvreqPayerID: Bool {return _storage._warningMissingInvreqPayerID != nil}
  /// Clears the value of `warningMissingInvreqPayerID`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvreqPayerID() {_uniqueStorage()._warningMissingInvreqPayerID = nil}

  var warningInvalidInvreqPayerNote: String {
    get {return _storage._warningInvalidInvreqPayerNote ?? String()}
    set {_uniqueStorage()._warningInvalidInvreqPayerNote = newValue}
  }
  /// Returns true if `warningInvalidInvreqPayerNote` has been explicitly set.
  var hasWarningInvalidInvreqPayerNote: Bool {return _storage._warningInvalidInvreqPayerNote != nil}
  /// Clears the value of `warningInvalidInvreqPayerNote`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidInvreqPayerNote() {_uniqueStorage()._warningInvalidInvreqPayerNote = nil}

  var warningMissingInvoiceRequestSignature: String {
    get {return _storage._warningMissingInvoiceRequestSignature ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceRequestSignature = newValue}
  }
  /// Returns true if `warningMissingInvoiceRequestSignature` has been explicitly set.
  var hasWarningMissingInvoiceRequestSignature: Bool {return _storage._warningMissingInvoiceRequestSignature != nil}
  /// Clears the value of `warningMissingInvoiceRequestSignature`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceRequestSignature() {_uniqueStorage()._warningMissingInvoiceRequestSignature = nil}

  var warningInvalidInvoiceRequestSignature: String {
    get {return _storage._warningInvalidInvoiceRequestSignature ?? String()}
    set {_uniqueStorage()._warningInvalidInvoiceRequestSignature = newValue}
  }
  /// Returns true if `warningInvalidInvoiceRequestSignature` has been explicitly set.
  var hasWarningInvalidInvoiceRequestSignature: Bool {return _storage._warningInvalidInvoiceRequestSignature != nil}
  /// Clears the value of `warningInvalidInvoiceRequestSignature`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidInvoiceRequestSignature() {_uniqueStorage()._warningInvalidInvoiceRequestSignature = nil}

  var invoiceCreatedAt: UInt64 {
    get {return _storage._invoiceCreatedAt ?? 0}
    set {_uniqueStorage()._invoiceCreatedAt = newValue}
  }
  /// Returns true if `invoiceCreatedAt` has been explicitly set.
  var hasInvoiceCreatedAt: Bool {return _storage._invoiceCreatedAt != nil}
  /// Clears the value of `invoiceCreatedAt`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceCreatedAt() {_uniqueStorage()._invoiceCreatedAt = nil}

  var invoiceRelativeExpiry: UInt32 {
    get {return _storage._invoiceRelativeExpiry ?? 0}
    set {_uniqueStorage()._invoiceRelativeExpiry = newValue}
  }
  /// Returns true if `invoiceRelativeExpiry` has been explicitly set.
  var hasInvoiceRelativeExpiry: Bool {return _storage._invoiceRelativeExpiry != nil}
  /// Clears the value of `invoiceRelativeExpiry`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceRelativeExpiry() {_uniqueStorage()._invoiceRelativeExpiry = nil}

  var invoicePaymentHash: Data {
    get {return _storage._invoicePaymentHash ?? Data()}
    set {_uniqueStorage()._invoicePaymentHash = newValue}
  }
  /// Returns true if `invoicePaymentHash` has been explicitly set.
  var hasInvoicePaymentHash: Bool {return _storage._invoicePaymentHash != nil}
  /// Clears the value of `invoicePaymentHash`. Subsequent reads from it will return its default value.
  mutating func clearInvoicePaymentHash() {_uniqueStorage()._invoicePaymentHash = nil}

  var invoiceAmountMsat: Cln_Amount {
    get {return _storage._invoiceAmountMsat ?? Cln_Amount()}
    set {_uniqueStorage()._invoiceAmountMsat = newValue}
  }
  /// Returns true if `invoiceAmountMsat` has been explicitly set.
  var hasInvoiceAmountMsat: Bool {return _storage._invoiceAmountMsat != nil}
  /// Clears the value of `invoiceAmountMsat`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceAmountMsat() {_uniqueStorage()._invoiceAmountMsat = nil}

  var invoiceFallbacks: [Cln_DecodeInvoice_fallbacks] {
    get {return _storage._invoiceFallbacks}
    set {_uniqueStorage()._invoiceFallbacks = newValue}
  }

  var invoiceFeatures: Data {
    get {return _storage._invoiceFeatures ?? Data()}
    set {_uniqueStorage()._invoiceFeatures = newValue}
  }
  /// Returns true if `invoiceFeatures` has been explicitly set.
  var hasInvoiceFeatures: Bool {return _storage._invoiceFeatures != nil}
  /// Clears the value of `invoiceFeatures`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceFeatures() {_uniqueStorage()._invoiceFeatures = nil}

  var invoiceNodeID: Data {
    get {return _storage._invoiceNodeID ?? Data()}
    set {_uniqueStorage()._invoiceNodeID = newValue}
  }
  /// Returns true if `invoiceNodeID` has been explicitly set.
  var hasInvoiceNodeID: Bool {return _storage._invoiceNodeID != nil}
  /// Clears the value of `invoiceNodeID`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceNodeID() {_uniqueStorage()._invoiceNodeID = nil}

  var invoiceRecurrenceBasetime: UInt64 {
    get {return _storage._invoiceRecurrenceBasetime ?? 0}
    set {_uniqueStorage()._invoiceRecurrenceBasetime = newValue}
  }
  /// Returns true if `invoiceRecurrenceBasetime` has been explicitly set.
  var hasInvoiceRecurrenceBasetime: Bool {return _storage._invoiceRecurrenceBasetime != nil}
  /// Clears the value of `invoiceRecurrenceBasetime`. Subsequent reads from it will return its default value.
  mutating func clearInvoiceRecurrenceBasetime() {_uniqueStorage()._invoiceRecurrenceBasetime = nil}

  var warningMissingInvoicePaths: String {
    get {return _storage._warningMissingInvoicePaths ?? String()}
    set {_uniqueStorage()._warningMissingInvoicePaths = newValue}
  }
  /// Returns true if `warningMissingInvoicePaths` has been explicitly set.
  var hasWarningMissingInvoicePaths: Bool {return _storage._warningMissingInvoicePaths != nil}
  /// Clears the value of `warningMissingInvoicePaths`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoicePaths() {_uniqueStorage()._warningMissingInvoicePaths = nil}

  var warningMissingInvoiceBlindedpay: String {
    get {return _storage._warningMissingInvoiceBlindedpay ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceBlindedpay = newValue}
  }
  /// Returns true if `warningMissingInvoiceBlindedpay` has been explicitly set.
  var hasWarningMissingInvoiceBlindedpay: Bool {return _storage._warningMissingInvoiceBlindedpay != nil}
  /// Clears the value of `warningMissingInvoiceBlindedpay`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceBlindedpay() {_uniqueStorage()._warningMissingInvoiceBlindedpay = nil}

  var warningMissingInvoiceCreatedAt: String {
    get {return _storage._warningMissingInvoiceCreatedAt ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceCreatedAt = newValue}
  }
  /// Returns true if `warningMissingInvoiceCreatedAt` has been explicitly set.
  var hasWarningMissingInvoiceCreatedAt: Bool {return _storage._warningMissingInvoiceCreatedAt != nil}
  /// Clears the value of `warningMissingInvoiceCreatedAt`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceCreatedAt() {_uniqueStorage()._warningMissingInvoiceCreatedAt = nil}

  var warningMissingInvoicePaymentHash: String {
    get {return _storage._warningMissingInvoicePaymentHash ?? String()}
    set {_uniqueStorage()._warningMissingInvoicePaymentHash = newValue}
  }
  /// Returns true if `warningMissingInvoicePaymentHash` has been explicitly set.
  var hasWarningMissingInvoicePaymentHash: Bool {return _storage._warningMissingInvoicePaymentHash != nil}
  /// Clears the value of `warningMissingInvoicePaymentHash`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoicePaymentHash() {_uniqueStorage()._warningMissingInvoicePaymentHash = nil}

  var warningMissingInvoiceAmount: String {
    get {return _storage._warningMissingInvoiceAmount ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceAmount = newValue}
  }
  /// Returns true if `warningMissingInvoiceAmount` has been explicitly set.
  var hasWarningMissingInvoiceAmount: Bool {return _storage._warningMissingInvoiceAmount != nil}
  /// Clears the value of `warningMissingInvoiceAmount`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceAmount() {_uniqueStorage()._warningMissingInvoiceAmount = nil}

  var warningMissingInvoiceRecurrenceBasetime: String {
    get {return _storage._warningMissingInvoiceRecurrenceBasetime ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceRecurrenceBasetime = newValue}
  }
  /// Returns true if `warningMissingInvoiceRecurrenceBasetime` has been explicitly set.
  var hasWarningMissingInvoiceRecurrenceBasetime: Bool {return _storage._warningMissingInvoiceRecurrenceBasetime != nil}
  /// Clears the value of `warningMissingInvoiceRecurrenceBasetime`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceRecurrenceBasetime() {_uniqueStorage()._warningMissingInvoiceRecurrenceBasetime = nil}

  var warningMissingInvoiceNodeID: String {
    get {return _storage._warningMissingInvoiceNodeID ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceNodeID = newValue}
  }
  /// Returns true if `warningMissingInvoiceNodeID` has been explicitly set.
  var hasWarningMissingInvoiceNodeID: Bool {return _storage._warningMissingInvoiceNodeID != nil}
  /// Clears the value of `warningMissingInvoiceNodeID`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceNodeID() {_uniqueStorage()._warningMissingInvoiceNodeID = nil}

  var warningMissingInvoiceSignature: String {
    get {return _storage._warningMissingInvoiceSignature ?? String()}
    set {_uniqueStorage()._warningMissingInvoiceSignature = newValue}
  }
  /// Returns true if `warningMissingInvoiceSignature` has been explicitly set.
  var hasWarningMissingInvoiceSignature: Bool {return _storage._warningMissingInvoiceSignature != nil}
  /// Clears the value of `warningMissingInvoiceSignature`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingInvoiceSignature() {_uniqueStorage()._warningMissingInvoiceSignature = nil}

  var warningInvalidInvoiceSignature: String {
    get {return _storage._warningInvalidInvoiceSignature ?? String()}
    set {_uniqueStorage()._warningInvalidInvoiceSignature = newValue}
  }
  /// Returns true if `warningInvalidInvoiceSignature` has been explicitly set.
  var hasWarningInvalidInvoiceSignature: Bool {return _storage._warningInvalidInvoiceSignature != nil}
  /// Clears the value of `warningInvalidInvoiceSignature`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvalidInvoiceSignature() {_uniqueStorage()._warningInvalidInvoiceSignature = nil}

  var fallbacks: [Cln_DecodeFallbacks] {
    get {return _storage._fallbacks}
    set {_uniqueStorage()._fallbacks = newValue}
  }

  var createdAt: UInt64 {
    get {return _storage._createdAt ?? 0}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var expiry: UInt64 {
    get {return _storage._expiry ?? 0}
    set {_uniqueStorage()._expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  var hasExpiry: Bool {return _storage._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  mutating func clearExpiry() {_uniqueStorage()._expiry = nil}

  var payee: Data {
    get {return _storage._payee ?? Data()}
    set {_uniqueStorage()._payee = newValue}
  }
  /// Returns true if `payee` has been explicitly set.
  var hasPayee: Bool {return _storage._payee != nil}
  /// Clears the value of `payee`. Subsequent reads from it will return its default value.
  mutating func clearPayee() {_uniqueStorage()._payee = nil}

  var paymentHash: Data {
    get {return _storage._paymentHash ?? Data()}
    set {_uniqueStorage()._paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return _storage._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {_uniqueStorage()._paymentHash = nil}

  var descriptionHash: Data {
    get {return _storage._descriptionHash ?? Data()}
    set {_uniqueStorage()._descriptionHash = newValue}
  }
  /// Returns true if `descriptionHash` has been explicitly set.
  var hasDescriptionHash: Bool {return _storage._descriptionHash != nil}
  /// Clears the value of `descriptionHash`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionHash() {_uniqueStorage()._descriptionHash = nil}

  var minFinalCltvExpiry: UInt32 {
    get {return _storage._minFinalCltvExpiry ?? 0}
    set {_uniqueStorage()._minFinalCltvExpiry = newValue}
  }
  /// Returns true if `minFinalCltvExpiry` has been explicitly set.
  var hasMinFinalCltvExpiry: Bool {return _storage._minFinalCltvExpiry != nil}
  /// Clears the value of `minFinalCltvExpiry`. Subsequent reads from it will return its default value.
  mutating func clearMinFinalCltvExpiry() {_uniqueStorage()._minFinalCltvExpiry = nil}

  var paymentSecret: Data {
    get {return _storage._paymentSecret ?? Data()}
    set {_uniqueStorage()._paymentSecret = newValue}
  }
  /// Returns true if `paymentSecret` has been explicitly set.
  var hasPaymentSecret: Bool {return _storage._paymentSecret != nil}
  /// Clears the value of `paymentSecret`. Subsequent reads from it will return its default value.
  mutating func clearPaymentSecret() {_uniqueStorage()._paymentSecret = nil}

  var paymentMetadata: Data {
    get {return _storage._paymentMetadata ?? Data()}
    set {_uniqueStorage()._paymentMetadata = newValue}
  }
  /// Returns true if `paymentMetadata` has been explicitly set.
  var hasPaymentMetadata: Bool {return _storage._paymentMetadata != nil}
  /// Clears the value of `paymentMetadata`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMetadata() {_uniqueStorage()._paymentMetadata = nil}

  var extra: [Cln_DecodeExtra] {
    get {return _storage._extra}
    set {_uniqueStorage()._extra = newValue}
  }

  var uniqueID: String {
    get {return _storage._uniqueID ?? String()}
    set {_uniqueStorage()._uniqueID = newValue}
  }
  /// Returns true if `uniqueID` has been explicitly set.
  var hasUniqueID: Bool {return _storage._uniqueID != nil}
  /// Clears the value of `uniqueID`. Subsequent reads from it will return its default value.
  mutating func clearUniqueID() {_uniqueStorage()._uniqueID = nil}

  var version: String {
    get {return _storage._version ?? String()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {_uniqueStorage()._version = nil}

  var string: String {
    get {return _storage._string ?? String()}
    set {_uniqueStorage()._string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  var hasString: Bool {return _storage._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  mutating func clearString() {_uniqueStorage()._string = nil}

  var restrictions: [Cln_DecodeRestrictions] {
    get {return _storage._restrictions}
    set {_uniqueStorage()._restrictions = newValue}
  }

  var warningRuneInvalidUtf8: String {
    get {return _storage._warningRuneInvalidUtf8 ?? String()}
    set {_uniqueStorage()._warningRuneInvalidUtf8 = newValue}
  }
  /// Returns true if `warningRuneInvalidUtf8` has been explicitly set.
  var hasWarningRuneInvalidUtf8: Bool {return _storage._warningRuneInvalidUtf8 != nil}
  /// Clears the value of `warningRuneInvalidUtf8`. Subsequent reads from it will return its default value.
  mutating func clearWarningRuneInvalidUtf8() {_uniqueStorage()._warningRuneInvalidUtf8 = nil}

  var hex: Data {
    get {return _storage._hex ?? Data()}
    set {_uniqueStorage()._hex = newValue}
  }
  /// Returns true if `hex` has been explicitly set.
  var hasHex: Bool {return _storage._hex != nil}
  /// Clears the value of `hex`. Subsequent reads from it will return its default value.
  mutating func clearHex() {_uniqueStorage()._hex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Decode.type
  enum DecodeType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case bolt12Offer // = 0
    case bolt12Invoice // = 1
    case bolt12InvoiceRequest // = 2
    case bolt11Invoice // = 3
    case rune // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .bolt12Offer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bolt12Offer
      case 1: self = .bolt12Invoice
      case 2: self = .bolt12InvoiceRequest
      case 3: self = .bolt11Invoice
      case 4: self = .rune
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .bolt12Offer: return 0
      case .bolt12Invoice: return 1
      case .bolt12InvoiceRequest: return 2
      case .bolt11Invoice: return 3
      case .rune: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_DecodeResponse.DecodeType] = [
      .bolt12Offer,
      .bolt12Invoice,
      .bolt12InvoiceRequest,
      .bolt11Invoice,
      .rune,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_DecodeOffer_paths: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var firstNodeID: Data = Data()

  var blinding: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DecodeOffer_recurrencePaywindow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var secondsBefore: UInt32 = 0

  var secondsAfter: UInt32 = 0

  var proportionalAmount: Bool {
    get {return _proportionalAmount ?? false}
    set {_proportionalAmount = newValue}
  }
  /// Returns true if `proportionalAmount` has been explicitly set.
  var hasProportionalAmount: Bool {return self._proportionalAmount != nil}
  /// Clears the value of `proportionalAmount`. Subsequent reads from it will return its default value.
  mutating func clearProportionalAmount() {self._proportionalAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proportionalAmount: Bool? = nil
}

struct Cln_DecodeInvoice_pathsPath: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blindedNodeID: Data = Data()

  var encryptedRecipientData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DecodeInvoice_fallbacks: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var hex: Data = Data()

  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _address: String? = nil
}

struct Cln_DecodeFallbacks: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var warningInvoiceFallbacksVersionInvalid: String {
    get {return _warningInvoiceFallbacksVersionInvalid ?? String()}
    set {_warningInvoiceFallbacksVersionInvalid = newValue}
  }
  /// Returns true if `warningInvoiceFallbacksVersionInvalid` has been explicitly set.
  var hasWarningInvoiceFallbacksVersionInvalid: Bool {return self._warningInvoiceFallbacksVersionInvalid != nil}
  /// Clears the value of `warningInvoiceFallbacksVersionInvalid`. Subsequent reads from it will return its default value.
  mutating func clearWarningInvoiceFallbacksVersionInvalid() {self._warningInvoiceFallbacksVersionInvalid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _warningInvoiceFallbacksVersionInvalid: String? = nil
}

struct Cln_DecodeExtra: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: String = String()

  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DecodeRestrictions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alternatives: [String] = []

  var summary: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_DisconnectRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var force: Bool {
    get {return _force ?? false}
    set {_force = newValue}
  }
  /// Returns true if `force` has been explicitly set.
  var hasForce: Bool {return self._force != nil}
  /// Clears the value of `force`. Subsequent reads from it will return its default value.
  mutating func clearForce() {self._force = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _force: Bool? = nil
}

struct Cln_DisconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_FeeratesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var style: Cln_FeeratesRequest.FeeratesStyle = .perkb

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Feerates.style
  enum FeeratesStyle: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case perkb // = 0
    case perkw // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .perkb
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .perkb
      case 1: self = .perkw
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .perkb: return 0
      case .perkw: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_FeeratesRequest.FeeratesStyle] = [
      .perkb,
      .perkw,
    ]

  }

  init() {}
}

struct Cln_FeeratesResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var warningMissingFeerates: String {
    get {return _storage._warningMissingFeerates ?? String()}
    set {_uniqueStorage()._warningMissingFeerates = newValue}
  }
  /// Returns true if `warningMissingFeerates` has been explicitly set.
  var hasWarningMissingFeerates: Bool {return _storage._warningMissingFeerates != nil}
  /// Clears the value of `warningMissingFeerates`. Subsequent reads from it will return its default value.
  mutating func clearWarningMissingFeerates() {_uniqueStorage()._warningMissingFeerates = nil}

  var perkb: Cln_FeeratesPerkb {
    get {return _storage._perkb ?? Cln_FeeratesPerkb()}
    set {_uniqueStorage()._perkb = newValue}
  }
  /// Returns true if `perkb` has been explicitly set.
  var hasPerkb: Bool {return _storage._perkb != nil}
  /// Clears the value of `perkb`. Subsequent reads from it will return its default value.
  mutating func clearPerkb() {_uniqueStorage()._perkb = nil}

  var perkw: Cln_FeeratesPerkw {
    get {return _storage._perkw ?? Cln_FeeratesPerkw()}
    set {_uniqueStorage()._perkw = newValue}
  }
  /// Returns true if `perkw` has been explicitly set.
  var hasPerkw: Bool {return _storage._perkw != nil}
  /// Clears the value of `perkw`. Subsequent reads from it will return its default value.
  mutating func clearPerkw() {_uniqueStorage()._perkw = nil}

  var onchainFeeEstimates: Cln_FeeratesOnchain_fee_estimates {
    get {return _storage._onchainFeeEstimates ?? Cln_FeeratesOnchain_fee_estimates()}
    set {_uniqueStorage()._onchainFeeEstimates = newValue}
  }
  /// Returns true if `onchainFeeEstimates` has been explicitly set.
  var hasOnchainFeeEstimates: Bool {return _storage._onchainFeeEstimates != nil}
  /// Clears the value of `onchainFeeEstimates`. Subsequent reads from it will return its default value.
  mutating func clearOnchainFeeEstimates() {_uniqueStorage()._onchainFeeEstimates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Cln_FeeratesPerkb: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minAcceptable: UInt32 = 0

  var maxAcceptable: UInt32 = 0

  var floor: UInt32 {
    get {return _floor ?? 0}
    set {_floor = newValue}
  }
  /// Returns true if `floor` has been explicitly set.
  var hasFloor: Bool {return self._floor != nil}
  /// Clears the value of `floor`. Subsequent reads from it will return its default value.
  mutating func clearFloor() {self._floor = nil}

  var estimates: [Cln_FeeratesPerkbEstimates] = []

  var opening: UInt32 {
    get {return _opening ?? 0}
    set {_opening = newValue}
  }
  /// Returns true if `opening` has been explicitly set.
  var hasOpening: Bool {return self._opening != nil}
  /// Clears the value of `opening`. Subsequent reads from it will return its default value.
  mutating func clearOpening() {self._opening = nil}

  var mutualClose: UInt32 {
    get {return _mutualClose ?? 0}
    set {_mutualClose = newValue}
  }
  /// Returns true if `mutualClose` has been explicitly set.
  var hasMutualClose: Bool {return self._mutualClose != nil}
  /// Clears the value of `mutualClose`. Subsequent reads from it will return its default value.
  mutating func clearMutualClose() {self._mutualClose = nil}

  var unilateralClose: UInt32 {
    get {return _unilateralClose ?? 0}
    set {_unilateralClose = newValue}
  }
  /// Returns true if `unilateralClose` has been explicitly set.
  var hasUnilateralClose: Bool {return self._unilateralClose != nil}
  /// Clears the value of `unilateralClose`. Subsequent reads from it will return its default value.
  mutating func clearUnilateralClose() {self._unilateralClose = nil}

  var unilateralAnchorClose: UInt32 {
    get {return _unilateralAnchorClose ?? 0}
    set {_unilateralAnchorClose = newValue}
  }
  /// Returns true if `unilateralAnchorClose` has been explicitly set.
  var hasUnilateralAnchorClose: Bool {return self._unilateralAnchorClose != nil}
  /// Clears the value of `unilateralAnchorClose`. Subsequent reads from it will return its default value.
  mutating func clearUnilateralAnchorClose() {self._unilateralAnchorClose = nil}

  var delayedToUs: UInt32 {
    get {return _delayedToUs ?? 0}
    set {_delayedToUs = newValue}
  }
  /// Returns true if `delayedToUs` has been explicitly set.
  var hasDelayedToUs: Bool {return self._delayedToUs != nil}
  /// Clears the value of `delayedToUs`. Subsequent reads from it will return its default value.
  mutating func clearDelayedToUs() {self._delayedToUs = nil}

  var htlcResolution: UInt32 {
    get {return _htlcResolution ?? 0}
    set {_htlcResolution = newValue}
  }
  /// Returns true if `htlcResolution` has been explicitly set.
  var hasHtlcResolution: Bool {return self._htlcResolution != nil}
  /// Clears the value of `htlcResolution`. Subsequent reads from it will return its default value.
  mutating func clearHtlcResolution() {self._htlcResolution = nil}

  var penalty: UInt32 {
    get {return _penalty ?? 0}
    set {_penalty = newValue}
  }
  /// Returns true if `penalty` has been explicitly set.
  var hasPenalty: Bool {return self._penalty != nil}
  /// Clears the value of `penalty`. Subsequent reads from it will return its default value.
  mutating func clearPenalty() {self._penalty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _floor: UInt32? = nil
  fileprivate var _opening: UInt32? = nil
  fileprivate var _mutualClose: UInt32? = nil
  fileprivate var _unilateralClose: UInt32? = nil
  fileprivate var _unilateralAnchorClose: UInt32? = nil
  fileprivate var _delayedToUs: UInt32? = nil
  fileprivate var _htlcResolution: UInt32? = nil
  fileprivate var _penalty: UInt32? = nil
}

struct Cln_FeeratesPerkbEstimates: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockcount: UInt32 {
    get {return _blockcount ?? 0}
    set {_blockcount = newValue}
  }
  /// Returns true if `blockcount` has been explicitly set.
  var hasBlockcount: Bool {return self._blockcount != nil}
  /// Clears the value of `blockcount`. Subsequent reads from it will return its default value.
  mutating func clearBlockcount() {self._blockcount = nil}

  var feerate: UInt32 {
    get {return _feerate ?? 0}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var smoothedFeerate: UInt32 {
    get {return _smoothedFeerate ?? 0}
    set {_smoothedFeerate = newValue}
  }
  /// Returns true if `smoothedFeerate` has been explicitly set.
  var hasSmoothedFeerate: Bool {return self._smoothedFeerate != nil}
  /// Clears the value of `smoothedFeerate`. Subsequent reads from it will return its default value.
  mutating func clearSmoothedFeerate() {self._smoothedFeerate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockcount: UInt32? = nil
  fileprivate var _feerate: UInt32? = nil
  fileprivate var _smoothedFeerate: UInt32? = nil
}

struct Cln_FeeratesPerkw: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minAcceptable: UInt32 = 0

  var maxAcceptable: UInt32 = 0

  var floor: UInt32 {
    get {return _floor ?? 0}
    set {_floor = newValue}
  }
  /// Returns true if `floor` has been explicitly set.
  var hasFloor: Bool {return self._floor != nil}
  /// Clears the value of `floor`. Subsequent reads from it will return its default value.
  mutating func clearFloor() {self._floor = nil}

  var estimates: [Cln_FeeratesPerkwEstimates] = []

  var opening: UInt32 {
    get {return _opening ?? 0}
    set {_opening = newValue}
  }
  /// Returns true if `opening` has been explicitly set.
  var hasOpening: Bool {return self._opening != nil}
  /// Clears the value of `opening`. Subsequent reads from it will return its default value.
  mutating func clearOpening() {self._opening = nil}

  var mutualClose: UInt32 {
    get {return _mutualClose ?? 0}
    set {_mutualClose = newValue}
  }
  /// Returns true if `mutualClose` has been explicitly set.
  var hasMutualClose: Bool {return self._mutualClose != nil}
  /// Clears the value of `mutualClose`. Subsequent reads from it will return its default value.
  mutating func clearMutualClose() {self._mutualClose = nil}

  var unilateralClose: UInt32 {
    get {return _unilateralClose ?? 0}
    set {_unilateralClose = newValue}
  }
  /// Returns true if `unilateralClose` has been explicitly set.
  var hasUnilateralClose: Bool {return self._unilateralClose != nil}
  /// Clears the value of `unilateralClose`. Subsequent reads from it will return its default value.
  mutating func clearUnilateralClose() {self._unilateralClose = nil}

  var unilateralAnchorClose: UInt32 {
    get {return _unilateralAnchorClose ?? 0}
    set {_unilateralAnchorClose = newValue}
  }
  /// Returns true if `unilateralAnchorClose` has been explicitly set.
  var hasUnilateralAnchorClose: Bool {return self._unilateralAnchorClose != nil}
  /// Clears the value of `unilateralAnchorClose`. Subsequent reads from it will return its default value.
  mutating func clearUnilateralAnchorClose() {self._unilateralAnchorClose = nil}

  var delayedToUs: UInt32 {
    get {return _delayedToUs ?? 0}
    set {_delayedToUs = newValue}
  }
  /// Returns true if `delayedToUs` has been explicitly set.
  var hasDelayedToUs: Bool {return self._delayedToUs != nil}
  /// Clears the value of `delayedToUs`. Subsequent reads from it will return its default value.
  mutating func clearDelayedToUs() {self._delayedToUs = nil}

  var htlcResolution: UInt32 {
    get {return _htlcResolution ?? 0}
    set {_htlcResolution = newValue}
  }
  /// Returns true if `htlcResolution` has been explicitly set.
  var hasHtlcResolution: Bool {return self._htlcResolution != nil}
  /// Clears the value of `htlcResolution`. Subsequent reads from it will return its default value.
  mutating func clearHtlcResolution() {self._htlcResolution = nil}

  var penalty: UInt32 {
    get {return _penalty ?? 0}
    set {_penalty = newValue}
  }
  /// Returns true if `penalty` has been explicitly set.
  var hasPenalty: Bool {return self._penalty != nil}
  /// Clears the value of `penalty`. Subsequent reads from it will return its default value.
  mutating func clearPenalty() {self._penalty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _floor: UInt32? = nil
  fileprivate var _opening: UInt32? = nil
  fileprivate var _mutualClose: UInt32? = nil
  fileprivate var _unilateralClose: UInt32? = nil
  fileprivate var _unilateralAnchorClose: UInt32? = nil
  fileprivate var _delayedToUs: UInt32? = nil
  fileprivate var _htlcResolution: UInt32? = nil
  fileprivate var _penalty: UInt32? = nil
}

struct Cln_FeeratesPerkwEstimates: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockcount: UInt32 {
    get {return _blockcount ?? 0}
    set {_blockcount = newValue}
  }
  /// Returns true if `blockcount` has been explicitly set.
  var hasBlockcount: Bool {return self._blockcount != nil}
  /// Clears the value of `blockcount`. Subsequent reads from it will return its default value.
  mutating func clearBlockcount() {self._blockcount = nil}

  var feerate: UInt32 {
    get {return _feerate ?? 0}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var smoothedFeerate: UInt32 {
    get {return _smoothedFeerate ?? 0}
    set {_smoothedFeerate = newValue}
  }
  /// Returns true if `smoothedFeerate` has been explicitly set.
  var hasSmoothedFeerate: Bool {return self._smoothedFeerate != nil}
  /// Clears the value of `smoothedFeerate`. Subsequent reads from it will return its default value.
  mutating func clearSmoothedFeerate() {self._smoothedFeerate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockcount: UInt32? = nil
  fileprivate var _feerate: UInt32? = nil
  fileprivate var _smoothedFeerate: UInt32? = nil
}

struct Cln_FeeratesOnchain_fee_estimates: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var openingChannelSatoshis: UInt64 = 0

  var mutualCloseSatoshis: UInt64 = 0

  var unilateralCloseSatoshis: UInt64 = 0

  var unilateralCloseNonanchorSatoshis: UInt64 {
    get {return _unilateralCloseNonanchorSatoshis ?? 0}
    set {_unilateralCloseNonanchorSatoshis = newValue}
  }
  /// Returns true if `unilateralCloseNonanchorSatoshis` has been explicitly set.
  var hasUnilateralCloseNonanchorSatoshis: Bool {return self._unilateralCloseNonanchorSatoshis != nil}
  /// Clears the value of `unilateralCloseNonanchorSatoshis`. Subsequent reads from it will return its default value.
  mutating func clearUnilateralCloseNonanchorSatoshis() {self._unilateralCloseNonanchorSatoshis = nil}

  var htlcTimeoutSatoshis: UInt64 = 0

  var htlcSuccessSatoshis: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unilateralCloseNonanchorSatoshis: UInt64? = nil
}

struct Cln_FundchannelRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var amount: Cln_AmountOrAll {
    get {return _amount ?? Cln_AmountOrAll()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var feerate: Cln_Feerate {
    get {return _feerate ?? Cln_Feerate()}
    set {_feerate = newValue}
  }
  /// Returns true if `feerate` has been explicitly set.
  var hasFeerate: Bool {return self._feerate != nil}
  /// Clears the value of `feerate`. Subsequent reads from it will return its default value.
  mutating func clearFeerate() {self._feerate = nil}

  var announce: Bool {
    get {return _announce ?? false}
    set {_announce = newValue}
  }
  /// Returns true if `announce` has been explicitly set.
  var hasAnnounce: Bool {return self._announce != nil}
  /// Clears the value of `announce`. Subsequent reads from it will return its default value.
  mutating func clearAnnounce() {self._announce = nil}

  var minconf: UInt32 {
    get {return _minconf ?? 0}
    set {_minconf = newValue}
  }
  /// Returns true if `minconf` has been explicitly set.
  var hasMinconf: Bool {return self._minconf != nil}
  /// Clears the value of `minconf`. Subsequent reads from it will return its default value.
  mutating func clearMinconf() {self._minconf = nil}

  var pushMsat: Cln_Amount {
    get {return _pushMsat ?? Cln_Amount()}
    set {_pushMsat = newValue}
  }
  /// Returns true if `pushMsat` has been explicitly set.
  var hasPushMsat: Bool {return self._pushMsat != nil}
  /// Clears the value of `pushMsat`. Subsequent reads from it will return its default value.
  mutating func clearPushMsat() {self._pushMsat = nil}

  var closeTo: String {
    get {return _closeTo ?? String()}
    set {_closeTo = newValue}
  }
  /// Returns true if `closeTo` has been explicitly set.
  var hasCloseTo: Bool {return self._closeTo != nil}
  /// Clears the value of `closeTo`. Subsequent reads from it will return its default value.
  mutating func clearCloseTo() {self._closeTo = nil}

  var requestAmt: Cln_Amount {
    get {return _requestAmt ?? Cln_Amount()}
    set {_requestAmt = newValue}
  }
  /// Returns true if `requestAmt` has been explicitly set.
  var hasRequestAmt: Bool {return self._requestAmt != nil}
  /// Clears the value of `requestAmt`. Subsequent reads from it will return its default value.
  mutating func clearRequestAmt() {self._requestAmt = nil}

  var compactLease: String {
    get {return _compactLease ?? String()}
    set {_compactLease = newValue}
  }
  /// Returns true if `compactLease` has been explicitly set.
  var hasCompactLease: Bool {return self._compactLease != nil}
  /// Clears the value of `compactLease`. Subsequent reads from it will return its default value.
  mutating func clearCompactLease() {self._compactLease = nil}

  var utxos: [Cln_Outpoint] = []

  var mindepth: UInt32 {
    get {return _mindepth ?? 0}
    set {_mindepth = newValue}
  }
  /// Returns true if `mindepth` has been explicitly set.
  var hasMindepth: Bool {return self._mindepth != nil}
  /// Clears the value of `mindepth`. Subsequent reads from it will return its default value.
  mutating func clearMindepth() {self._mindepth = nil}

  var reserve: Cln_Amount {
    get {return _reserve ?? Cln_Amount()}
    set {_reserve = newValue}
  }
  /// Returns true if `reserve` has been explicitly set.
  var hasReserve: Bool {return self._reserve != nil}
  /// Clears the value of `reserve`. Subsequent reads from it will return its default value.
  mutating func clearReserve() {self._reserve = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cln_AmountOrAll? = nil
  fileprivate var _feerate: Cln_Feerate? = nil
  fileprivate var _announce: Bool? = nil
  fileprivate var _minconf: UInt32? = nil
  fileprivate var _pushMsat: Cln_Amount? = nil
  fileprivate var _closeTo: String? = nil
  fileprivate var _requestAmt: Cln_Amount? = nil
  fileprivate var _compactLease: String? = nil
  fileprivate var _mindepth: UInt32? = nil
  fileprivate var _reserve: Cln_Amount? = nil
}

struct Cln_FundchannelResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var txid: Data = Data()

  var outnum: UInt32 = 0

  var channelID: Data = Data()

  var closeTo: Data {
    get {return _closeTo ?? Data()}
    set {_closeTo = newValue}
  }
  /// Returns true if `closeTo` has been explicitly set.
  var hasCloseTo: Bool {return self._closeTo != nil}
  /// Clears the value of `closeTo`. Subsequent reads from it will return its default value.
  mutating func clearCloseTo() {self._closeTo = nil}

  var mindepth: UInt32 {
    get {return _mindepth ?? 0}
    set {_mindepth = newValue}
  }
  /// Returns true if `mindepth` has been explicitly set.
  var hasMindepth: Bool {return self._mindepth != nil}
  /// Clears the value of `mindepth`. Subsequent reads from it will return its default value.
  mutating func clearMindepth() {self._mindepth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closeTo: Data? = nil
  fileprivate var _mindepth: UInt32? = nil
}

struct Cln_GetrouteRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var riskfactor: UInt64 = 0

  var cltv: UInt32 {
    get {return _cltv ?? 0}
    set {_cltv = newValue}
  }
  /// Returns true if `cltv` has been explicitly set.
  var hasCltv: Bool {return self._cltv != nil}
  /// Clears the value of `cltv`. Subsequent reads from it will return its default value.
  mutating func clearCltv() {self._cltv = nil}

  var fromid: Data {
    get {return _fromid ?? Data()}
    set {_fromid = newValue}
  }
  /// Returns true if `fromid` has been explicitly set.
  var hasFromid: Bool {return self._fromid != nil}
  /// Clears the value of `fromid`. Subsequent reads from it will return its default value.
  mutating func clearFromid() {self._fromid = nil}

  var fuzzpercent: UInt32 {
    get {return _fuzzpercent ?? 0}
    set {_fuzzpercent = newValue}
  }
  /// Returns true if `fuzzpercent` has been explicitly set.
  var hasFuzzpercent: Bool {return self._fuzzpercent != nil}
  /// Clears the value of `fuzzpercent`. Subsequent reads from it will return its default value.
  mutating func clearFuzzpercent() {self._fuzzpercent = nil}

  var exclude: [String] = []

  var maxhops: UInt32 {
    get {return _maxhops ?? 0}
    set {_maxhops = newValue}
  }
  /// Returns true if `maxhops` has been explicitly set.
  var hasMaxhops: Bool {return self._maxhops != nil}
  /// Clears the value of `maxhops`. Subsequent reads from it will return its default value.
  mutating func clearMaxhops() {self._maxhops = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _cltv: UInt32? = nil
  fileprivate var _fromid: Data? = nil
  fileprivate var _fuzzpercent: UInt32? = nil
  fileprivate var _maxhops: UInt32? = nil
}

struct Cln_GetrouteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var route: [Cln_GetrouteRoute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_GetrouteRoute: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var channel: String = String()

  var direction: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var delay: UInt32 = 0

  var style: Cln_GetrouteRoute.GetrouteRouteStyle = .tlv

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// GetRoute.route[].style
  enum GetrouteRouteStyle: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case tlv // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .tlv
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .tlv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .tlv: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_GetrouteRoute.GetrouteRouteStyle] = [
      .tlv,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_ListforwardsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Cln_ListforwardsRequest.ListforwardsStatus {
    get {return _status ?? .offered}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var inChannel: String {
    get {return _inChannel ?? String()}
    set {_inChannel = newValue}
  }
  /// Returns true if `inChannel` has been explicitly set.
  var hasInChannel: Bool {return self._inChannel != nil}
  /// Clears the value of `inChannel`. Subsequent reads from it will return its default value.
  mutating func clearInChannel() {self._inChannel = nil}

  var outChannel: String {
    get {return _outChannel ?? String()}
    set {_outChannel = newValue}
  }
  /// Returns true if `outChannel` has been explicitly set.
  var hasOutChannel: Bool {return self._outChannel != nil}
  /// Clears the value of `outChannel`. Subsequent reads from it will return its default value.
  mutating func clearOutChannel() {self._outChannel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListForwards.status
  enum ListforwardsStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case offered // = 0
    case settled // = 1
    case localFailed // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .offered
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .offered
      case 1: self = .settled
      case 2: self = .localFailed
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .offered: return 0
      case .settled: return 1
      case .localFailed: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListforwardsRequest.ListforwardsStatus] = [
      .offered,
      .settled,
      .localFailed,
      .failed,
    ]

  }

  init() {}

  fileprivate var _status: Cln_ListforwardsRequest.ListforwardsStatus? = nil
  fileprivate var _inChannel: String? = nil
  fileprivate var _outChannel: String? = nil
}

struct Cln_ListforwardsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var forwards: [Cln_ListforwardsForwards] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListforwardsForwards: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inChannel: String = String()

  var inHtlcID: UInt64 {
    get {return _inHtlcID ?? 0}
    set {_inHtlcID = newValue}
  }
  /// Returns true if `inHtlcID` has been explicitly set.
  var hasInHtlcID: Bool {return self._inHtlcID != nil}
  /// Clears the value of `inHtlcID`. Subsequent reads from it will return its default value.
  mutating func clearInHtlcID() {self._inHtlcID = nil}

  var inMsat: Cln_Amount {
    get {return _inMsat ?? Cln_Amount()}
    set {_inMsat = newValue}
  }
  /// Returns true if `inMsat` has been explicitly set.
  var hasInMsat: Bool {return self._inMsat != nil}
  /// Clears the value of `inMsat`. Subsequent reads from it will return its default value.
  mutating func clearInMsat() {self._inMsat = nil}

  var status: Cln_ListforwardsForwards.ListforwardsForwardsStatus = .offered

  var receivedTime: Double = 0

  var outChannel: String {
    get {return _outChannel ?? String()}
    set {_outChannel = newValue}
  }
  /// Returns true if `outChannel` has been explicitly set.
  var hasOutChannel: Bool {return self._outChannel != nil}
  /// Clears the value of `outChannel`. Subsequent reads from it will return its default value.
  mutating func clearOutChannel() {self._outChannel = nil}

  var outHtlcID: UInt64 {
    get {return _outHtlcID ?? 0}
    set {_outHtlcID = newValue}
  }
  /// Returns true if `outHtlcID` has been explicitly set.
  var hasOutHtlcID: Bool {return self._outHtlcID != nil}
  /// Clears the value of `outHtlcID`. Subsequent reads from it will return its default value.
  mutating func clearOutHtlcID() {self._outHtlcID = nil}

  var style: Cln_ListforwardsForwards.ListforwardsForwardsStyle {
    get {return _style ?? .legacy}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var feeMsat: Cln_Amount {
    get {return _feeMsat ?? Cln_Amount()}
    set {_feeMsat = newValue}
  }
  /// Returns true if `feeMsat` has been explicitly set.
  var hasFeeMsat: Bool {return self._feeMsat != nil}
  /// Clears the value of `feeMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeMsat() {self._feeMsat = nil}

  var outMsat: Cln_Amount {
    get {return _outMsat ?? Cln_Amount()}
    set {_outMsat = newValue}
  }
  /// Returns true if `outMsat` has been explicitly set.
  var hasOutMsat: Bool {return self._outMsat != nil}
  /// Clears the value of `outMsat`. Subsequent reads from it will return its default value.
  mutating func clearOutMsat() {self._outMsat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListForwards.forwards[].status
  enum ListforwardsForwardsStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case offered // = 0
    case settled // = 1
    case localFailed // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .offered
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .offered
      case 1: self = .settled
      case 2: self = .localFailed
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .offered: return 0
      case .settled: return 1
      case .localFailed: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListforwardsForwards.ListforwardsForwardsStatus] = [
      .offered,
      .settled,
      .localFailed,
      .failed,
    ]

  }

  /// ListForwards.forwards[].style
  enum ListforwardsForwardsStyle: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case legacy // = 0
    case tlv // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .legacy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .legacy
      case 1: self = .tlv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .legacy: return 0
      case .tlv: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListforwardsForwards.ListforwardsForwardsStyle] = [
      .legacy,
      .tlv,
    ]

  }

  init() {}

  fileprivate var _inHtlcID: UInt64? = nil
  fileprivate var _inMsat: Cln_Amount? = nil
  fileprivate var _outChannel: String? = nil
  fileprivate var _outHtlcID: UInt64? = nil
  fileprivate var _style: Cln_ListforwardsForwards.ListforwardsForwardsStyle? = nil
  fileprivate var _feeMsat: Cln_Amount? = nil
  fileprivate var _outMsat: Cln_Amount? = nil
}

struct Cln_ListpaysRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var paymentHash: Data {
    get {return _paymentHash ?? Data()}
    set {_paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return self._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {self._paymentHash = nil}

  var status: Cln_ListpaysRequest.ListpaysStatus {
    get {return _status ?? .pending}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPays.status
  enum ListpaysStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case complete // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .complete
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .complete: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpaysRequest.ListpaysStatus] = [
      .pending,
      .complete,
      .failed,
    ]

  }

  init() {}

  fileprivate var _bolt11: String? = nil
  fileprivate var _paymentHash: Data? = nil
  fileprivate var _status: Cln_ListpaysRequest.ListpaysStatus? = nil
}

struct Cln_ListpaysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pays: [Cln_ListpaysPays] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListpaysPays: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentHash: Data = Data()

  var status: Cln_ListpaysPays.ListpaysPaysStatus = .pending

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var createdAt: UInt64 = 0

  var completedAt: UInt64 {
    get {return _completedAt ?? 0}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  mutating func clearCompletedAt() {self._completedAt = nil}

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var bolt12: String {
    get {return _bolt12 ?? String()}
    set {_bolt12 = newValue}
  }
  /// Returns true if `bolt12` has been explicitly set.
  var hasBolt12: Bool {return self._bolt12 != nil}
  /// Clears the value of `bolt12`. Subsequent reads from it will return its default value.
  mutating func clearBolt12() {self._bolt12 = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var amountSentMsat: Cln_Amount {
    get {return _amountSentMsat ?? Cln_Amount()}
    set {_amountSentMsat = newValue}
  }
  /// Returns true if `amountSentMsat` has been explicitly set.
  var hasAmountSentMsat: Bool {return self._amountSentMsat != nil}
  /// Clears the value of `amountSentMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountSentMsat() {self._amountSentMsat = nil}

  var preimage: Data {
    get {return _preimage ?? Data()}
    set {_preimage = newValue}
  }
  /// Returns true if `preimage` has been explicitly set.
  var hasPreimage: Bool {return self._preimage != nil}
  /// Clears the value of `preimage`. Subsequent reads from it will return its default value.
  mutating func clearPreimage() {self._preimage = nil}

  var numberOfParts: UInt64 {
    get {return _numberOfParts ?? 0}
    set {_numberOfParts = newValue}
  }
  /// Returns true if `numberOfParts` has been explicitly set.
  var hasNumberOfParts: Bool {return self._numberOfParts != nil}
  /// Clears the value of `numberOfParts`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfParts() {self._numberOfParts = nil}

  var erroronion: Data {
    get {return _erroronion ?? Data()}
    set {_erroronion = newValue}
  }
  /// Returns true if `erroronion` has been explicitly set.
  var hasErroronion: Bool {return self._erroronion != nil}
  /// Clears the value of `erroronion`. Subsequent reads from it will return its default value.
  mutating func clearErroronion() {self._erroronion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListPays.pays[].status
  enum ListpaysPaysStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case failed // = 1
    case complete // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .failed
      case 2: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .failed: return 1
      case .complete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListpaysPays.ListpaysPaysStatus] = [
      .pending,
      .failed,
      .complete,
    ]

  }

  init() {}

  fileprivate var _destination: Data? = nil
  fileprivate var _completedAt: UInt64? = nil
  fileprivate var _label: String? = nil
  fileprivate var _bolt11: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _bolt12: String? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
  fileprivate var _amountSentMsat: Cln_Amount? = nil
  fileprivate var _preimage: Data? = nil
  fileprivate var _numberOfParts: UInt64? = nil
  fileprivate var _erroronion: Data? = nil
}

struct Cln_ListhtlcsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: String? = nil
}

struct Cln_ListhtlcsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var htlcs: [Cln_ListhtlcsHtlcs] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_ListhtlcsHtlcs: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shortChannelID: String = String()

  var id: UInt64 = 0

  var expiry: UInt32 = 0

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var direction: Cln_ListhtlcsHtlcs.ListhtlcsHtlcsDirection = .out

  var paymentHash: Data = Data()

  var state: Cln_HtlcState = .sentAddHtlc

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ListHtlcs.htlcs[].direction
  enum ListhtlcsHtlcsDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case out // = 0
    case `in` // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .out
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .out
      case 1: self = .in
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .out: return 0
      case .in: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Cln_ListhtlcsHtlcs.ListhtlcsHtlcsDirection] = [
      .out,
      .in,
    ]

  }

  init() {}

  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_PingRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var len: UInt32 {
    get {return _len ?? 0}
    set {_len = newValue}
  }
  /// Returns true if `len` has been explicitly set.
  var hasLen: Bool {return self._len != nil}
  /// Clears the value of `len`. Subsequent reads from it will return its default value.
  mutating func clearLen() {self._len = nil}

  var pongbytes: UInt32 {
    get {return _pongbytes ?? 0}
    set {_pongbytes = newValue}
  }
  /// Returns true if `pongbytes` has been explicitly set.
  var hasPongbytes: Bool {return self._pongbytes != nil}
  /// Clears the value of `pongbytes`. Subsequent reads from it will return its default value.
  mutating func clearPongbytes() {self._pongbytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _len: UInt32? = nil
  fileprivate var _pongbytes: UInt32? = nil
}

struct Cln_PingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totlen: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SendcustommsgRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeID: Data = Data()

  var msg: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SendcustommsgResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SetchannelRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var feebase: Cln_Amount {
    get {return _feebase ?? Cln_Amount()}
    set {_feebase = newValue}
  }
  /// Returns true if `feebase` has been explicitly set.
  var hasFeebase: Bool {return self._feebase != nil}
  /// Clears the value of `feebase`. Subsequent reads from it will return its default value.
  mutating func clearFeebase() {self._feebase = nil}

  var feeppm: UInt32 {
    get {return _feeppm ?? 0}
    set {_feeppm = newValue}
  }
  /// Returns true if `feeppm` has been explicitly set.
  var hasFeeppm: Bool {return self._feeppm != nil}
  /// Clears the value of `feeppm`. Subsequent reads from it will return its default value.
  mutating func clearFeeppm() {self._feeppm = nil}

  var htlcmin: Cln_Amount {
    get {return _htlcmin ?? Cln_Amount()}
    set {_htlcmin = newValue}
  }
  /// Returns true if `htlcmin` has been explicitly set.
  var hasHtlcmin: Bool {return self._htlcmin != nil}
  /// Clears the value of `htlcmin`. Subsequent reads from it will return its default value.
  mutating func clearHtlcmin() {self._htlcmin = nil}

  var htlcmax: Cln_Amount {
    get {return _htlcmax ?? Cln_Amount()}
    set {_htlcmax = newValue}
  }
  /// Returns true if `htlcmax` has been explicitly set.
  var hasHtlcmax: Bool {return self._htlcmax != nil}
  /// Clears the value of `htlcmax`. Subsequent reads from it will return its default value.
  mutating func clearHtlcmax() {self._htlcmax = nil}

  var enforcedelay: UInt32 {
    get {return _enforcedelay ?? 0}
    set {_enforcedelay = newValue}
  }
  /// Returns true if `enforcedelay` has been explicitly set.
  var hasEnforcedelay: Bool {return self._enforcedelay != nil}
  /// Clears the value of `enforcedelay`. Subsequent reads from it will return its default value.
  mutating func clearEnforcedelay() {self._enforcedelay = nil}

  var ignorefeelimits: Bool {
    get {return _ignorefeelimits ?? false}
    set {_ignorefeelimits = newValue}
  }
  /// Returns true if `ignorefeelimits` has been explicitly set.
  var hasIgnorefeelimits: Bool {return self._ignorefeelimits != nil}
  /// Clears the value of `ignorefeelimits`. Subsequent reads from it will return its default value.
  mutating func clearIgnorefeelimits() {self._ignorefeelimits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _feebase: Cln_Amount? = nil
  fileprivate var _feeppm: UInt32? = nil
  fileprivate var _htlcmin: Cln_Amount? = nil
  fileprivate var _htlcmax: Cln_Amount? = nil
  fileprivate var _enforcedelay: UInt32? = nil
  fileprivate var _ignorefeelimits: Bool? = nil
}

struct Cln_SetchannelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Cln_SetchannelChannels] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SetchannelChannels: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: Data = Data()

  var channelID: Data = Data()

  var shortChannelID: String {
    get {return _shortChannelID ?? String()}
    set {_shortChannelID = newValue}
  }
  /// Returns true if `shortChannelID` has been explicitly set.
  var hasShortChannelID: Bool {return self._shortChannelID != nil}
  /// Clears the value of `shortChannelID`. Subsequent reads from it will return its default value.
  mutating func clearShortChannelID() {self._shortChannelID = nil}

  var feeBaseMsat: Cln_Amount {
    get {return _feeBaseMsat ?? Cln_Amount()}
    set {_feeBaseMsat = newValue}
  }
  /// Returns true if `feeBaseMsat` has been explicitly set.
  var hasFeeBaseMsat: Bool {return self._feeBaseMsat != nil}
  /// Clears the value of `feeBaseMsat`. Subsequent reads from it will return its default value.
  mutating func clearFeeBaseMsat() {self._feeBaseMsat = nil}

  var feeProportionalMillionths: UInt32 = 0

  var ignoreFeeLimits: Bool {
    get {return _ignoreFeeLimits ?? false}
    set {_ignoreFeeLimits = newValue}
  }
  /// Returns true if `ignoreFeeLimits` has been explicitly set.
  var hasIgnoreFeeLimits: Bool {return self._ignoreFeeLimits != nil}
  /// Clears the value of `ignoreFeeLimits`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreFeeLimits() {self._ignoreFeeLimits = nil}

  var minimumHtlcOutMsat: Cln_Amount {
    get {return _minimumHtlcOutMsat ?? Cln_Amount()}
    set {_minimumHtlcOutMsat = newValue}
  }
  /// Returns true if `minimumHtlcOutMsat` has been explicitly set.
  var hasMinimumHtlcOutMsat: Bool {return self._minimumHtlcOutMsat != nil}
  /// Clears the value of `minimumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMinimumHtlcOutMsat() {self._minimumHtlcOutMsat = nil}

  var warningHtlcminTooLow: String {
    get {return _warningHtlcminTooLow ?? String()}
    set {_warningHtlcminTooLow = newValue}
  }
  /// Returns true if `warningHtlcminTooLow` has been explicitly set.
  var hasWarningHtlcminTooLow: Bool {return self._warningHtlcminTooLow != nil}
  /// Clears the value of `warningHtlcminTooLow`. Subsequent reads from it will return its default value.
  mutating func clearWarningHtlcminTooLow() {self._warningHtlcminTooLow = nil}

  var maximumHtlcOutMsat: Cln_Amount {
    get {return _maximumHtlcOutMsat ?? Cln_Amount()}
    set {_maximumHtlcOutMsat = newValue}
  }
  /// Returns true if `maximumHtlcOutMsat` has been explicitly set.
  var hasMaximumHtlcOutMsat: Bool {return self._maximumHtlcOutMsat != nil}
  /// Clears the value of `maximumHtlcOutMsat`. Subsequent reads from it will return its default value.
  mutating func clearMaximumHtlcOutMsat() {self._maximumHtlcOutMsat = nil}

  var warningHtlcmaxTooHigh: String {
    get {return _warningHtlcmaxTooHigh ?? String()}
    set {_warningHtlcmaxTooHigh = newValue}
  }
  /// Returns true if `warningHtlcmaxTooHigh` has been explicitly set.
  var hasWarningHtlcmaxTooHigh: Bool {return self._warningHtlcmaxTooHigh != nil}
  /// Clears the value of `warningHtlcmaxTooHigh`. Subsequent reads from it will return its default value.
  mutating func clearWarningHtlcmaxTooHigh() {self._warningHtlcmaxTooHigh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shortChannelID: String? = nil
  fileprivate var _feeBaseMsat: Cln_Amount? = nil
  fileprivate var _ignoreFeeLimits: Bool? = nil
  fileprivate var _minimumHtlcOutMsat: Cln_Amount? = nil
  fileprivate var _warningHtlcminTooLow: String? = nil
  fileprivate var _maximumHtlcOutMsat: Cln_Amount? = nil
  fileprivate var _warningHtlcmaxTooHigh: String? = nil
}

struct Cln_SigninvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invstring: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SigninvoiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SignmessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_SignmessageResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: Data = Data()

  var recid: Data = Data()

  var zbase: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_StopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_StopResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_PreapprovekeysendRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: Data {
    get {return _destination ?? Data()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var paymentHash: Data {
    get {return _paymentHash ?? Data()}
    set {_paymentHash = newValue}
  }
  /// Returns true if `paymentHash` has been explicitly set.
  var hasPaymentHash: Bool {return self._paymentHash != nil}
  /// Clears the value of `paymentHash`. Subsequent reads from it will return its default value.
  mutating func clearPaymentHash() {self._paymentHash = nil}

  var amountMsat: Cln_Amount {
    get {return _amountMsat ?? Cln_Amount()}
    set {_amountMsat = newValue}
  }
  /// Returns true if `amountMsat` has been explicitly set.
  var hasAmountMsat: Bool {return self._amountMsat != nil}
  /// Clears the value of `amountMsat`. Subsequent reads from it will return its default value.
  mutating func clearAmountMsat() {self._amountMsat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _destination: Data? = nil
  fileprivate var _paymentHash: Data? = nil
  fileprivate var _amountMsat: Cln_Amount? = nil
}

struct Cln_PreapprovekeysendResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_PreapproveinvoiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bolt11: String {
    get {return _bolt11 ?? String()}
    set {_bolt11 = newValue}
  }
  /// Returns true if `bolt11` has been explicitly set.
  var hasBolt11: Bool {return self._bolt11 != nil}
  /// Clears the value of `bolt11`. Subsequent reads from it will return its default value.
  mutating func clearBolt11() {self._bolt11 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bolt11: String? = nil
}

struct Cln_PreapproveinvoiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_StaticbackupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cln_StaticbackupResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scb: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cln"

extension Cln_GetinfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetinfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetinfoRequest, rhs: Cln_GetinfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetinfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetinfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "alias"),
    3: .same(proto: "color"),
    4: .standard(proto: "num_peers"),
    5: .standard(proto: "num_pending_channels"),
    6: .standard(proto: "num_active_channels"),
    7: .standard(proto: "num_inactive_channels"),
    8: .same(proto: "version"),
    9: .standard(proto: "lightning_dir"),
    10: .standard(proto: "our_features"),
    11: .same(proto: "blockheight"),
    12: .same(proto: "network"),
    13: .standard(proto: "fees_collected_msat"),
    14: .same(proto: "address"),
    15: .same(proto: "binding"),
    16: .standard(proto: "warning_bitcoind_sync"),
    17: .standard(proto: "warning_lightningd_sync"),
  ]

  fileprivate class _StorageClass {
    var _id: Data = Data()
    var _alias: String? = nil
    var _color: Data = Data()
    var _numPeers: UInt32 = 0
    var _numPendingChannels: UInt32 = 0
    var _numActiveChannels: UInt32 = 0
    var _numInactiveChannels: UInt32 = 0
    var _version: String = String()
    var _lightningDir: String = String()
    var _ourFeatures: Cln_GetinfoOur_features? = nil
    var _blockheight: UInt32 = 0
    var _network: String = String()
    var _feesCollectedMsat: Cln_Amount? = nil
    var _address: [Cln_GetinfoAddress] = []
    var _binding: [Cln_GetinfoBinding] = []
    var _warningBitcoindSync: String? = nil
    var _warningLightningdSync: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _alias = source._alias
      _color = source._color
      _numPeers = source._numPeers
      _numPendingChannels = source._numPendingChannels
      _numActiveChannels = source._numActiveChannels
      _numInactiveChannels = source._numInactiveChannels
      _version = source._version
      _lightningDir = source._lightningDir
      _ourFeatures = source._ourFeatures
      _blockheight = source._blockheight
      _network = source._network
      _feesCollectedMsat = source._feesCollectedMsat
      _address = source._address
      _binding = source._binding
      _warningBitcoindSync = source._warningBitcoindSync
      _warningLightningdSync = source._warningLightningdSync
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._alias) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._color) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._numPeers) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._numPendingChannels) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._numActiveChannels) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._numInactiveChannels) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._lightningDir) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._ourFeatures) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._blockheight) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._feesCollectedMsat) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._address) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._binding) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._warningBitcoindSync) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._warningLightningdSync) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._alias {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      if !_storage._color.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._color, fieldNumber: 3)
      }
      if _storage._numPeers != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numPeers, fieldNumber: 4)
      }
      if _storage._numPendingChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numPendingChannels, fieldNumber: 5)
      }
      if _storage._numActiveChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numActiveChannels, fieldNumber: 6)
      }
      if _storage._numInactiveChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numInactiveChannels, fieldNumber: 7)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 8)
      }
      if !_storage._lightningDir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lightningDir, fieldNumber: 9)
      }
      try { if let v = _storage._ourFeatures {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._blockheight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._blockheight, fieldNumber: 11)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 12)
      }
      try { if let v = _storage._feesCollectedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._address.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._address, fieldNumber: 14)
      }
      if !_storage._binding.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._binding, fieldNumber: 15)
      }
      try { if let v = _storage._warningBitcoindSync {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._warningLightningdSync {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetinfoResponse, rhs: Cln_GetinfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._numPeers != rhs_storage._numPeers {return false}
        if _storage._numPendingChannels != rhs_storage._numPendingChannels {return false}
        if _storage._numActiveChannels != rhs_storage._numActiveChannels {return false}
        if _storage._numInactiveChannels != rhs_storage._numInactiveChannels {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._lightningDir != rhs_storage._lightningDir {return false}
        if _storage._ourFeatures != rhs_storage._ourFeatures {return false}
        if _storage._blockheight != rhs_storage._blockheight {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._feesCollectedMsat != rhs_storage._feesCollectedMsat {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._binding != rhs_storage._binding {return false}
        if _storage._warningBitcoindSync != rhs_storage._warningBitcoindSync {return false}
        if _storage._warningLightningdSync != rhs_storage._warningLightningdSync {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetinfoOur_features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetinfoOur_features"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "node"),
    3: .same(proto: "channel"),
    4: .same(proto: "invoice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.init_p) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.node) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.channel) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.invoice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.init_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.init_p, fieldNumber: 1)
    }
    if !self.node.isEmpty {
      try visitor.visitSingularBytesField(value: self.node, fieldNumber: 2)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularBytesField(value: self.channel, fieldNumber: 3)
    }
    if !self.invoice.isEmpty {
      try visitor.visitSingularBytesField(value: self.invoice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetinfoOur_features, rhs: Cln_GetinfoOur_features) -> Bool {
    if lhs.init_p != rhs.init_p {return false}
    if lhs.node != rhs.node {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.invoice != rhs.invoice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetinfoAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetinfoAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "port"),
    3: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .dns {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetinfoAddress, rhs: Cln_GetinfoAddress) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.port != rhs.port {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetinfoAddress.GetinfoAddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DNS"),
    1: .same(proto: "IPV4"),
    2: .same(proto: "IPV6"),
    3: .same(proto: "TORV2"),
    4: .same(proto: "TORV3"),
  ]
}

extension Cln_GetinfoBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetinfoBinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "address"),
    3: .same(proto: "port"),
    4: .same(proto: "socket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._port) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._socket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .localSocket {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._socket {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetinfoBinding, rhs: Cln_GetinfoBinding) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs._address != rhs._address {return false}
    if lhs._port != rhs._port {return false}
    if lhs._socket != rhs._socket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetinfoBinding.GetinfoBindingType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCAL_SOCKET"),
    1: .same(proto: "IPV4"),
    2: .same(proto: "IPV6"),
    3: .same(proto: "TORV2"),
    4: .same(proto: "TORV3"),
    5: .same(proto: "WEBSOCKET"),
  ]
}

extension Cln_ListpeersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._level {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersRequest, rhs: Cln_ListpeersRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._level != rhs._level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersResponse, rhs: Cln_ListpeersResponse) -> Bool {
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "connected"),
    8: .standard(proto: "num_channels"),
    3: .same(proto: "log"),
    4: .same(proto: "channels"),
    5: .same(proto: "netaddr"),
    7: .standard(proto: "remote_addr"),
    6: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.log) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.netaddr) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._features) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._remoteAddr) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._numChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 3)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 4)
    }
    if !self.netaddr.isEmpty {
      try visitor.visitRepeatedStringField(value: self.netaddr, fieldNumber: 5)
    }
    try { if let v = self._features {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._remoteAddr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._numChannels {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeers, rhs: Cln_ListpeersPeers) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs._numChannels != rhs._numChannels {return false}
    if lhs.log != rhs.log {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.netaddr != rhs.netaddr {return false}
    if lhs._remoteAddr != rhs._remoteAddr {return false}
    if lhs._features != rhs._features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .standard(proto: "num_skipped"),
    3: .same(proto: "time"),
    4: .same(proto: "source"),
    5: .same(proto: "log"),
    6: .standard(proto: "node_id"),
    7: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numSkipped) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._log) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._nodeID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .skipped {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try { if let v = self._numSkipped {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._log {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersLog, rhs: Cln_ListpeersPeersLog) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs._numSkipped != rhs._numSkipped {return false}
    if lhs._time != rhs._time {return false}
    if lhs._source != rhs._source {return false}
    if lhs._log != rhs._log {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersLog.ListpeersPeersLogType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SKIPPED"),
    1: .same(proto: "BROKEN"),
    2: .same(proto: "UNUSUAL"),
    3: .same(proto: "INFO"),
    4: .same(proto: "DEBUG"),
    5: .same(proto: "IO_IN"),
    6: .same(proto: "IO_OUT"),
  ]
}

extension Cln_ListpeersPeersChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "scratch_txid"),
    3: .same(proto: "feerate"),
    4: .same(proto: "owner"),
    5: .standard(proto: "short_channel_id"),
    6: .standard(proto: "channel_id"),
    7: .standard(proto: "funding_txid"),
    8: .standard(proto: "funding_outnum"),
    9: .standard(proto: "initial_feerate"),
    10: .standard(proto: "last_feerate"),
    11: .standard(proto: "next_feerate"),
    12: .standard(proto: "next_fee_step"),
    13: .same(proto: "inflight"),
    14: .standard(proto: "close_to"),
    15: .same(proto: "private"),
    16: .same(proto: "opener"),
    17: .same(proto: "closer"),
    18: .same(proto: "features"),
    19: .same(proto: "funding"),
    20: .standard(proto: "to_us_msat"),
    21: .standard(proto: "min_to_us_msat"),
    22: .standard(proto: "max_to_us_msat"),
    23: .standard(proto: "total_msat"),
    24: .standard(proto: "fee_base_msat"),
    25: .standard(proto: "fee_proportional_millionths"),
    26: .standard(proto: "dust_limit_msat"),
    27: .standard(proto: "max_total_htlc_in_msat"),
    28: .standard(proto: "their_reserve_msat"),
    29: .standard(proto: "our_reserve_msat"),
    30: .standard(proto: "spendable_msat"),
    31: .standard(proto: "receivable_msat"),
    32: .standard(proto: "minimum_htlc_in_msat"),
    48: .standard(proto: "minimum_htlc_out_msat"),
    49: .standard(proto: "maximum_htlc_out_msat"),
    33: .standard(proto: "their_to_self_delay"),
    34: .standard(proto: "our_to_self_delay"),
    35: .standard(proto: "max_accepted_htlcs"),
    50: .same(proto: "alias"),
    37: .same(proto: "status"),
    38: .standard(proto: "in_payments_offered"),
    39: .standard(proto: "in_offered_msat"),
    40: .standard(proto: "in_payments_fulfilled"),
    41: .standard(proto: "in_fulfilled_msat"),
    42: .standard(proto: "out_payments_offered"),
    43: .standard(proto: "out_offered_msat"),
    44: .standard(proto: "out_payments_fulfilled"),
    45: .standard(proto: "out_fulfilled_msat"),
    46: .same(proto: "htlcs"),
    47: .standard(proto: "close_to_addr"),
  ]

  fileprivate class _StorageClass {
    var _state: Cln_ListpeersPeersChannels.ListpeersPeersChannelsState = .openingd
    var _scratchTxid: Data? = nil
    var _feerate: Cln_ListpeersPeersChannelsFeerate? = nil
    var _owner: String? = nil
    var _shortChannelID: String? = nil
    var _channelID: Data? = nil
    var _fundingTxid: Data? = nil
    var _fundingOutnum: UInt32? = nil
    var _initialFeerate: String? = nil
    var _lastFeerate: String? = nil
    var _nextFeerate: String? = nil
    var _nextFeeStep: UInt32? = nil
    var _inflight: [Cln_ListpeersPeersChannelsInflight] = []
    var _closeTo: Data? = nil
    var _private: Bool? = nil
    var _opener: Cln_ChannelSide = .local
    var _closer: Cln_ChannelSide? = nil
    var _features: [String] = []
    var _funding: Cln_ListpeersPeersChannelsFunding? = nil
    var _toUsMsat: Cln_Amount? = nil
    var _minToUsMsat: Cln_Amount? = nil
    var _maxToUsMsat: Cln_Amount? = nil
    var _totalMsat: Cln_Amount? = nil
    var _feeBaseMsat: Cln_Amount? = nil
    var _feeProportionalMillionths: UInt32? = nil
    var _dustLimitMsat: Cln_Amount? = nil
    var _maxTotalHtlcInMsat: Cln_Amount? = nil
    var _theirReserveMsat: Cln_Amount? = nil
    var _ourReserveMsat: Cln_Amount? = nil
    var _spendableMsat: Cln_Amount? = nil
    var _receivableMsat: Cln_Amount? = nil
    var _minimumHtlcInMsat: Cln_Amount? = nil
    var _minimumHtlcOutMsat: Cln_Amount? = nil
    var _maximumHtlcOutMsat: Cln_Amount? = nil
    var _theirToSelfDelay: UInt32? = nil
    var _ourToSelfDelay: UInt32? = nil
    var _maxAcceptedHtlcs: UInt32? = nil
    var _alias: Cln_ListpeersPeersChannelsAlias? = nil
    var _status: [String] = []
    var _inPaymentsOffered: UInt64? = nil
    var _inOfferedMsat: Cln_Amount? = nil
    var _inPaymentsFulfilled: UInt64? = nil
    var _inFulfilledMsat: Cln_Amount? = nil
    var _outPaymentsOffered: UInt64? = nil
    var _outOfferedMsat: Cln_Amount? = nil
    var _outPaymentsFulfilled: UInt64? = nil
    var _outFulfilledMsat: Cln_Amount? = nil
    var _htlcs: [Cln_ListpeersPeersChannelsHtlcs] = []
    var _closeToAddr: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _state = source._state
      _scratchTxid = source._scratchTxid
      _feerate = source._feerate
      _owner = source._owner
      _shortChannelID = source._shortChannelID
      _channelID = source._channelID
      _fundingTxid = source._fundingTxid
      _fundingOutnum = source._fundingOutnum
      _initialFeerate = source._initialFeerate
      _lastFeerate = source._lastFeerate
      _nextFeerate = source._nextFeerate
      _nextFeeStep = source._nextFeeStep
      _inflight = source._inflight
      _closeTo = source._closeTo
      _private = source._private
      _opener = source._opener
      _closer = source._closer
      _features = source._features
      _funding = source._funding
      _toUsMsat = source._toUsMsat
      _minToUsMsat = source._minToUsMsat
      _maxToUsMsat = source._maxToUsMsat
      _totalMsat = source._totalMsat
      _feeBaseMsat = source._feeBaseMsat
      _feeProportionalMillionths = source._feeProportionalMillionths
      _dustLimitMsat = source._dustLimitMsat
      _maxTotalHtlcInMsat = source._maxTotalHtlcInMsat
      _theirReserveMsat = source._theirReserveMsat
      _ourReserveMsat = source._ourReserveMsat
      _spendableMsat = source._spendableMsat
      _receivableMsat = source._receivableMsat
      _minimumHtlcInMsat = source._minimumHtlcInMsat
      _minimumHtlcOutMsat = source._minimumHtlcOutMsat
      _maximumHtlcOutMsat = source._maximumHtlcOutMsat
      _theirToSelfDelay = source._theirToSelfDelay
      _ourToSelfDelay = source._ourToSelfDelay
      _maxAcceptedHtlcs = source._maxAcceptedHtlcs
      _alias = source._alias
      _status = source._status
      _inPaymentsOffered = source._inPaymentsOffered
      _inOfferedMsat = source._inOfferedMsat
      _inPaymentsFulfilled = source._inPaymentsFulfilled
      _inFulfilledMsat = source._inFulfilledMsat
      _outPaymentsOffered = source._outPaymentsOffered
      _outOfferedMsat = source._outOfferedMsat
      _outPaymentsFulfilled = source._outPaymentsFulfilled
      _outFulfilledMsat = source._outFulfilledMsat
      _htlcs = source._htlcs
      _closeToAddr = source._closeToAddr
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._scratchTxid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._feerate) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._shortChannelID) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._channelID) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._fundingTxid) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._fundingOutnum) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._initialFeerate) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._lastFeerate) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._nextFeerate) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextFeeStep) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._inflight) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._closeTo) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._opener) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._closer) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._features) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._funding) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._toUsMsat) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._minToUsMsat) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._maxToUsMsat) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._totalMsat) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._feeBaseMsat) }()
        case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._feeProportionalMillionths) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._dustLimitMsat) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._maxTotalHtlcInMsat) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._theirReserveMsat) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._ourReserveMsat) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._spendableMsat) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._receivableMsat) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._minimumHtlcInMsat) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._theirToSelfDelay) }()
        case 34: try { try decoder.decodeSingularUInt32Field(value: &_storage._ourToSelfDelay) }()
        case 35: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxAcceptedHtlcs) }()
        case 37: try { try decoder.decodeRepeatedStringField(value: &_storage._status) }()
        case 38: try { try decoder.decodeSingularUInt64Field(value: &_storage._inPaymentsOffered) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._inOfferedMsat) }()
        case 40: try { try decoder.decodeSingularUInt64Field(value: &_storage._inPaymentsFulfilled) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._inFulfilledMsat) }()
        case 42: try { try decoder.decodeSingularUInt64Field(value: &_storage._outPaymentsOffered) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._outOfferedMsat) }()
        case 44: try { try decoder.decodeSingularUInt64Field(value: &_storage._outPaymentsFulfilled) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._outFulfilledMsat) }()
        case 46: try { try decoder.decodeRepeatedMessageField(value: &_storage._htlcs) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._closeToAddr) }()
        case 48: try { try decoder.decodeSingularMessageField(value: &_storage._minimumHtlcOutMsat) }()
        case 49: try { try decoder.decodeSingularMessageField(value: &_storage._maximumHtlcOutMsat) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._alias) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._state != .openingd {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 1)
      }
      try { if let v = _storage._scratchTxid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._feerate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._shortChannelID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._channelID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._fundingTxid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fundingOutnum {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._initialFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._nextFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._nextFeeStep {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      if !_storage._inflight.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inflight, fieldNumber: 13)
      }
      try { if let v = _storage._closeTo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._private {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      if _storage._opener != .local {
        try visitor.visitSingularEnumField(value: _storage._opener, fieldNumber: 16)
      }
      try { if let v = _storage._closer {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 17)
      } }()
      if !_storage._features.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._features, fieldNumber: 18)
      }
      try { if let v = _storage._funding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._toUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._minToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._maxToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._totalMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._feeBaseMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._feeProportionalMillionths {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._dustLimitMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._maxTotalHtlcInMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._theirReserveMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._ourReserveMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._spendableMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._receivableMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._minimumHtlcInMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._theirToSelfDelay {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._ourToSelfDelay {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._maxAcceptedHtlcs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 35)
      } }()
      if !_storage._status.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._status, fieldNumber: 37)
      }
      try { if let v = _storage._inPaymentsOffered {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._inOfferedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._inPaymentsFulfilled {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._inFulfilledMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._outPaymentsOffered {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._outOfferedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._outPaymentsFulfilled {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._outFulfilledMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      if !_storage._htlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._htlcs, fieldNumber: 46)
      }
      try { if let v = _storage._closeToAddr {
        try visitor.visitSingularStringField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._minimumHtlcOutMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._maximumHtlcOutMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._alias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannels, rhs: Cln_ListpeersPeersChannels) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._state != rhs_storage._state {return false}
        if _storage._scratchTxid != rhs_storage._scratchTxid {return false}
        if _storage._feerate != rhs_storage._feerate {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._shortChannelID != rhs_storage._shortChannelID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._fundingTxid != rhs_storage._fundingTxid {return false}
        if _storage._fundingOutnum != rhs_storage._fundingOutnum {return false}
        if _storage._initialFeerate != rhs_storage._initialFeerate {return false}
        if _storage._lastFeerate != rhs_storage._lastFeerate {return false}
        if _storage._nextFeerate != rhs_storage._nextFeerate {return false}
        if _storage._nextFeeStep != rhs_storage._nextFeeStep {return false}
        if _storage._inflight != rhs_storage._inflight {return false}
        if _storage._closeTo != rhs_storage._closeTo {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._opener != rhs_storage._opener {return false}
        if _storage._closer != rhs_storage._closer {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._funding != rhs_storage._funding {return false}
        if _storage._toUsMsat != rhs_storage._toUsMsat {return false}
        if _storage._minToUsMsat != rhs_storage._minToUsMsat {return false}
        if _storage._maxToUsMsat != rhs_storage._maxToUsMsat {return false}
        if _storage._totalMsat != rhs_storage._totalMsat {return false}
        if _storage._feeBaseMsat != rhs_storage._feeBaseMsat {return false}
        if _storage._feeProportionalMillionths != rhs_storage._feeProportionalMillionths {return false}
        if _storage._dustLimitMsat != rhs_storage._dustLimitMsat {return false}
        if _storage._maxTotalHtlcInMsat != rhs_storage._maxTotalHtlcInMsat {return false}
        if _storage._theirReserveMsat != rhs_storage._theirReserveMsat {return false}
        if _storage._ourReserveMsat != rhs_storage._ourReserveMsat {return false}
        if _storage._spendableMsat != rhs_storage._spendableMsat {return false}
        if _storage._receivableMsat != rhs_storage._receivableMsat {return false}
        if _storage._minimumHtlcInMsat != rhs_storage._minimumHtlcInMsat {return false}
        if _storage._minimumHtlcOutMsat != rhs_storage._minimumHtlcOutMsat {return false}
        if _storage._maximumHtlcOutMsat != rhs_storage._maximumHtlcOutMsat {return false}
        if _storage._theirToSelfDelay != rhs_storage._theirToSelfDelay {return false}
        if _storage._ourToSelfDelay != rhs_storage._ourToSelfDelay {return false}
        if _storage._maxAcceptedHtlcs != rhs_storage._maxAcceptedHtlcs {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._inPaymentsOffered != rhs_storage._inPaymentsOffered {return false}
        if _storage._inOfferedMsat != rhs_storage._inOfferedMsat {return false}
        if _storage._inPaymentsFulfilled != rhs_storage._inPaymentsFulfilled {return false}
        if _storage._inFulfilledMsat != rhs_storage._inFulfilledMsat {return false}
        if _storage._outPaymentsOffered != rhs_storage._outPaymentsOffered {return false}
        if _storage._outOfferedMsat != rhs_storage._outOfferedMsat {return false}
        if _storage._outPaymentsFulfilled != rhs_storage._outPaymentsFulfilled {return false}
        if _storage._outFulfilledMsat != rhs_storage._outFulfilledMsat {return false}
        if _storage._htlcs != rhs_storage._htlcs {return false}
        if _storage._closeToAddr != rhs_storage._closeToAddr {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannels.ListpeersPeersChannelsState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPENINGD"),
    1: .same(proto: "CHANNELD_AWAITING_LOCKIN"),
    2: .same(proto: "CHANNELD_NORMAL"),
    3: .same(proto: "CHANNELD_SHUTTING_DOWN"),
    4: .same(proto: "CLOSINGD_SIGEXCHANGE"),
    5: .same(proto: "CLOSINGD_COMPLETE"),
    6: .same(proto: "AWAITING_UNILATERAL"),
    7: .same(proto: "FUNDING_SPEND_SEEN"),
    8: .same(proto: "ONCHAIN"),
    9: .same(proto: "DUALOPEND_OPEN_INIT"),
    10: .same(proto: "DUALOPEND_AWAITING_LOCKIN"),
  ]
}

extension Cln_ListpeersPeersChannelsFeerate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannelsFeerate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "perkw"),
    2: .same(proto: "perkb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.perkw) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.perkb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.perkw != 0 {
      try visitor.visitSingularUInt32Field(value: self.perkw, fieldNumber: 1)
    }
    if self.perkb != 0 {
      try visitor.visitSingularUInt32Field(value: self.perkb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannelsFeerate, rhs: Cln_ListpeersPeersChannelsFeerate) -> Bool {
    if lhs.perkw != rhs.perkw {return false}
    if lhs.perkb != rhs.perkb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannelsInflight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannelsInflight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funding_txid"),
    2: .standard(proto: "funding_outnum"),
    3: .same(proto: "feerate"),
    4: .standard(proto: "total_funding_msat"),
    5: .standard(proto: "our_funding_msat"),
    7: .standard(proto: "splice_amount"),
    6: .standard(proto: "scratch_txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundingTxid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.fundingOutnum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.feerate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalFundingMsat) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ourFundingMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.scratchTxid) }()
      case 7: try { try decoder.decodeSingularSInt64Field(value: &self._spliceAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fundingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundingTxid, fieldNumber: 1)
    }
    if self.fundingOutnum != 0 {
      try visitor.visitSingularUInt32Field(value: self.fundingOutnum, fieldNumber: 2)
    }
    if !self.feerate.isEmpty {
      try visitor.visitSingularStringField(value: self.feerate, fieldNumber: 3)
    }
    try { if let v = self._totalFundingMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ourFundingMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.scratchTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.scratchTxid, fieldNumber: 6)
    }
    try { if let v = self._spliceAmount {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannelsInflight, rhs: Cln_ListpeersPeersChannelsInflight) -> Bool {
    if lhs.fundingTxid != rhs.fundingTxid {return false}
    if lhs.fundingOutnum != rhs.fundingOutnum {return false}
    if lhs.feerate != rhs.feerate {return false}
    if lhs._totalFundingMsat != rhs._totalFundingMsat {return false}
    if lhs._ourFundingMsat != rhs._ourFundingMsat {return false}
    if lhs._spliceAmount != rhs._spliceAmount {return false}
    if lhs.scratchTxid != rhs.scratchTxid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannelsFunding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannelsFunding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "pushed_msat"),
    4: .standard(proto: "local_funds_msat"),
    7: .standard(proto: "remote_funds_msat"),
    5: .standard(proto: "fee_paid_msat"),
    6: .standard(proto: "fee_rcvd_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pushedMsat) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._localFundsMsat) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feePaidMsat) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._feeRcvdMsat) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._remoteFundsMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._localFundsMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._feePaidMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._feeRcvdMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._remoteFundsMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannelsFunding, rhs: Cln_ListpeersPeersChannelsFunding) -> Bool {
    if lhs._pushedMsat != rhs._pushedMsat {return false}
    if lhs._localFundsMsat != rhs._localFundsMsat {return false}
    if lhs._remoteFundsMsat != rhs._remoteFundsMsat {return false}
    if lhs._feePaidMsat != rhs._feePaidMsat {return false}
    if lhs._feeRcvdMsat != rhs._feeRcvdMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannelsAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannelsAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._local) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._remote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._local {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannelsAlias, rhs: Cln_ListpeersPeersChannelsAlias) -> Bool {
    if lhs._local != rhs._local {return false}
    if lhs._remote != rhs._remote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannelsHtlcs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeersPeersChannelsHtlcs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "id"),
    3: .standard(proto: "amount_msat"),
    4: .same(proto: "expiry"),
    5: .standard(proto: "payment_hash"),
    6: .standard(proto: "local_trimmed"),
    7: .same(proto: "status"),
    8: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.expiry) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._localTrimmed) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._status) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.direction != .in {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 4)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 5)
    }
    try { if let v = self._localTrimmed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if self.state != .sentAddHtlc {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeersPeersChannelsHtlcs, rhs: Cln_ListpeersPeersChannelsHtlcs) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.id != rhs.id {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._localTrimmed != rhs._localTrimmed {return false}
    if lhs._status != rhs._status {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeersPeersChannelsHtlcs.ListpeersPeersChannelsHtlcsDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN"),
    1: .same(proto: "OUT"),
  ]
}

extension Cln_ListfundsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListfundsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._spent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListfundsRequest, rhs: Cln_ListfundsRequest) -> Bool {
    if lhs._spent != rhs._spent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListfundsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListfundsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
    2: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListfundsResponse, rhs: Cln_ListfundsResponse) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListfundsOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListfundsOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "output"),
    3: .standard(proto: "amount_msat"),
    4: .same(proto: "scriptpubkey"),
    5: .same(proto: "address"),
    6: .same(proto: "redeemscript"),
    7: .same(proto: "status"),
    9: .same(proto: "reserved"),
    8: .same(proto: "blockheight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.output) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.scriptpubkey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._redeemscript) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._blockheight) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reserved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.output != 0 {
      try visitor.visitSingularUInt32Field(value: self.output, fieldNumber: 2)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.scriptpubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.scriptpubkey, fieldNumber: 4)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._redeemscript {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if self.status != .unconfirmed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    try { if let v = self._blockheight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    if self.reserved != false {
      try visitor.visitSingularBoolField(value: self.reserved, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListfundsOutputs, rhs: Cln_ListfundsOutputs) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.output != rhs.output {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.scriptpubkey != rhs.scriptpubkey {return false}
    if lhs._address != rhs._address {return false}
    if lhs._redeemscript != rhs._redeemscript {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reserved != rhs.reserved {return false}
    if lhs._blockheight != rhs._blockheight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListfundsOutputs.ListfundsOutputsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNCONFIRMED"),
    1: .same(proto: "CONFIRMED"),
    2: .same(proto: "SPENT"),
    3: .same(proto: "IMMATURE"),
  ]
}

extension Cln_ListfundsChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListfundsChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "our_amount_msat"),
    3: .standard(proto: "amount_msat"),
    4: .standard(proto: "funding_txid"),
    5: .standard(proto: "funding_output"),
    6: .same(proto: "connected"),
    7: .same(proto: "state"),
    9: .standard(proto: "channel_id"),
    8: .standard(proto: "short_channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ourAmountMsat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.fundingTxid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.fundingOutput) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._shortChannelID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 1)
    }
    try { if let v = self._ourAmountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.fundingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundingTxid, fieldNumber: 4)
    }
    if self.fundingOutput != 0 {
      try visitor.visitSingularUInt32Field(value: self.fundingOutput, fieldNumber: 5)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 6)
    }
    if self.state != .openingd {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try { if let v = self._shortChannelID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._channelID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListfundsChannels, rhs: Cln_ListfundsChannels) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs._ourAmountMsat != rhs._ourAmountMsat {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.fundingTxid != rhs.fundingTxid {return false}
    if lhs.fundingOutput != rhs.fundingOutput {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.state != rhs.state {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs._shortChannelID != rhs._shortChannelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendpayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendpayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
    2: .standard(proto: "payment_hash"),
    3: .same(proto: "label"),
    10: .standard(proto: "amount_msat"),
    5: .same(proto: "bolt11"),
    6: .standard(proto: "payment_secret"),
    7: .same(proto: "partid"),
    11: .same(proto: "localinvreqid"),
    9: .same(proto: "groupid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.route) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._paymentSecret) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._partid) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._groupid) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self._localinvreqid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.route.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.route, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 2)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._paymentSecret {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._partid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._groupid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._localinvreqid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendpayRequest, rhs: Cln_SendpayRequest) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._label != rhs._label {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._paymentSecret != rhs._paymentSecret {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._localinvreqid != rhs._localinvreqid {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendpayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendpayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groupid"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "amount_msat"),
    6: .same(proto: "destination"),
    7: .standard(proto: "created_at"),
    15: .standard(proto: "completed_at"),
    8: .standard(proto: "amount_sent_msat"),
    9: .same(proto: "label"),
    10: .same(proto: "partid"),
    11: .same(proto: "bolt11"),
    12: .same(proto: "bolt12"),
    13: .standard(proto: "payment_preimage"),
    14: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._groupid) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._partid) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self._completedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._groupid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 7)
    }
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._partid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._completedAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendpayResponse, rhs: Cln_SendpayResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendpayResponse.SendpayStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETE"),
  ]
}

extension Cln_SendpayRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendpayRoute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "amount_msat"),
    2: .same(proto: "id"),
    3: .same(proto: "delay"),
    4: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.delay) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 2)
    }
    if self.delay != 0 {
      try visitor.visitSingularUInt32Field(value: self.delay, fieldNumber: 3)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendpayRoute, rhs: Cln_SendpayRoute) -> Bool {
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.id != rhs.id {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListchannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListchannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_channel_id"),
    2: .same(proto: "source"),
    3: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._shortChannelID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shortChannelID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListchannelsRequest, rhs: Cln_ListchannelsRequest) -> Bool {
    if lhs._shortChannelID != rhs._shortChannelID {return false}
    if lhs._source != rhs._source {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListchannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListchannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListchannelsResponse, rhs: Cln_ListchannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListchannelsChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListchannelsChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "destination"),
    3: .standard(proto: "short_channel_id"),
    16: .same(proto: "direction"),
    4: .same(proto: "public"),
    5: .standard(proto: "amount_msat"),
    6: .standard(proto: "message_flags"),
    7: .standard(proto: "channel_flags"),
    8: .same(proto: "active"),
    9: .standard(proto: "last_update"),
    10: .standard(proto: "base_fee_millisatoshi"),
    11: .standard(proto: "fee_per_millionth"),
    12: .same(proto: "delay"),
    13: .standard(proto: "htlc_minimum_msat"),
    14: .standard(proto: "htlc_maximum_msat"),
    15: .same(proto: "features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortChannelID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.`public`) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.messageFlags) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.channelFlags) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.lastUpdate) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.baseFeeMillisatoshi) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.feePerMillionth) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.delay) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._htlcMinimumMsat) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._htlcMaximumMsat) }()
      case 15: try { try decoder.decodeSingularBytesField(value: &self.features) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.source.isEmpty {
      try visitor.visitSingularBytesField(value: self.source, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularBytesField(value: self.destination, fieldNumber: 2)
    }
    if !self.shortChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.shortChannelID, fieldNumber: 3)
    }
    if self.`public` != false {
      try visitor.visitSingularBoolField(value: self.`public`, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.messageFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageFlags, fieldNumber: 6)
    }
    if self.channelFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelFlags, fieldNumber: 7)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 8)
    }
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 9)
    }
    if self.baseFeeMillisatoshi != 0 {
      try visitor.visitSingularUInt32Field(value: self.baseFeeMillisatoshi, fieldNumber: 10)
    }
    if self.feePerMillionth != 0 {
      try visitor.visitSingularUInt32Field(value: self.feePerMillionth, fieldNumber: 11)
    }
    if self.delay != 0 {
      try visitor.visitSingularUInt32Field(value: self.delay, fieldNumber: 12)
    }
    try { if let v = self._htlcMinimumMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._htlcMaximumMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    if !self.features.isEmpty {
      try visitor.visitSingularBytesField(value: self.features, fieldNumber: 15)
    }
    if self.direction != 0 {
      try visitor.visitSingularUInt32Field(value: self.direction, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListchannelsChannels, rhs: Cln_ListchannelsChannels) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.shortChannelID != rhs.shortChannelID {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.`public` != rhs.`public` {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.messageFlags != rhs.messageFlags {return false}
    if lhs.channelFlags != rhs.channelFlags {return false}
    if lhs.active != rhs.active {return false}
    if lhs.lastUpdate != rhs.lastUpdate {return false}
    if lhs.baseFeeMillisatoshi != rhs.baseFeeMillisatoshi {return false}
    if lhs.feePerMillionth != rhs.feePerMillionth {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs._htlcMinimumMsat != rhs._htlcMinimumMsat {return false}
    if lhs._htlcMaximumMsat != rhs._htlcMaximumMsat {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_AddgossipRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddgossipRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_AddgossipRequest, rhs: Cln_AddgossipRequest) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_AddgossipResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddgossipResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_AddgossipResponse, rhs: Cln_AddgossipResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_AutocleaninvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutocleaninvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expired_by"),
    2: .standard(proto: "cycle_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._expiredBy) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._cycleSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expiredBy {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cycleSeconds {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_AutocleaninvoiceRequest, rhs: Cln_AutocleaninvoiceRequest) -> Bool {
    if lhs._expiredBy != rhs._expiredBy {return false}
    if lhs._cycleSeconds != rhs._cycleSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_AutocleaninvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutocleaninvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "expired_by"),
    3: .standard(proto: "cycle_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._expiredBy) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._cycleSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try { if let v = self._expiredBy {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cycleSeconds {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_AutocleaninvoiceResponse, rhs: Cln_AutocleaninvoiceResponse) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs._expiredBy != rhs._expiredBy {return false}
    if lhs._cycleSeconds != rhs._cycleSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CheckmessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckmessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "zbase"),
    3: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zbase) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._pubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.zbase.isEmpty {
      try visitor.visitSingularStringField(value: self.zbase, fieldNumber: 2)
    }
    try { if let v = self._pubkey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CheckmessageRequest, rhs: Cln_CheckmessageRequest) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.zbase != rhs.zbase {return false}
    if lhs._pubkey != rhs._pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CheckmessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckmessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verified"),
    2: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verified) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CheckmessageResponse, rhs: Cln_CheckmessageResponse) -> Bool {
    if lhs.verified != rhs.verified {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "unilateraltimeout"),
    3: .same(proto: "destination"),
    4: .standard(proto: "fee_negotiation_step"),
    5: .standard(proto: "wrong_funding"),
    6: .standard(proto: "force_lease_closed"),
    7: .same(proto: "feerange"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._unilateraltimeout) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._feeNegotiationStep) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._wrongFunding) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._forceLeaseClosed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.feerange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._unilateraltimeout {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._feeNegotiationStep {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._wrongFunding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._forceLeaseClosed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    if !self.feerange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feerange, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CloseRequest, rhs: Cln_CloseRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._unilateraltimeout != rhs._unilateraltimeout {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._feeNegotiationStep != rhs._feeNegotiationStep {return false}
    if lhs._wrongFunding != rhs._wrongFunding {return false}
    if lhs._forceLeaseClosed != rhs._forceLeaseClosed {return false}
    if lhs.feerange != rhs.feerange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "tx"),
    3: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._tx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .mutual {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try { if let v = self._tx {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CloseResponse, rhs: Cln_CloseResponse) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs._txid != rhs._txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CloseResponse.CloseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTUAL"),
    1: .same(proto: "UNILATERAL"),
    2: .same(proto: "UNOPENED"),
  ]
}

extension Cln_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "host"),
    3: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._host) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._host {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ConnectRequest, rhs: Cln_ConnectRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._host != rhs._host {return false}
    if lhs._port != rhs._port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "features"),
    3: .same(proto: "direction"),
    4: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.features) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.features.isEmpty {
      try visitor.visitSingularBytesField(value: self.features, fieldNumber: 2)
    }
    if self.direction != .in {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ConnectResponse, rhs: Cln_ConnectResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.features != rhs.features {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ConnectResponse.ConnectDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN"),
    1: .same(proto: "OUT"),
  ]
}

extension Cln_ConnectAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "socket"),
    3: .same(proto: "address"),
    4: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._socket) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .localSocket {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try { if let v = self._socket {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ConnectAddress, rhs: Cln_ConnectAddress) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs._socket != rhs._socket {return false}
    if lhs._address != rhs._address {return false}
    if lhs._port != rhs._port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ConnectAddress.ConnectAddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCAL_SOCKET"),
    1: .same(proto: "IPV4"),
    2: .same(proto: "IPV6"),
    3: .same(proto: "TORV2"),
    4: .same(proto: "TORV3"),
  ]
}

extension Cln_CreateinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invstring"),
    2: .same(proto: "label"),
    3: .same(proto: "preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.invstring) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invstring.isEmpty {
      try visitor.visitSingularStringField(value: self.invstring, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CreateinvoiceRequest, rhs: Cln_CreateinvoiceRequest) -> Bool {
    if lhs.invstring != rhs.invstring {return false}
    if lhs.label != rhs.label {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CreateinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateinvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "bolt11"),
    3: .same(proto: "bolt12"),
    4: .standard(proto: "payment_hash"),
    5: .standard(proto: "amount_msat"),
    6: .same(proto: "status"),
    7: .same(proto: "description"),
    8: .standard(proto: "expires_at"),
    16: .standard(proto: "created_index"),
    9: .standard(proto: "pay_index"),
    10: .standard(proto: "amount_received_msat"),
    11: .standard(proto: "paid_at"),
    12: .standard(proto: "payment_preimage"),
    13: .standard(proto: "local_offer_id"),
    15: .standard(proto: "invreq_payer_note"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._payIndex) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountReceivedMsat) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._paidAt) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._localOfferID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._invreqPayerNote) }()
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.status != .paid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 8)
    }
    try { if let v = self._payIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountReceivedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._paidAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._localOfferID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._invreqPayerNote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CreateinvoiceResponse, rhs: Cln_CreateinvoiceResponse) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.status != rhs.status {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._payIndex != rhs._payIndex {return false}
    if lhs._amountReceivedMsat != rhs._amountReceivedMsat {return false}
    if lhs._paidAt != rhs._paidAt {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs._localOfferID != rhs._localOfferID {return false}
    if lhs._invreqPayerNote != rhs._invreqPayerNote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CreateinvoiceResponse.CreateinvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAID"),
    1: .same(proto: "EXPIRED"),
    2: .same(proto: "UNPAID"),
  ]
}

extension Cln_DatastoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatastoreRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "key"),
    6: .same(proto: "string"),
    2: .same(proto: "hex"),
    3: .same(proto: "mode"),
    4: .same(proto: "generation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self._hex) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._generation) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hex {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._generation {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 5)
    }
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DatastoreRequest, rhs: Cln_DatastoreRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._string != rhs._string {return false}
    if lhs._hex != rhs._hex {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._generation != rhs._generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DatastoreRequest.DatastoreMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUST_CREATE"),
    1: .same(proto: "MUST_REPLACE"),
    2: .same(proto: "CREATE_OR_REPLACE"),
    3: .same(proto: "MUST_APPEND"),
    4: .same(proto: "CREATE_OR_APPEND"),
  ]
}

extension Cln_DatastoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatastoreResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "key"),
    2: .same(proto: "generation"),
    3: .same(proto: "hex"),
    4: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._generation) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._hex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._string) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._generation {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hex {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DatastoreResponse, rhs: Cln_DatastoreResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._generation != rhs._generation {return false}
    if lhs._hex != rhs._hex {return false}
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CreateonionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateonionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hops"),
    2: .same(proto: "assocdata"),
    3: .standard(proto: "session_key"),
    4: .standard(proto: "onion_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hops) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.assocdata) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._sessionKey) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._onionSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hops, fieldNumber: 1)
    }
    if !self.assocdata.isEmpty {
      try visitor.visitSingularBytesField(value: self.assocdata, fieldNumber: 2)
    }
    try { if let v = self._sessionKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._onionSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CreateonionRequest, rhs: Cln_CreateonionRequest) -> Bool {
    if lhs.hops != rhs.hops {return false}
    if lhs.assocdata != rhs.assocdata {return false}
    if lhs._sessionKey != rhs._sessionKey {return false}
    if lhs._onionSize != rhs._onionSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CreateonionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateonionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "onion"),
    2: .standard(proto: "shared_secrets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.onion) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.sharedSecrets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.onion.isEmpty {
      try visitor.visitSingularBytesField(value: self.onion, fieldNumber: 1)
    }
    if !self.sharedSecrets.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.sharedSecrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CreateonionResponse, rhs: Cln_CreateonionResponse) -> Bool {
    if lhs.onion != rhs.onion {return false}
    if lhs.sharedSecrets != rhs.sharedSecrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_CreateonionHops: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateonionHops"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_CreateonionHops, rhs: Cln_CreateonionHops) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DeldatastoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeldatastoreRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "key"),
    2: .same(proto: "generation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._generation) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._generation {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DeldatastoreRequest, rhs: Cln_DeldatastoreRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._generation != rhs._generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DeldatastoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeldatastoreResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "key"),
    2: .same(proto: "generation"),
    3: .same(proto: "hex"),
    4: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._generation) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._hex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._string) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._generation {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hex {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DeldatastoreResponse, rhs: Cln_DeldatastoreResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._generation != rhs._generation {return false}
    if lhs._hex != rhs._hex {return false}
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DelexpiredinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelexpiredinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxexpirytime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._maxexpirytime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxexpirytime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DelexpiredinvoiceRequest, rhs: Cln_DelexpiredinvoiceRequest) -> Bool {
    if lhs._maxexpirytime != rhs._maxexpirytime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DelexpiredinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelexpiredinvoiceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DelexpiredinvoiceResponse, rhs: Cln_DelexpiredinvoiceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DelinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "status"),
    3: .same(proto: "desconly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._desconly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.status != .paid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try { if let v = self._desconly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DelinvoiceRequest, rhs: Cln_DelinvoiceRequest) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.status != rhs.status {return false}
    if lhs._desconly != rhs._desconly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DelinvoiceRequest.DelinvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAID"),
    1: .same(proto: "EXPIRED"),
    2: .same(proto: "UNPAID"),
  ]
}

extension Cln_DelinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelinvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "bolt11"),
    3: .same(proto: "bolt12"),
    4: .standard(proto: "amount_msat"),
    5: .same(proto: "description"),
    6: .standard(proto: "payment_hash"),
    12: .standard(proto: "created_index"),
    13: .standard(proto: "updated_index"),
    7: .same(proto: "status"),
    8: .standard(proto: "expires_at"),
    9: .standard(proto: "local_offer_id"),
    11: .standard(proto: "invreq_payer_note"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._localOfferID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._invreqPayerNote) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._updatedIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 6)
    }
    if self.status != .paid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 8)
    }
    try { if let v = self._localOfferID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._invreqPayerNote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._updatedIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DelinvoiceResponse, rhs: Cln_DelinvoiceResponse) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._updatedIndex != rhs._updatedIndex {return false}
    if lhs.status != rhs.status {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._localOfferID != rhs._localOfferID {return false}
    if lhs._invreqPayerNote != rhs._invreqPayerNote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DelinvoiceResponse.DelinvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAID"),
    1: .same(proto: "EXPIRED"),
    2: .same(proto: "UNPAID"),
  ]
}

extension Cln_InvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .standard(proto: "amount_msat"),
    2: .same(proto: "description"),
    3: .same(proto: "label"),
    7: .same(proto: "expiry"),
    4: .same(proto: "fallbacks"),
    5: .same(proto: "preimage"),
    6: .same(proto: "cltv"),
    9: .same(proto: "deschashonly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.fallbacks) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._preimage) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._cltv) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._expiry) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._deschashonly) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    if !self.fallbacks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fallbacks, fieldNumber: 4)
    }
    try { if let v = self._preimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cltv {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._expiry {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deschashonly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_InvoiceRequest, rhs: Cln_InvoiceRequest) -> Bool {
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.label != rhs.label {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.fallbacks != rhs.fallbacks {return false}
    if lhs._preimage != rhs._preimage {return false}
    if lhs._cltv != rhs._cltv {return false}
    if lhs._deschashonly != rhs._deschashonly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_InvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .standard(proto: "payment_hash"),
    3: .standard(proto: "payment_secret"),
    4: .standard(proto: "expires_at"),
    10: .standard(proto: "created_index"),
    5: .standard(proto: "warning_capacity"),
    6: .standard(proto: "warning_offline"),
    7: .standard(proto: "warning_deadends"),
    8: .standard(proto: "warning_private_unused"),
    9: .standard(proto: "warning_mpp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentSecret) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._warningCapacity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._warningOffline) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._warningDeadends) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._warningPrivateUnused) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._warningMpp) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 2)
    }
    if !self.paymentSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentSecret, fieldNumber: 3)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 4)
    }
    try { if let v = self._warningCapacity {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._warningOffline {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._warningDeadends {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._warningPrivateUnused {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._warningMpp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_InvoiceResponse, rhs: Cln_InvoiceResponse) -> Bool {
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.paymentSecret != rhs.paymentSecret {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._warningCapacity != rhs._warningCapacity {return false}
    if lhs._warningOffline != rhs._warningOffline {return false}
    if lhs._warningDeadends != rhs._warningDeadends {return false}
    if lhs._warningPrivateUnused != rhs._warningPrivateUnused {return false}
    if lhs._warningMpp != rhs._warningMpp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListdatastoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListdatastoreRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListdatastoreRequest, rhs: Cln_ListdatastoreRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListdatastoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListdatastoreResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datastore"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.datastore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datastore.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datastore, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListdatastoreResponse, rhs: Cln_ListdatastoreResponse) -> Bool {
    if lhs.datastore != rhs.datastore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListdatastoreDatastore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListdatastoreDatastore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "generation"),
    3: .same(proto: "hex"),
    4: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._generation) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._hex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitRepeatedStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._generation {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hex {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListdatastoreDatastore, rhs: Cln_ListdatastoreDatastore) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._generation != rhs._generation {return false}
    if lhs._hex != rhs._hex {return false}
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListinvoicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListinvoicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "invstring"),
    3: .standard(proto: "payment_hash"),
    4: .standard(proto: "offer_id"),
    5: .same(proto: "index"),
    6: .same(proto: "start"),
    7: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._invstring) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._paymentHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._offerID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._index) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._start) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._invstring {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._paymentHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._offerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._start {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListinvoicesRequest, rhs: Cln_ListinvoicesRequest) -> Bool {
    if lhs._label != rhs._label {return false}
    if lhs._invstring != rhs._invstring {return false}
    if lhs._paymentHash != rhs._paymentHash {return false}
    if lhs._offerID != rhs._offerID {return false}
    if lhs._index != rhs._index {return false}
    if lhs._start != rhs._start {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListinvoicesRequest.ListinvoicesIndex: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED"),
    1: .same(proto: "UPDATED"),
  ]
}

extension Cln_ListinvoicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListinvoicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invoices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invoices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListinvoicesResponse, rhs: Cln_ListinvoicesResponse) -> Bool {
    if lhs.invoices != rhs.invoices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListinvoicesInvoices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListinvoicesInvoices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "description"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "expires_at"),
    6: .standard(proto: "amount_msat"),
    7: .same(proto: "bolt11"),
    8: .same(proto: "bolt12"),
    9: .standard(proto: "local_offer_id"),
    15: .standard(proto: "invreq_payer_note"),
    16: .standard(proto: "created_index"),
    17: .standard(proto: "updated_index"),
    11: .standard(proto: "pay_index"),
    12: .standard(proto: "amount_received_msat"),
    13: .standard(proto: "paid_at"),
    14: .standard(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._localOfferID) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._payIndex) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._amountReceivedMsat) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._paidAt) }()
      case 14: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._invreqPayerNote) }()
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      case 17: try { try decoder.decodeSingularUInt64Field(value: &self._updatedIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .unpaid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 5)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._localOfferID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._payIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._amountReceivedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._paidAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._invreqPayerNote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._updatedIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListinvoicesInvoices, rhs: Cln_ListinvoicesInvoices) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._localOfferID != rhs._localOfferID {return false}
    if lhs._invreqPayerNote != rhs._invreqPayerNote {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._updatedIndex != rhs._updatedIndex {return false}
    if lhs._payIndex != rhs._payIndex {return false}
    if lhs._amountReceivedMsat != rhs._amountReceivedMsat {return false}
    if lhs._paidAt != rhs._paidAt {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListinvoicesInvoices.ListinvoicesInvoicesStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNPAID"),
    1: .same(proto: "PAID"),
    2: .same(proto: "EXPIRED"),
  ]
}

extension Cln_SendonionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendonionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "onion"),
    2: .standard(proto: "first_hop"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "label"),
    5: .standard(proto: "shared_secrets"),
    6: .same(proto: "partid"),
    7: .same(proto: "bolt11"),
    12: .standard(proto: "amount_msat"),
    9: .same(proto: "destination"),
    13: .same(proto: "localinvreqid"),
    11: .same(proto: "groupid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.onion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._firstHop) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.sharedSecrets) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._partid) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._groupid) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._localinvreqid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.onion.isEmpty {
      try visitor.visitSingularBytesField(value: self.onion, fieldNumber: 1)
    }
    try { if let v = self._firstHop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.sharedSecrets.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.sharedSecrets, fieldNumber: 5)
    }
    try { if let v = self._partid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._groupid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._localinvreqid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendonionRequest, rhs: Cln_SendonionRequest) -> Bool {
    if lhs.onion != rhs.onion {return false}
    if lhs._firstHop != rhs._firstHop {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._label != rhs._label {return false}
    if lhs.sharedSecrets != rhs.sharedSecrets {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs._localinvreqid != rhs._localinvreqid {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendonionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendonionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "payment_hash"),
    3: .same(proto: "status"),
    4: .standard(proto: "amount_msat"),
    5: .same(proto: "destination"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "amount_sent_msat"),
    8: .same(proto: "label"),
    9: .same(proto: "bolt11"),
    10: .same(proto: "bolt12"),
    13: .same(proto: "partid"),
    11: .standard(proto: "payment_preimage"),
    12: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._partid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 2)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 6)
    }
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._partid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendonionResponse, rhs: Cln_SendonionResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendonionResponse.SendonionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETE"),
  ]
}

extension Cln_SendonionFirst_hop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendonionFirst_hop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "amount_msat"),
    3: .same(proto: "delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.delay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.delay != 0 {
      try visitor.visitSingularUInt32Field(value: self.delay, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendonionFirst_hop, rhs: Cln_SendonionFirst_hop) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListsendpaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListsendpaysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .standard(proto: "payment_hash"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._paymentHash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paymentHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListsendpaysRequest, rhs: Cln_ListsendpaysRequest) -> Bool {
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._paymentHash != rhs._paymentHash {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListsendpaysRequest.ListsendpaysStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETE"),
    2: .same(proto: "FAILED"),
  ]
}

extension Cln_ListsendpaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListsendpaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListsendpaysResponse, rhs: Cln_ListsendpaysResponse) -> Bool {
    if lhs.payments != rhs.payments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListsendpaysPayments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListsendpaysPayments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groupid"),
    15: .same(proto: "partid"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "amount_msat"),
    6: .same(proto: "destination"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "amount_sent_msat"),
    9: .same(proto: "label"),
    10: .same(proto: "bolt11"),
    14: .same(proto: "description"),
    11: .same(proto: "bolt12"),
    12: .standard(proto: "payment_preimage"),
    13: .same(proto: "erroronion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupid) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._erroronion) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self._partid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.groupid != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupid, fieldNumber: 2)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 7)
    }
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._erroronion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._partid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListsendpaysPayments, rhs: Cln_ListsendpaysPayments) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.groupid != rhs.groupid {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs._erroronion != rhs._erroronion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListsendpaysPayments.ListsendpaysPaymentsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "COMPLETE"),
  ]
}

extension Cln_ListtransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListtransactionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListtransactionsRequest, rhs: Cln_ListtransactionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListtransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListtransactionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListtransactionsResponse, rhs: Cln_ListtransactionsResponse) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListtransactionsTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListtransactionsTransactions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "rawtx"),
    3: .same(proto: "blockheight"),
    4: .same(proto: "txindex"),
    7: .same(proto: "locktime"),
    8: .same(proto: "version"),
    9: .same(proto: "inputs"),
    10: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawtx) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.blockheight) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.txindex) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.locktime) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.rawtx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawtx, fieldNumber: 2)
    }
    if self.blockheight != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockheight, fieldNumber: 3)
    }
    if self.txindex != 0 {
      try visitor.visitSingularUInt32Field(value: self.txindex, fieldNumber: 4)
    }
    if self.locktime != 0 {
      try visitor.visitSingularUInt32Field(value: self.locktime, fieldNumber: 7)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 8)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 9)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListtransactionsTransactions, rhs: Cln_ListtransactionsTransactions) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.rawtx != rhs.rawtx {return false}
    if lhs.blockheight != rhs.blockheight {return false}
    if lhs.txindex != rhs.txindex {return false}
    if lhs.locktime != rhs.locktime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListtransactionsTransactionsInputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListtransactionsTransactionsInputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "index"),
    3: .same(proto: "sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListtransactionsTransactionsInputs, rhs: Cln_ListtransactionsTransactionsInputs) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.index != rhs.index {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListtransactionsTransactionsOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListtransactionsTransactionsOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    6: .standard(proto: "amount_msat"),
    3: .same(proto: "scriptPubKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.scriptPubKey) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.scriptPubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.scriptPubKey, fieldNumber: 3)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListtransactionsTransactionsOutputs, rhs: Cln_ListtransactionsTransactionsOutputs) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.scriptPubKey != rhs.scriptPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    13: .standard(proto: "amount_msat"),
    3: .same(proto: "label"),
    8: .same(proto: "riskfactor"),
    4: .same(proto: "maxfeepercent"),
    5: .standard(proto: "retry_for"),
    6: .same(proto: "maxdelay"),
    7: .same(proto: "exemptfee"),
    14: .same(proto: "localinvreqid"),
    10: .same(proto: "exclude"),
    11: .same(proto: "maxfee"),
    12: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._maxfeepercent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._retryFor) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._maxdelay) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._exemptfee) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self._riskfactor) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.exclude) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._maxfee) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 14: try { try decoder.decodeSingularBytesField(value: &self._localinvreqid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 1)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxfeepercent {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._retryFor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._maxdelay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._exemptfee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._riskfactor {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
    } }()
    if !self.exclude.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclude, fieldNumber: 10)
    }
    try { if let v = self._maxfee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._localinvreqid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PayRequest, rhs: Cln_PayRequest) -> Bool {
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._riskfactor != rhs._riskfactor {return false}
    if lhs._maxfeepercent != rhs._maxfeepercent {return false}
    if lhs._retryFor != rhs._retryFor {return false}
    if lhs._maxdelay != rhs._maxdelay {return false}
    if lhs._exemptfee != rhs._exemptfee {return false}
    if lhs._localinvreqid != rhs._localinvreqid {return false}
    if lhs.exclude != rhs.exclude {return false}
    if lhs._maxfee != rhs._maxfee {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_preimage"),
    2: .same(proto: "destination"),
    3: .standard(proto: "payment_hash"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "parts"),
    6: .standard(proto: "amount_msat"),
    7: .standard(proto: "amount_sent_msat"),
    8: .standard(proto: "warning_partial_completion"),
    9: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentPreimage) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.parts) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._warningPartialCompletion) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentPreimage, fieldNumber: 1)
    }
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularDoubleField(value: self.createdAt, fieldNumber: 4)
    }
    if self.parts != 0 {
      try visitor.visitSingularUInt32Field(value: self.parts, fieldNumber: 5)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._warningPartialCompletion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if self.status != .complete {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PayResponse, rhs: Cln_PayResponse) -> Bool {
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._warningPartialCompletion != rhs._warningPartialCompletion {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PayResponse.PayStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPLETE"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "FAILED"),
  ]
}

extension Cln_ListnodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListnodesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListnodesRequest, rhs: Cln_ListnodesRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListnodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListnodesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListnodesResponse, rhs: Cln_ListnodesResponse) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListnodesNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListnodesNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeid"),
    2: .standard(proto: "last_timestamp"),
    3: .same(proto: "alias"),
    4: .same(proto: "color"),
    5: .same(proto: "features"),
    6: .same(proto: "addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._lastTimestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._alias) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._color) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._features) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeid.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeid, fieldNumber: 1)
    }
    try { if let v = self._lastTimestamp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._alias {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._features {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListnodesNodes, rhs: Cln_ListnodesNodes) -> Bool {
    if lhs.nodeid != rhs.nodeid {return false}
    if lhs._lastTimestamp != rhs._lastTimestamp {return false}
    if lhs._alias != rhs._alias {return false}
    if lhs._color != rhs._color {return false}
    if lhs._features != rhs._features {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListnodesNodesAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListnodesNodesAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "port"),
    3: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .dns {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListnodesNodesAddresses, rhs: Cln_ListnodesNodesAddresses) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.port != rhs.port {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListnodesNodesAddresses.ListnodesNodesAddressesType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DNS"),
    1: .same(proto: "IPV4"),
    2: .same(proto: "IPV6"),
    3: .same(proto: "TORV2"),
    4: .same(proto: "TORV3"),
  ]
}

extension Cln_WaitanyinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitanyinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lastpay_index"),
    2: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._lastpayIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastpayIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitanyinvoiceRequest, rhs: Cln_WaitanyinvoiceRequest) -> Bool {
    if lhs._lastpayIndex != rhs._lastpayIndex {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitanyinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitanyinvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "description"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "expires_at"),
    6: .standard(proto: "amount_msat"),
    7: .same(proto: "bolt11"),
    8: .same(proto: "bolt12"),
    13: .standard(proto: "created_index"),
    14: .standard(proto: "updated_index"),
    9: .standard(proto: "pay_index"),
    10: .standard(proto: "amount_received_msat"),
    11: .standard(proto: "paid_at"),
    12: .standard(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._payIndex) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountReceivedMsat) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._paidAt) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self._updatedIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .paid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 5)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._payIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountReceivedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._paidAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._updatedIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitanyinvoiceResponse, rhs: Cln_WaitanyinvoiceResponse) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._updatedIndex != rhs._updatedIndex {return false}
    if lhs._payIndex != rhs._payIndex {return false}
    if lhs._amountReceivedMsat != rhs._amountReceivedMsat {return false}
    if lhs._paidAt != rhs._paidAt {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitanyinvoiceResponse.WaitanyinvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAID"),
    1: .same(proto: "EXPIRED"),
  ]
}

extension Cln_WaitinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitinvoiceRequest, rhs: Cln_WaitinvoiceRequest) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitinvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "description"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "expires_at"),
    6: .standard(proto: "amount_msat"),
    7: .same(proto: "bolt11"),
    8: .same(proto: "bolt12"),
    13: .standard(proto: "created_index"),
    14: .standard(proto: "updated_index"),
    9: .standard(proto: "pay_index"),
    10: .standard(proto: "amount_received_msat"),
    11: .standard(proto: "paid_at"),
    12: .standard(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._payIndex) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountReceivedMsat) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._paidAt) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._createdIndex) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self._updatedIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .paid {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 5)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._payIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountReceivedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._paidAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._createdIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._updatedIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitinvoiceResponse, rhs: Cln_WaitinvoiceResponse) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._createdIndex != rhs._createdIndex {return false}
    if lhs._updatedIndex != rhs._updatedIndex {return false}
    if lhs._payIndex != rhs._payIndex {return false}
    if lhs._amountReceivedMsat != rhs._amountReceivedMsat {return false}
    if lhs._paidAt != rhs._paidAt {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitinvoiceResponse.WaitinvoiceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAID"),
    1: .same(proto: "EXPIRED"),
  ]
}

extension Cln_WaitsendpayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitsendpayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    3: .same(proto: "timeout"),
    2: .same(proto: "partid"),
    4: .same(proto: "groupid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._partid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeout) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._groupid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    try { if let v = self._partid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitsendpayRequest, rhs: Cln_WaitsendpayRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitsendpayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WaitsendpayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groupid"),
    3: .standard(proto: "payment_hash"),
    4: .same(proto: "status"),
    5: .standard(proto: "amount_msat"),
    6: .same(proto: "destination"),
    7: .standard(proto: "created_at"),
    14: .standard(proto: "completed_at"),
    8: .standard(proto: "amount_sent_msat"),
    9: .same(proto: "label"),
    10: .same(proto: "partid"),
    11: .same(proto: "bolt11"),
    12: .same(proto: "bolt12"),
    13: .standard(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._groupid) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._partid) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._paymentPreimage) }()
      case 14: try { try decoder.decodeSingularDoubleField(value: &self._completedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._groupid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.status != .complete {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 7)
    }
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._partid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._paymentPreimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._completedAt {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WaitsendpayResponse, rhs: Cln_WaitsendpayResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._partid != rhs._partid {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._paymentPreimage != rhs._paymentPreimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WaitsendpayResponse.WaitsendpayStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPLETE"),
  ]
}

extension Cln_NewaddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewaddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresstype"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._addresstype) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addresstype {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_NewaddrRequest, rhs: Cln_NewaddrRequest) -> Bool {
    if lhs._addresstype != rhs._addresstype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_NewaddrRequest.NewaddrAddresstype: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BECH32"),
    2: .same(proto: "ALL"),
    3: .same(proto: "P2TR"),
  ]
}

extension Cln_NewaddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewaddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "p2tr"),
    1: .same(proto: "bech32"),
    2: .standard(proto: "p2sh_segwit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bech32) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._p2ShSegwit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._p2Tr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bech32 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._p2ShSegwit {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._p2Tr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_NewaddrResponse, rhs: Cln_NewaddrResponse) -> Bool {
    if lhs._p2Tr != rhs._p2Tr {return false}
    if lhs._bech32 != rhs._bech32 {return false}
    if lhs._p2ShSegwit != rhs._p2ShSegwit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "satoshi"),
    5: .same(proto: "feerate"),
    3: .same(proto: "minconf"),
    4: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._satoshi) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._minconf) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    try { if let v = self._satoshi {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minconf {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 4)
    }
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WithdrawRequest, rhs: Cln_WithdrawRequest) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs._satoshi != rhs._satoshi {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_WithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "txid"),
    3: .same(proto: "psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_WithdrawResponse, rhs: Cln_WithdrawResponse) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.psbt != rhs.psbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_KeysendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeysendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    10: .standard(proto: "amount_msat"),
    3: .same(proto: "label"),
    4: .same(proto: "maxfeepercent"),
    5: .standard(proto: "retry_for"),
    6: .same(proto: "maxdelay"),
    7: .same(proto: "exemptfee"),
    8: .same(proto: "routehints"),
    9: .same(proto: "extratlvs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._maxfeepercent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._retryFor) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._maxdelay) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._exemptfee) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._routehints) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._extratlvs) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destination.isEmpty {
      try visitor.visitSingularBytesField(value: self.destination, fieldNumber: 1)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxfeepercent {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._retryFor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._maxdelay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._exemptfee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._routehints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._extratlvs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_KeysendRequest, rhs: Cln_KeysendRequest) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._label != rhs._label {return false}
    if lhs._maxfeepercent != rhs._maxfeepercent {return false}
    if lhs._retryFor != rhs._retryFor {return false}
    if lhs._maxdelay != rhs._maxdelay {return false}
    if lhs._exemptfee != rhs._exemptfee {return false}
    if lhs._routehints != rhs._routehints {return false}
    if lhs._extratlvs != rhs._extratlvs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_KeysendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeysendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_preimage"),
    2: .same(proto: "destination"),
    3: .standard(proto: "payment_hash"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "parts"),
    6: .standard(proto: "amount_msat"),
    7: .standard(proto: "amount_sent_msat"),
    8: .standard(proto: "warning_partial_completion"),
    9: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentPreimage) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.parts) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._warningPartialCompletion) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentPreimage, fieldNumber: 1)
    }
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularDoubleField(value: self.createdAt, fieldNumber: 4)
    }
    if self.parts != 0 {
      try visitor.visitSingularUInt32Field(value: self.parts, fieldNumber: 5)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._warningPartialCompletion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if self.status != .complete {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_KeysendResponse, rhs: Cln_KeysendResponse) -> Bool {
    if lhs.paymentPreimage != rhs.paymentPreimage {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._warningPartialCompletion != rhs._warningPartialCompletion {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_KeysendResponse.KeysendStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPLETE"),
  ]
}

extension Cln_FundpsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundpsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "satoshi"),
    2: .same(proto: "feerate"),
    3: .same(proto: "startweight"),
    4: .same(proto: "minconf"),
    5: .same(proto: "reserve"),
    6: .same(proto: "locktime"),
    7: .standard(proto: "min_witness_weight"),
    8: .standard(proto: "excess_as_change"),
    9: .same(proto: "nonwrapped"),
    10: .standard(proto: "opening_anchor_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._satoshi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.startweight) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._minconf) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._reserve) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._locktime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._minWitnessWeight) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._excessAsChange) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._nonwrapped) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._openingAnchorChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._satoshi {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.startweight != 0 {
      try visitor.visitSingularUInt32Field(value: self.startweight, fieldNumber: 3)
    }
    try { if let v = self._minconf {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reserve {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._locktime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._minWitnessWeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._excessAsChange {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._nonwrapped {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._openingAnchorChannel {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FundpsbtRequest, rhs: Cln_FundpsbtRequest) -> Bool {
    if lhs._satoshi != rhs._satoshi {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs.startweight != rhs.startweight {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs._reserve != rhs._reserve {return false}
    if lhs._locktime != rhs._locktime {return false}
    if lhs._minWitnessWeight != rhs._minWitnessWeight {return false}
    if lhs._excessAsChange != rhs._excessAsChange {return false}
    if lhs._nonwrapped != rhs._nonwrapped {return false}
    if lhs._openingAnchorChannel != rhs._openingAnchorChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FundpsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundpsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .standard(proto: "feerate_per_kw"),
    3: .standard(proto: "estimated_final_weight"),
    4: .standard(proto: "excess_msat"),
    5: .standard(proto: "change_outnum"),
    6: .same(proto: "reservations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.feeratePerKw) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.estimatedFinalWeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._excessMsat) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._changeOutnum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reservations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    if self.feeratePerKw != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeratePerKw, fieldNumber: 2)
    }
    if self.estimatedFinalWeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.estimatedFinalWeight, fieldNumber: 3)
    }
    try { if let v = self._excessMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._changeOutnum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.reservations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reservations, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FundpsbtResponse, rhs: Cln_FundpsbtResponse) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.feeratePerKw != rhs.feeratePerKw {return false}
    if lhs.estimatedFinalWeight != rhs.estimatedFinalWeight {return false}
    if lhs._excessMsat != rhs._excessMsat {return false}
    if lhs._changeOutnum != rhs._changeOutnum {return false}
    if lhs.reservations != rhs.reservations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FundpsbtReservations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundpsbtReservations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "vout"),
    3: .standard(proto: "was_reserved"),
    4: .same(proto: "reserved"),
    5: .standard(proto: "reserved_to_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vout) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wasReserved) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reserved) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.reservedToBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularUInt32Field(value: self.vout, fieldNumber: 2)
    }
    if self.wasReserved != false {
      try visitor.visitSingularBoolField(value: self.wasReserved, fieldNumber: 3)
    }
    if self.reserved != false {
      try visitor.visitSingularBoolField(value: self.reserved, fieldNumber: 4)
    }
    if self.reservedToBlock != 0 {
      try visitor.visitSingularUInt32Field(value: self.reservedToBlock, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FundpsbtReservations, rhs: Cln_FundpsbtReservations) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.wasReserved != rhs.wasReserved {return false}
    if lhs.reserved != rhs.reserved {return false}
    if lhs.reservedToBlock != rhs.reservedToBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendpsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendpsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._reserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    try { if let v = self._reserve {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendpsbtRequest, rhs: Cln_SendpsbtRequest) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs._reserve != rhs._reserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendpsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendpsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendpsbtResponse, rhs: Cln_SendpsbtResponse) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SignpsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignpsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "signonly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.signonly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    if !self.signonly.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.signonly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SignpsbtRequest, rhs: Cln_SignpsbtRequest) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.signonly != rhs.signonly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SignpsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignpsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signedPsbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularStringField(value: self.signedPsbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SignpsbtResponse, rhs: Cln_SignpsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_UtxopsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxopsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "satoshi"),
    2: .same(proto: "feerate"),
    3: .same(proto: "startweight"),
    4: .same(proto: "utxos"),
    5: .same(proto: "reserve"),
    8: .same(proto: "reservedok"),
    6: .same(proto: "locktime"),
    7: .standard(proto: "min_witness_weight"),
    9: .standard(proto: "excess_as_change"),
    10: .standard(proto: "opening_anchor_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._satoshi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.startweight) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._reserve) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._locktime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._minWitnessWeight) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._reservedok) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._excessAsChange) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._openingAnchorChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._satoshi {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.startweight != 0 {
      try visitor.visitSingularUInt32Field(value: self.startweight, fieldNumber: 3)
    }
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 4)
    }
    try { if let v = self._reserve {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._locktime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._minWitnessWeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._reservedok {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._excessAsChange {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._openingAnchorChannel {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_UtxopsbtRequest, rhs: Cln_UtxopsbtRequest) -> Bool {
    if lhs._satoshi != rhs._satoshi {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs.startweight != rhs.startweight {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs._reserve != rhs._reserve {return false}
    if lhs._reservedok != rhs._reservedok {return false}
    if lhs._locktime != rhs._locktime {return false}
    if lhs._minWitnessWeight != rhs._minWitnessWeight {return false}
    if lhs._excessAsChange != rhs._excessAsChange {return false}
    if lhs._openingAnchorChannel != rhs._openingAnchorChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_UtxopsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxopsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .standard(proto: "feerate_per_kw"),
    3: .standard(proto: "estimated_final_weight"),
    4: .standard(proto: "excess_msat"),
    5: .standard(proto: "change_outnum"),
    6: .same(proto: "reservations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.feeratePerKw) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.estimatedFinalWeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._excessMsat) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._changeOutnum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reservations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    if self.feeratePerKw != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeratePerKw, fieldNumber: 2)
    }
    if self.estimatedFinalWeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.estimatedFinalWeight, fieldNumber: 3)
    }
    try { if let v = self._excessMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._changeOutnum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.reservations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reservations, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_UtxopsbtResponse, rhs: Cln_UtxopsbtResponse) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.feeratePerKw != rhs.feeratePerKw {return false}
    if lhs.estimatedFinalWeight != rhs.estimatedFinalWeight {return false}
    if lhs._excessMsat != rhs._excessMsat {return false}
    if lhs._changeOutnum != rhs._changeOutnum {return false}
    if lhs.reservations != rhs.reservations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_UtxopsbtReservations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxopsbtReservations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "vout"),
    3: .standard(proto: "was_reserved"),
    4: .same(proto: "reserved"),
    5: .standard(proto: "reserved_to_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vout) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wasReserved) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reserved) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.reservedToBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularUInt32Field(value: self.vout, fieldNumber: 2)
    }
    if self.wasReserved != false {
      try visitor.visitSingularBoolField(value: self.wasReserved, fieldNumber: 3)
    }
    if self.reserved != false {
      try visitor.visitSingularBoolField(value: self.reserved, fieldNumber: 4)
    }
    if self.reservedToBlock != 0 {
      try visitor.visitSingularUInt32Field(value: self.reservedToBlock, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_UtxopsbtReservations, rhs: Cln_UtxopsbtReservations) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.wasReserved != rhs.wasReserved {return false}
    if lhs.reserved != rhs.reserved {return false}
    if lhs.reservedToBlock != rhs.reservedToBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxdiscardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxdiscardRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxdiscardRequest, rhs: Cln_TxdiscardRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxdiscardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxdiscardResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unsigned_tx"),
    2: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unsignedTx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unsignedTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedTx, fieldNumber: 1)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxdiscardResponse, rhs: Cln_TxdiscardResponse) -> Bool {
    if lhs.unsignedTx != rhs.unsignedTx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxprepareRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxprepareRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "outputs"),
    2: .same(proto: "feerate"),
    3: .same(proto: "minconf"),
    4: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._minconf) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minconf {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 4)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxprepareRequest, rhs: Cln_TxprepareRequest) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxprepareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxprepareResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .standard(proto: "unsigned_tx"),
    3: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.unsignedTx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    if !self.unsignedTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedTx, fieldNumber: 2)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxprepareResponse, rhs: Cln_TxprepareResponse) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.unsignedTx != rhs.unsignedTx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxsendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxsendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxsendRequest, rhs: Cln_TxsendRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_TxsendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxsendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "tx"),
    3: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.psbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.psbt.isEmpty {
      try visitor.visitSingularStringField(value: self.psbt, fieldNumber: 1)
    }
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 2)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_TxsendResponse, rhs: Cln_TxsendResponse) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsRequest, rhs: Cln_ListpeerchannelsRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsResponse, rhs: Cln_ListpeerchannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "peer_connected"),
    3: .same(proto: "state"),
    4: .standard(proto: "scratch_txid"),
    54: .standard(proto: "ignore_fee_limits"),
    6: .same(proto: "feerate"),
    7: .same(proto: "owner"),
    8: .standard(proto: "short_channel_id"),
    9: .standard(proto: "channel_id"),
    10: .standard(proto: "funding_txid"),
    11: .standard(proto: "funding_outnum"),
    12: .standard(proto: "initial_feerate"),
    13: .standard(proto: "last_feerate"),
    14: .standard(proto: "next_feerate"),
    15: .standard(proto: "next_fee_step"),
    16: .same(proto: "inflight"),
    17: .standard(proto: "close_to"),
    18: .same(proto: "private"),
    19: .same(proto: "opener"),
    20: .same(proto: "closer"),
    22: .same(proto: "funding"),
    23: .standard(proto: "to_us_msat"),
    24: .standard(proto: "min_to_us_msat"),
    25: .standard(proto: "max_to_us_msat"),
    26: .standard(proto: "total_msat"),
    27: .standard(proto: "fee_base_msat"),
    28: .standard(proto: "fee_proportional_millionths"),
    29: .standard(proto: "dust_limit_msat"),
    30: .standard(proto: "max_total_htlc_in_msat"),
    31: .standard(proto: "their_reserve_msat"),
    32: .standard(proto: "our_reserve_msat"),
    33: .standard(proto: "spendable_msat"),
    34: .standard(proto: "receivable_msat"),
    35: .standard(proto: "minimum_htlc_in_msat"),
    36: .standard(proto: "minimum_htlc_out_msat"),
    37: .standard(proto: "maximum_htlc_out_msat"),
    38: .standard(proto: "their_to_self_delay"),
    39: .standard(proto: "our_to_self_delay"),
    40: .standard(proto: "max_accepted_htlcs"),
    41: .same(proto: "alias"),
    43: .same(proto: "status"),
    44: .standard(proto: "in_payments_offered"),
    45: .standard(proto: "in_offered_msat"),
    46: .standard(proto: "in_payments_fulfilled"),
    47: .standard(proto: "in_fulfilled_msat"),
    48: .standard(proto: "out_payments_offered"),
    49: .standard(proto: "out_offered_msat"),
    50: .standard(proto: "out_payments_fulfilled"),
    51: .standard(proto: "out_fulfilled_msat"),
    52: .same(proto: "htlcs"),
    53: .standard(proto: "close_to_addr"),
  ]

  fileprivate class _StorageClass {
    var _peerID: Data? = nil
    var _peerConnected: Bool? = nil
    var _state: Cln_ListpeerchannelsChannels.ListpeerchannelsChannelsState? = nil
    var _scratchTxid: Data? = nil
    var _ignoreFeeLimits: Bool? = nil
    var _feerate: Cln_ListpeerchannelsChannelsFeerate? = nil
    var _owner: String? = nil
    var _shortChannelID: String? = nil
    var _channelID: Data? = nil
    var _fundingTxid: Data? = nil
    var _fundingOutnum: UInt32? = nil
    var _initialFeerate: String? = nil
    var _lastFeerate: String? = nil
    var _nextFeerate: String? = nil
    var _nextFeeStep: UInt32? = nil
    var _inflight: [Cln_ListpeerchannelsChannelsInflight] = []
    var _closeTo: Data? = nil
    var _private: Bool? = nil
    var _opener: Cln_ChannelSide? = nil
    var _closer: Cln_ChannelSide? = nil
    var _funding: Cln_ListpeerchannelsChannelsFunding? = nil
    var _toUsMsat: Cln_Amount? = nil
    var _minToUsMsat: Cln_Amount? = nil
    var _maxToUsMsat: Cln_Amount? = nil
    var _totalMsat: Cln_Amount? = nil
    var _feeBaseMsat: Cln_Amount? = nil
    var _feeProportionalMillionths: UInt32? = nil
    var _dustLimitMsat: Cln_Amount? = nil
    var _maxTotalHtlcInMsat: Cln_Amount? = nil
    var _theirReserveMsat: Cln_Amount? = nil
    var _ourReserveMsat: Cln_Amount? = nil
    var _spendableMsat: Cln_Amount? = nil
    var _receivableMsat: Cln_Amount? = nil
    var _minimumHtlcInMsat: Cln_Amount? = nil
    var _minimumHtlcOutMsat: Cln_Amount? = nil
    var _maximumHtlcOutMsat: Cln_Amount? = nil
    var _theirToSelfDelay: UInt32? = nil
    var _ourToSelfDelay: UInt32? = nil
    var _maxAcceptedHtlcs: UInt32? = nil
    var _alias: Cln_ListpeerchannelsChannelsAlias? = nil
    var _status: [String] = []
    var _inPaymentsOffered: UInt64? = nil
    var _inOfferedMsat: Cln_Amount? = nil
    var _inPaymentsFulfilled: UInt64? = nil
    var _inFulfilledMsat: Cln_Amount? = nil
    var _outPaymentsOffered: UInt64? = nil
    var _outOfferedMsat: Cln_Amount? = nil
    var _outPaymentsFulfilled: UInt64? = nil
    var _outFulfilledMsat: Cln_Amount? = nil
    var _htlcs: [Cln_ListpeerchannelsChannelsHtlcs] = []
    var _closeToAddr: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _peerID = source._peerID
      _peerConnected = source._peerConnected
      _state = source._state
      _scratchTxid = source._scratchTxid
      _ignoreFeeLimits = source._ignoreFeeLimits
      _feerate = source._feerate
      _owner = source._owner
      _shortChannelID = source._shortChannelID
      _channelID = source._channelID
      _fundingTxid = source._fundingTxid
      _fundingOutnum = source._fundingOutnum
      _initialFeerate = source._initialFeerate
      _lastFeerate = source._lastFeerate
      _nextFeerate = source._nextFeerate
      _nextFeeStep = source._nextFeeStep
      _inflight = source._inflight
      _closeTo = source._closeTo
      _private = source._private
      _opener = source._opener
      _closer = source._closer
      _funding = source._funding
      _toUsMsat = source._toUsMsat
      _minToUsMsat = source._minToUsMsat
      _maxToUsMsat = source._maxToUsMsat
      _totalMsat = source._totalMsat
      _feeBaseMsat = source._feeBaseMsat
      _feeProportionalMillionths = source._feeProportionalMillionths
      _dustLimitMsat = source._dustLimitMsat
      _maxTotalHtlcInMsat = source._maxTotalHtlcInMsat
      _theirReserveMsat = source._theirReserveMsat
      _ourReserveMsat = source._ourReserveMsat
      _spendableMsat = source._spendableMsat
      _receivableMsat = source._receivableMsat
      _minimumHtlcInMsat = source._minimumHtlcInMsat
      _minimumHtlcOutMsat = source._minimumHtlcOutMsat
      _maximumHtlcOutMsat = source._maximumHtlcOutMsat
      _theirToSelfDelay = source._theirToSelfDelay
      _ourToSelfDelay = source._ourToSelfDelay
      _maxAcceptedHtlcs = source._maxAcceptedHtlcs
      _alias = source._alias
      _status = source._status
      _inPaymentsOffered = source._inPaymentsOffered
      _inOfferedMsat = source._inOfferedMsat
      _inPaymentsFulfilled = source._inPaymentsFulfilled
      _inFulfilledMsat = source._inFulfilledMsat
      _outPaymentsOffered = source._outPaymentsOffered
      _outOfferedMsat = source._outOfferedMsat
      _outPaymentsFulfilled = source._outPaymentsFulfilled
      _outFulfilledMsat = source._outFulfilledMsat
      _htlcs = source._htlcs
      _closeToAddr = source._closeToAddr
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._peerID) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._peerConnected) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._scratchTxid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._feerate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._shortChannelID) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._channelID) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._fundingTxid) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._fundingOutnum) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._initialFeerate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._lastFeerate) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._nextFeerate) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextFeeStep) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._inflight) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._closeTo) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._opener) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._closer) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._funding) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._toUsMsat) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._minToUsMsat) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._maxToUsMsat) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._totalMsat) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._feeBaseMsat) }()
        case 28: try { try decoder.decodeSingularUInt32Field(value: &_storage._feeProportionalMillionths) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._dustLimitMsat) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._maxTotalHtlcInMsat) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._theirReserveMsat) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._ourReserveMsat) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._spendableMsat) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._receivableMsat) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._minimumHtlcInMsat) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._minimumHtlcOutMsat) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._maximumHtlcOutMsat) }()
        case 38: try { try decoder.decodeSingularUInt32Field(value: &_storage._theirToSelfDelay) }()
        case 39: try { try decoder.decodeSingularUInt32Field(value: &_storage._ourToSelfDelay) }()
        case 40: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxAcceptedHtlcs) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._alias) }()
        case 43: try { try decoder.decodeRepeatedStringField(value: &_storage._status) }()
        case 44: try { try decoder.decodeSingularUInt64Field(value: &_storage._inPaymentsOffered) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._inOfferedMsat) }()
        case 46: try { try decoder.decodeSingularUInt64Field(value: &_storage._inPaymentsFulfilled) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._inFulfilledMsat) }()
        case 48: try { try decoder.decodeSingularUInt64Field(value: &_storage._outPaymentsOffered) }()
        case 49: try { try decoder.decodeSingularMessageField(value: &_storage._outOfferedMsat) }()
        case 50: try { try decoder.decodeSingularUInt64Field(value: &_storage._outPaymentsFulfilled) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._outFulfilledMsat) }()
        case 52: try { try decoder.decodeRepeatedMessageField(value: &_storage._htlcs) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._closeToAddr) }()
        case 54: try { try decoder.decodeSingularBoolField(value: &_storage._ignoreFeeLimits) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._peerID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._peerConnected {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._scratchTxid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._feerate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._shortChannelID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._channelID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._fundingTxid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._fundingOutnum {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._initialFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._nextFeerate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._nextFeeStep {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      } }()
      if !_storage._inflight.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inflight, fieldNumber: 16)
      }
      try { if let v = _storage._closeTo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._private {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._opener {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._closer {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._funding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._toUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._minToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._maxToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._totalMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._feeBaseMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._feeProportionalMillionths {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._dustLimitMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._maxTotalHtlcInMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._theirReserveMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._ourReserveMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._spendableMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._receivableMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._minimumHtlcInMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._minimumHtlcOutMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._maximumHtlcOutMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._theirToSelfDelay {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._ourToSelfDelay {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._maxAcceptedHtlcs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._alias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      if !_storage._status.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._status, fieldNumber: 43)
      }
      try { if let v = _storage._inPaymentsOffered {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._inOfferedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._inPaymentsFulfilled {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._inFulfilledMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._outPaymentsOffered {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._outOfferedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._outPaymentsFulfilled {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._outFulfilledMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      if !_storage._htlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._htlcs, fieldNumber: 52)
      }
      try { if let v = _storage._closeToAddr {
        try visitor.visitSingularStringField(value: v, fieldNumber: 53)
      } }()
      try { if let v = _storage._ignoreFeeLimits {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 54)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannels, rhs: Cln_ListpeerchannelsChannels) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._peerID != rhs_storage._peerID {return false}
        if _storage._peerConnected != rhs_storage._peerConnected {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._scratchTxid != rhs_storage._scratchTxid {return false}
        if _storage._ignoreFeeLimits != rhs_storage._ignoreFeeLimits {return false}
        if _storage._feerate != rhs_storage._feerate {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._shortChannelID != rhs_storage._shortChannelID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._fundingTxid != rhs_storage._fundingTxid {return false}
        if _storage._fundingOutnum != rhs_storage._fundingOutnum {return false}
        if _storage._initialFeerate != rhs_storage._initialFeerate {return false}
        if _storage._lastFeerate != rhs_storage._lastFeerate {return false}
        if _storage._nextFeerate != rhs_storage._nextFeerate {return false}
        if _storage._nextFeeStep != rhs_storage._nextFeeStep {return false}
        if _storage._inflight != rhs_storage._inflight {return false}
        if _storage._closeTo != rhs_storage._closeTo {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._opener != rhs_storage._opener {return false}
        if _storage._closer != rhs_storage._closer {return false}
        if _storage._funding != rhs_storage._funding {return false}
        if _storage._toUsMsat != rhs_storage._toUsMsat {return false}
        if _storage._minToUsMsat != rhs_storage._minToUsMsat {return false}
        if _storage._maxToUsMsat != rhs_storage._maxToUsMsat {return false}
        if _storage._totalMsat != rhs_storage._totalMsat {return false}
        if _storage._feeBaseMsat != rhs_storage._feeBaseMsat {return false}
        if _storage._feeProportionalMillionths != rhs_storage._feeProportionalMillionths {return false}
        if _storage._dustLimitMsat != rhs_storage._dustLimitMsat {return false}
        if _storage._maxTotalHtlcInMsat != rhs_storage._maxTotalHtlcInMsat {return false}
        if _storage._theirReserveMsat != rhs_storage._theirReserveMsat {return false}
        if _storage._ourReserveMsat != rhs_storage._ourReserveMsat {return false}
        if _storage._spendableMsat != rhs_storage._spendableMsat {return false}
        if _storage._receivableMsat != rhs_storage._receivableMsat {return false}
        if _storage._minimumHtlcInMsat != rhs_storage._minimumHtlcInMsat {return false}
        if _storage._minimumHtlcOutMsat != rhs_storage._minimumHtlcOutMsat {return false}
        if _storage._maximumHtlcOutMsat != rhs_storage._maximumHtlcOutMsat {return false}
        if _storage._theirToSelfDelay != rhs_storage._theirToSelfDelay {return false}
        if _storage._ourToSelfDelay != rhs_storage._ourToSelfDelay {return false}
        if _storage._maxAcceptedHtlcs != rhs_storage._maxAcceptedHtlcs {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._inPaymentsOffered != rhs_storage._inPaymentsOffered {return false}
        if _storage._inOfferedMsat != rhs_storage._inOfferedMsat {return false}
        if _storage._inPaymentsFulfilled != rhs_storage._inPaymentsFulfilled {return false}
        if _storage._inFulfilledMsat != rhs_storage._inFulfilledMsat {return false}
        if _storage._outPaymentsOffered != rhs_storage._outPaymentsOffered {return false}
        if _storage._outOfferedMsat != rhs_storage._outOfferedMsat {return false}
        if _storage._outPaymentsFulfilled != rhs_storage._outPaymentsFulfilled {return false}
        if _storage._outFulfilledMsat != rhs_storage._outFulfilledMsat {return false}
        if _storage._htlcs != rhs_storage._htlcs {return false}
        if _storage._closeToAddr != rhs_storage._closeToAddr {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannels.ListpeerchannelsChannelsState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPENINGD"),
    1: .same(proto: "CHANNELD_AWAITING_LOCKIN"),
    2: .same(proto: "CHANNELD_NORMAL"),
    3: .same(proto: "CHANNELD_SHUTTING_DOWN"),
    4: .same(proto: "CLOSINGD_SIGEXCHANGE"),
    5: .same(proto: "CLOSINGD_COMPLETE"),
    6: .same(proto: "AWAITING_UNILATERAL"),
    7: .same(proto: "FUNDING_SPEND_SEEN"),
    8: .same(proto: "ONCHAIN"),
    9: .same(proto: "DUALOPEND_OPEN_INIT"),
    10: .same(proto: "DUALOPEND_AWAITING_LOCKIN"),
    11: .same(proto: "CHANNELD_AWAITING_SPLICE"),
  ]
}

extension Cln_ListpeerchannelsChannelsFeerate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannelsFeerate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "perkw"),
    2: .same(proto: "perkb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._perkw) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._perkb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._perkw {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._perkb {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannelsFeerate, rhs: Cln_ListpeerchannelsChannelsFeerate) -> Bool {
    if lhs._perkw != rhs._perkw {return false}
    if lhs._perkb != rhs._perkb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannelsInflight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannelsInflight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funding_txid"),
    2: .standard(proto: "funding_outnum"),
    3: .same(proto: "feerate"),
    4: .standard(proto: "total_funding_msat"),
    7: .standard(proto: "splice_amount"),
    5: .standard(proto: "our_funding_msat"),
    6: .standard(proto: "scratch_txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._fundingTxid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._fundingOutnum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._feerate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalFundingMsat) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ourFundingMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._scratchTxid) }()
      case 7: try { try decoder.decodeSingularSInt64Field(value: &self._spliceAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fundingTxid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fundingOutnum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._totalFundingMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ourFundingMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scratchTxid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._spliceAmount {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannelsInflight, rhs: Cln_ListpeerchannelsChannelsInflight) -> Bool {
    if lhs._fundingTxid != rhs._fundingTxid {return false}
    if lhs._fundingOutnum != rhs._fundingOutnum {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._totalFundingMsat != rhs._totalFundingMsat {return false}
    if lhs._spliceAmount != rhs._spliceAmount {return false}
    if lhs._ourFundingMsat != rhs._ourFundingMsat {return false}
    if lhs._scratchTxid != rhs._scratchTxid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannelsFunding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannelsFunding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pushed_msat"),
    2: .standard(proto: "local_funds_msat"),
    3: .standard(proto: "remote_funds_msat"),
    4: .standard(proto: "fee_paid_msat"),
    5: .standard(proto: "fee_rcvd_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pushedMsat) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._localFundsMsat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._remoteFundsMsat) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._feePaidMsat) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feeRcvdMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushedMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._localFundsMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._remoteFundsMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._feePaidMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._feeRcvdMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannelsFunding, rhs: Cln_ListpeerchannelsChannelsFunding) -> Bool {
    if lhs._pushedMsat != rhs._pushedMsat {return false}
    if lhs._localFundsMsat != rhs._localFundsMsat {return false}
    if lhs._remoteFundsMsat != rhs._remoteFundsMsat {return false}
    if lhs._feePaidMsat != rhs._feePaidMsat {return false}
    if lhs._feeRcvdMsat != rhs._feeRcvdMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannelsAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannelsAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._local) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._remote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._local {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannelsAlias, rhs: Cln_ListpeerchannelsChannelsAlias) -> Bool {
    if lhs._local != rhs._local {return false}
    if lhs._remote != rhs._remote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannelsHtlcs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpeerchannelsChannelsHtlcs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "id"),
    3: .standard(proto: "amount_msat"),
    4: .same(proto: "expiry"),
    5: .standard(proto: "payment_hash"),
    6: .standard(proto: "local_trimmed"),
    7: .same(proto: "status"),
    8: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._expiry) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._paymentHash) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._localTrimmed) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._status) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expiry {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._paymentHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._localTrimmed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpeerchannelsChannelsHtlcs, rhs: Cln_ListpeerchannelsChannelsHtlcs) -> Bool {
    if lhs._direction != rhs._direction {return false}
    if lhs._id != rhs._id {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs._paymentHash != rhs._paymentHash {return false}
    if lhs._localTrimmed != rhs._localTrimmed {return false}
    if lhs._status != rhs._status {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpeerchannelsChannelsHtlcs.ListpeerchannelsChannelsHtlcsDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN"),
    1: .same(proto: "OUT"),
  ]
}

extension Cln_ListclosedchannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListclosedchannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListclosedchannelsRequest, rhs: Cln_ListclosedchannelsRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListclosedchannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListclosedchannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closedchannels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.closedchannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closedchannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closedchannels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListclosedchannelsResponse, rhs: Cln_ListclosedchannelsResponse) -> Bool {
    if lhs.closedchannels != rhs.closedchannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListclosedchannelsClosedchannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListclosedchannelsClosedchannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "short_channel_id"),
    4: .same(proto: "alias"),
    5: .same(proto: "opener"),
    6: .same(proto: "closer"),
    7: .same(proto: "private"),
    9: .standard(proto: "total_local_commitments"),
    10: .standard(proto: "total_remote_commitments"),
    11: .standard(proto: "total_htlcs_sent"),
    12: .standard(proto: "funding_txid"),
    13: .standard(proto: "funding_outnum"),
    14: .same(proto: "leased"),
    15: .standard(proto: "funding_fee_paid_msat"),
    16: .standard(proto: "funding_fee_rcvd_msat"),
    17: .standard(proto: "funding_pushed_msat"),
    18: .standard(proto: "total_msat"),
    19: .standard(proto: "final_to_us_msat"),
    20: .standard(proto: "min_to_us_msat"),
    21: .standard(proto: "max_to_us_msat"),
    22: .standard(proto: "last_commitment_txid"),
    23: .standard(proto: "last_commitment_fee_msat"),
    24: .standard(proto: "close_cause"),
  ]

  fileprivate class _StorageClass {
    var _peerID: Data? = nil
    var _channelID: Data = Data()
    var _shortChannelID: String? = nil
    var _alias: Cln_ListclosedchannelsClosedchannelsAlias? = nil
    var _opener: Cln_ChannelSide = .local
    var _closer: Cln_ChannelSide? = nil
    var _private: Bool = false
    var _totalLocalCommitments: UInt64 = 0
    var _totalRemoteCommitments: UInt64 = 0
    var _totalHtlcsSent: UInt64 = 0
    var _fundingTxid: Data = Data()
    var _fundingOutnum: UInt32 = 0
    var _leased: Bool = false
    var _fundingFeePaidMsat: Cln_Amount? = nil
    var _fundingFeeRcvdMsat: Cln_Amount? = nil
    var _fundingPushedMsat: Cln_Amount? = nil
    var _totalMsat: Cln_Amount? = nil
    var _finalToUsMsat: Cln_Amount? = nil
    var _minToUsMsat: Cln_Amount? = nil
    var _maxToUsMsat: Cln_Amount? = nil
    var _lastCommitmentTxid: Data? = nil
    var _lastCommitmentFeeMsat: Cln_Amount? = nil
    var _closeCause: Cln_ListclosedchannelsClosedchannels.ListclosedchannelsClosedchannelsClose_cause = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _peerID = source._peerID
      _channelID = source._channelID
      _shortChannelID = source._shortChannelID
      _alias = source._alias
      _opener = source._opener
      _closer = source._closer
      _private = source._private
      _totalLocalCommitments = source._totalLocalCommitments
      _totalRemoteCommitments = source._totalRemoteCommitments
      _totalHtlcsSent = source._totalHtlcsSent
      _fundingTxid = source._fundingTxid
      _fundingOutnum = source._fundingOutnum
      _leased = source._leased
      _fundingFeePaidMsat = source._fundingFeePaidMsat
      _fundingFeeRcvdMsat = source._fundingFeeRcvdMsat
      _fundingPushedMsat = source._fundingPushedMsat
      _totalMsat = source._totalMsat
      _finalToUsMsat = source._finalToUsMsat
      _minToUsMsat = source._minToUsMsat
      _maxToUsMsat = source._maxToUsMsat
      _lastCommitmentTxid = source._lastCommitmentTxid
      _lastCommitmentFeeMsat = source._lastCommitmentFeeMsat
      _closeCause = source._closeCause
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._peerID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._channelID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._shortChannelID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._alias) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._opener) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._closer) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalLocalCommitments) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalRemoteCommitments) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalHtlcsSent) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._fundingTxid) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._fundingOutnum) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._leased) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._fundingFeePaidMsat) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._fundingFeeRcvdMsat) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._fundingPushedMsat) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._totalMsat) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._finalToUsMsat) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._minToUsMsat) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._maxToUsMsat) }()
        case 22: try { try decoder.decodeSingularBytesField(value: &_storage._lastCommitmentTxid) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._lastCommitmentFeeMsat) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._closeCause) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._peerID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._channelID, fieldNumber: 2)
      }
      try { if let v = _storage._shortChannelID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._alias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._opener != .local {
        try visitor.visitSingularEnumField(value: _storage._opener, fieldNumber: 5)
      }
      try { if let v = _storage._closer {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 7)
      }
      if _storage._totalLocalCommitments != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalLocalCommitments, fieldNumber: 9)
      }
      if _storage._totalRemoteCommitments != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalRemoteCommitments, fieldNumber: 10)
      }
      if _storage._totalHtlcsSent != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalHtlcsSent, fieldNumber: 11)
      }
      if !_storage._fundingTxid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._fundingTxid, fieldNumber: 12)
      }
      if _storage._fundingOutnum != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fundingOutnum, fieldNumber: 13)
      }
      if _storage._leased != false {
        try visitor.visitSingularBoolField(value: _storage._leased, fieldNumber: 14)
      }
      try { if let v = _storage._fundingFeePaidMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._fundingFeeRcvdMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._fundingPushedMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._totalMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._finalToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._minToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._maxToUsMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._lastCommitmentTxid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._lastCommitmentFeeMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if _storage._closeCause != .unknown {
        try visitor.visitSingularEnumField(value: _storage._closeCause, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListclosedchannelsClosedchannels, rhs: Cln_ListclosedchannelsClosedchannels) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._peerID != rhs_storage._peerID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._shortChannelID != rhs_storage._shortChannelID {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._opener != rhs_storage._opener {return false}
        if _storage._closer != rhs_storage._closer {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._totalLocalCommitments != rhs_storage._totalLocalCommitments {return false}
        if _storage._totalRemoteCommitments != rhs_storage._totalRemoteCommitments {return false}
        if _storage._totalHtlcsSent != rhs_storage._totalHtlcsSent {return false}
        if _storage._fundingTxid != rhs_storage._fundingTxid {return false}
        if _storage._fundingOutnum != rhs_storage._fundingOutnum {return false}
        if _storage._leased != rhs_storage._leased {return false}
        if _storage._fundingFeePaidMsat != rhs_storage._fundingFeePaidMsat {return false}
        if _storage._fundingFeeRcvdMsat != rhs_storage._fundingFeeRcvdMsat {return false}
        if _storage._fundingPushedMsat != rhs_storage._fundingPushedMsat {return false}
        if _storage._totalMsat != rhs_storage._totalMsat {return false}
        if _storage._finalToUsMsat != rhs_storage._finalToUsMsat {return false}
        if _storage._minToUsMsat != rhs_storage._minToUsMsat {return false}
        if _storage._maxToUsMsat != rhs_storage._maxToUsMsat {return false}
        if _storage._lastCommitmentTxid != rhs_storage._lastCommitmentTxid {return false}
        if _storage._lastCommitmentFeeMsat != rhs_storage._lastCommitmentFeeMsat {return false}
        if _storage._closeCause != rhs_storage._closeCause {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListclosedchannelsClosedchannels.ListclosedchannelsClosedchannelsClose_cause: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "LOCAL"),
    2: .same(proto: "USER"),
    3: .same(proto: "REMOTE"),
    4: .same(proto: "PROTOCOL"),
    5: .same(proto: "ONCHAIN"),
  ]
}

extension Cln_ListclosedchannelsClosedchannelsAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListclosedchannelsClosedchannelsAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._local) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._remote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._local {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListclosedchannelsClosedchannelsAlias, rhs: Cln_ListclosedchannelsClosedchannelsAlias) -> Bool {
    if lhs._local != rhs._local {return false}
    if lhs._remote != rhs._remote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodepayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodepayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 1)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodepayRequest, rhs: Cln_DecodepayRequest) -> Bool {
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodepayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodepayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "expiry"),
    4: .same(proto: "payee"),
    5: .standard(proto: "amount_msat"),
    6: .standard(proto: "payment_hash"),
    7: .same(proto: "signature"),
    8: .same(proto: "description"),
    9: .standard(proto: "description_hash"),
    10: .standard(proto: "min_final_cltv_expiry"),
    11: .standard(proto: "payment_secret"),
    12: .same(proto: "features"),
    13: .standard(proto: "payment_metadata"),
    14: .same(proto: "fallbacks"),
    16: .same(proto: "extra"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expiry) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payee) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._descriptionHash) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.minFinalCltvExpiry) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self._paymentSecret) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self._features) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._paymentMetadata) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.fallbacks) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.extra) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 1)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 2)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiry, fieldNumber: 3)
    }
    if !self.payee.isEmpty {
      try visitor.visitSingularBytesField(value: self.payee, fieldNumber: 4)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 6)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 7)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._descriptionHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    if self.minFinalCltvExpiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.minFinalCltvExpiry, fieldNumber: 10)
    }
    try { if let v = self._paymentSecret {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._features {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._paymentMetadata {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    if !self.fallbacks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbacks, fieldNumber: 14)
    }
    if !self.extra.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extra, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodepayResponse, rhs: Cln_DecodepayResponse) -> Bool {
    if lhs.currency != rhs.currency {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.payee != rhs.payee {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._descriptionHash != rhs._descriptionHash {return false}
    if lhs.minFinalCltvExpiry != rhs.minFinalCltvExpiry {return false}
    if lhs._paymentSecret != rhs._paymentSecret {return false}
    if lhs._features != rhs._features {return false}
    if lhs._paymentMetadata != rhs._paymentMetadata {return false}
    if lhs.fallbacks != rhs.fallbacks {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodepayFallbacks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodepayFallbacks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "addr"),
    3: .same(proto: "hex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._addr) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.itemType != .p2Pkh {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try { if let v = self._addr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.hex.isEmpty {
      try visitor.visitSingularBytesField(value: self.hex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodepayFallbacks, rhs: Cln_DecodepayFallbacks) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs._addr != rhs._addr {return false}
    if lhs.hex != rhs.hex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodepayFallbacks.DecodepayFallbacksType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "P2PKH"),
    1: .same(proto: "P2SH"),
    2: .same(proto: "P2WPKH"),
    3: .same(proto: "P2WSH"),
  ]
}

extension Cln_DecodepayExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodepayExtra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodepayExtra, rhs: Cln_DecodepayExtra) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeRequest, rhs: Cln_DecodeRequest) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
    2: .same(proto: "valid"),
    3: .standard(proto: "offer_id"),
    4: .standard(proto: "offer_chains"),
    5: .standard(proto: "offer_metadata"),
    6: .standard(proto: "offer_currency"),
    7: .standard(proto: "warning_unknown_offer_currency"),
    8: .standard(proto: "currency_minor_unit"),
    9: .standard(proto: "offer_amount"),
    10: .standard(proto: "offer_amount_msat"),
    11: .standard(proto: "offer_description"),
    12: .standard(proto: "offer_issuer"),
    13: .standard(proto: "offer_features"),
    14: .standard(proto: "offer_absolute_expiry"),
    15: .standard(proto: "offer_quantity_max"),
    16: .standard(proto: "offer_paths"),
    17: .standard(proto: "offer_node_id"),
    20: .standard(proto: "warning_missing_offer_node_id"),
    21: .standard(proto: "warning_invalid_offer_description"),
    22: .standard(proto: "warning_missing_offer_description"),
    23: .standard(proto: "warning_invalid_offer_currency"),
    24: .standard(proto: "warning_invalid_offer_issuer"),
    25: .standard(proto: "invreq_metadata"),
    26: .standard(proto: "invreq_payer_id"),
    27: .standard(proto: "invreq_chain"),
    28: .standard(proto: "invreq_amount_msat"),
    29: .standard(proto: "invreq_features"),
    30: .standard(proto: "invreq_quantity"),
    31: .standard(proto: "invreq_payer_note"),
    32: .standard(proto: "invreq_recurrence_counter"),
    33: .standard(proto: "invreq_recurrence_start"),
    35: .standard(proto: "warning_missing_invreq_metadata"),
    36: .standard(proto: "warning_missing_invreq_payer_id"),
    37: .standard(proto: "warning_invalid_invreq_payer_note"),
    38: .standard(proto: "warning_missing_invoice_request_signature"),
    39: .standard(proto: "warning_invalid_invoice_request_signature"),
    41: .standard(proto: "invoice_created_at"),
    42: .standard(proto: "invoice_relative_expiry"),
    43: .standard(proto: "invoice_payment_hash"),
    44: .standard(proto: "invoice_amount_msat"),
    45: .standard(proto: "invoice_fallbacks"),
    46: .standard(proto: "invoice_features"),
    47: .standard(proto: "invoice_node_id"),
    48: .standard(proto: "invoice_recurrence_basetime"),
    50: .standard(proto: "warning_missing_invoice_paths"),
    51: .standard(proto: "warning_missing_invoice_blindedpay"),
    52: .standard(proto: "warning_missing_invoice_created_at"),
    53: .standard(proto: "warning_missing_invoice_payment_hash"),
    54: .standard(proto: "warning_missing_invoice_amount"),
    55: .standard(proto: "warning_missing_invoice_recurrence_basetime"),
    56: .standard(proto: "warning_missing_invoice_node_id"),
    57: .standard(proto: "warning_missing_invoice_signature"),
    58: .standard(proto: "warning_invalid_invoice_signature"),
    59: .same(proto: "fallbacks"),
    60: .standard(proto: "created_at"),
    61: .same(proto: "expiry"),
    62: .same(proto: "payee"),
    63: .standard(proto: "payment_hash"),
    64: .standard(proto: "description_hash"),
    65: .standard(proto: "min_final_cltv_expiry"),
    66: .standard(proto: "payment_secret"),
    67: .standard(proto: "payment_metadata"),
    69: .same(proto: "extra"),
    70: .standard(proto: "unique_id"),
    71: .same(proto: "version"),
    72: .same(proto: "string"),
    73: .same(proto: "restrictions"),
    74: .standard(proto: "warning_rune_invalid_utf8"),
    75: .same(proto: "hex"),
  ]

  fileprivate class _StorageClass {
    var _itemType: Cln_DecodeResponse.DecodeType = .bolt12Offer
    var _valid: Bool = false
    var _offerID: Data? = nil
    var _offerChains: [Data] = []
    var _offerMetadata: Data? = nil
    var _offerCurrency: String? = nil
    var _warningUnknownOfferCurrency: String? = nil
    var _currencyMinorUnit: UInt32? = nil
    var _offerAmount: UInt64? = nil
    var _offerAmountMsat: Cln_Amount? = nil
    var _offerDescription: String? = nil
    var _offerIssuer: String? = nil
    var _offerFeatures: Data? = nil
    var _offerAbsoluteExpiry: UInt64? = nil
    var _offerQuantityMax: UInt64? = nil
    var _offerPaths: [Cln_DecodeOffer_paths] = []
    var _offerNodeID: Data? = nil
    var _warningMissingOfferNodeID: String? = nil
    var _warningInvalidOfferDescription: String? = nil
    var _warningMissingOfferDescription: String? = nil
    var _warningInvalidOfferCurrency: String? = nil
    var _warningInvalidOfferIssuer: String? = nil
    var _invreqMetadata: Data? = nil
    var _invreqPayerID: Data? = nil
    var _invreqChain: Data? = nil
    var _invreqAmountMsat: Cln_Amount? = nil
    var _invreqFeatures: Data? = nil
    var _invreqQuantity: UInt64? = nil
    var _invreqPayerNote: String? = nil
    var _invreqRecurrenceCounter: UInt32? = nil
    var _invreqRecurrenceStart: UInt32? = nil
    var _warningMissingInvreqMetadata: String? = nil
    var _warningMissingInvreqPayerID: String? = nil
    var _warningInvalidInvreqPayerNote: String? = nil
    var _warningMissingInvoiceRequestSignature: String? = nil
    var _warningInvalidInvoiceRequestSignature: String? = nil
    var _invoiceCreatedAt: UInt64? = nil
    var _invoiceRelativeExpiry: UInt32? = nil
    var _invoicePaymentHash: Data? = nil
    var _invoiceAmountMsat: Cln_Amount? = nil
    var _invoiceFallbacks: [Cln_DecodeInvoice_fallbacks] = []
    var _invoiceFeatures: Data? = nil
    var _invoiceNodeID: Data? = nil
    var _invoiceRecurrenceBasetime: UInt64? = nil
    var _warningMissingInvoicePaths: String? = nil
    var _warningMissingInvoiceBlindedpay: String? = nil
    var _warningMissingInvoiceCreatedAt: String? = nil
    var _warningMissingInvoicePaymentHash: String? = nil
    var _warningMissingInvoiceAmount: String? = nil
    var _warningMissingInvoiceRecurrenceBasetime: String? = nil
    var _warningMissingInvoiceNodeID: String? = nil
    var _warningMissingInvoiceSignature: String? = nil
    var _warningInvalidInvoiceSignature: String? = nil
    var _fallbacks: [Cln_DecodeFallbacks] = []
    var _createdAt: UInt64? = nil
    var _expiry: UInt64? = nil
    var _payee: Data? = nil
    var _paymentHash: Data? = nil
    var _descriptionHash: Data? = nil
    var _minFinalCltvExpiry: UInt32? = nil
    var _paymentSecret: Data? = nil
    var _paymentMetadata: Data? = nil
    var _extra: [Cln_DecodeExtra] = []
    var _uniqueID: String? = nil
    var _version: String? = nil
    var _string: String? = nil
    var _restrictions: [Cln_DecodeRestrictions] = []
    var _warningRuneInvalidUtf8: String? = nil
    var _hex: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _itemType = source._itemType
      _valid = source._valid
      _offerID = source._offerID
      _offerChains = source._offerChains
      _offerMetadata = source._offerMetadata
      _offerCurrency = source._offerCurrency
      _warningUnknownOfferCurrency = source._warningUnknownOfferCurrency
      _currencyMinorUnit = source._currencyMinorUnit
      _offerAmount = source._offerAmount
      _offerAmountMsat = source._offerAmountMsat
      _offerDescription = source._offerDescription
      _offerIssuer = source._offerIssuer
      _offerFeatures = source._offerFeatures
      _offerAbsoluteExpiry = source._offerAbsoluteExpiry
      _offerQuantityMax = source._offerQuantityMax
      _offerPaths = source._offerPaths
      _offerNodeID = source._offerNodeID
      _warningMissingOfferNodeID = source._warningMissingOfferNodeID
      _warningInvalidOfferDescription = source._warningInvalidOfferDescription
      _warningMissingOfferDescription = source._warningMissingOfferDescription
      _warningInvalidOfferCurrency = source._warningInvalidOfferCurrency
      _warningInvalidOfferIssuer = source._warningInvalidOfferIssuer
      _invreqMetadata = source._invreqMetadata
      _invreqPayerID = source._invreqPayerID
      _invreqChain = source._invreqChain
      _invreqAmountMsat = source._invreqAmountMsat
      _invreqFeatures = source._invreqFeatures
      _invreqQuantity = source._invreqQuantity
      _invreqPayerNote = source._invreqPayerNote
      _invreqRecurrenceCounter = source._invreqRecurrenceCounter
      _invreqRecurrenceStart = source._invreqRecurrenceStart
      _warningMissingInvreqMetadata = source._warningMissingInvreqMetadata
      _warningMissingInvreqPayerID = source._warningMissingInvreqPayerID
      _warningInvalidInvreqPayerNote = source._warningInvalidInvreqPayerNote
      _warningMissingInvoiceRequestSignature = source._warningMissingInvoiceRequestSignature
      _warningInvalidInvoiceRequestSignature = source._warningInvalidInvoiceRequestSignature
      _invoiceCreatedAt = source._invoiceCreatedAt
      _invoiceRelativeExpiry = source._invoiceRelativeExpiry
      _invoicePaymentHash = source._invoicePaymentHash
      _invoiceAmountMsat = source._invoiceAmountMsat
      _invoiceFallbacks = source._invoiceFallbacks
      _invoiceFeatures = source._invoiceFeatures
      _invoiceNodeID = source._invoiceNodeID
      _invoiceRecurrenceBasetime = source._invoiceRecurrenceBasetime
      _warningMissingInvoicePaths = source._warningMissingInvoicePaths
      _warningMissingInvoiceBlindedpay = source._warningMissingInvoiceBlindedpay
      _warningMissingInvoiceCreatedAt = source._warningMissingInvoiceCreatedAt
      _warningMissingInvoicePaymentHash = source._warningMissingInvoicePaymentHash
      _warningMissingInvoiceAmount = source._warningMissingInvoiceAmount
      _warningMissingInvoiceRecurrenceBasetime = source._warningMissingInvoiceRecurrenceBasetime
      _warningMissingInvoiceNodeID = source._warningMissingInvoiceNodeID
      _warningMissingInvoiceSignature = source._warningMissingInvoiceSignature
      _warningInvalidInvoiceSignature = source._warningInvalidInvoiceSignature
      _fallbacks = source._fallbacks
      _createdAt = source._createdAt
      _expiry = source._expiry
      _payee = source._payee
      _paymentHash = source._paymentHash
      _descriptionHash = source._descriptionHash
      _minFinalCltvExpiry = source._minFinalCltvExpiry
      _paymentSecret = source._paymentSecret
      _paymentMetadata = source._paymentMetadata
      _extra = source._extra
      _uniqueID = source._uniqueID
      _version = source._version
      _string = source._string
      _restrictions = source._restrictions
      _warningRuneInvalidUtf8 = source._warningRuneInvalidUtf8
      _hex = source._hex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._itemType) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._valid) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._offerID) }()
        case 4: try { try decoder.decodeRepeatedBytesField(value: &_storage._offerChains) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._offerMetadata) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._offerCurrency) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._warningUnknownOfferCurrency) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._currencyMinorUnit) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._offerAmount) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._offerAmountMsat) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._offerDescription) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._offerIssuer) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._offerFeatures) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._offerAbsoluteExpiry) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._offerQuantityMax) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._offerPaths) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._offerNodeID) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingOfferNodeID) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidOfferDescription) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingOfferDescription) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidOfferCurrency) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidOfferIssuer) }()
        case 25: try { try decoder.decodeSingularBytesField(value: &_storage._invreqMetadata) }()
        case 26: try { try decoder.decodeSingularBytesField(value: &_storage._invreqPayerID) }()
        case 27: try { try decoder.decodeSingularBytesField(value: &_storage._invreqChain) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._invreqAmountMsat) }()
        case 29: try { try decoder.decodeSingularBytesField(value: &_storage._invreqFeatures) }()
        case 30: try { try decoder.decodeSingularUInt64Field(value: &_storage._invreqQuantity) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._invreqPayerNote) }()
        case 32: try { try decoder.decodeSingularUInt32Field(value: &_storage._invreqRecurrenceCounter) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._invreqRecurrenceStart) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvreqMetadata) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvreqPayerID) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidInvreqPayerNote) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceRequestSignature) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidInvoiceRequestSignature) }()
        case 41: try { try decoder.decodeSingularUInt64Field(value: &_storage._invoiceCreatedAt) }()
        case 42: try { try decoder.decodeSingularUInt32Field(value: &_storage._invoiceRelativeExpiry) }()
        case 43: try { try decoder.decodeSingularBytesField(value: &_storage._invoicePaymentHash) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._invoiceAmountMsat) }()
        case 45: try { try decoder.decodeRepeatedMessageField(value: &_storage._invoiceFallbacks) }()
        case 46: try { try decoder.decodeSingularBytesField(value: &_storage._invoiceFeatures) }()
        case 47: try { try decoder.decodeSingularBytesField(value: &_storage._invoiceNodeID) }()
        case 48: try { try decoder.decodeSingularUInt64Field(value: &_storage._invoiceRecurrenceBasetime) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoicePaths) }()
        case 51: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceBlindedpay) }()
        case 52: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceCreatedAt) }()
        case 53: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoicePaymentHash) }()
        case 54: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceAmount) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceRecurrenceBasetime) }()
        case 56: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceNodeID) }()
        case 57: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingInvoiceSignature) }()
        case 58: try { try decoder.decodeSingularStringField(value: &_storage._warningInvalidInvoiceSignature) }()
        case 59: try { try decoder.decodeRepeatedMessageField(value: &_storage._fallbacks) }()
        case 60: try { try decoder.decodeSingularUInt64Field(value: &_storage._createdAt) }()
        case 61: try { try decoder.decodeSingularUInt64Field(value: &_storage._expiry) }()
        case 62: try { try decoder.decodeSingularBytesField(value: &_storage._payee) }()
        case 63: try { try decoder.decodeSingularBytesField(value: &_storage._paymentHash) }()
        case 64: try { try decoder.decodeSingularBytesField(value: &_storage._descriptionHash) }()
        case 65: try { try decoder.decodeSingularUInt32Field(value: &_storage._minFinalCltvExpiry) }()
        case 66: try { try decoder.decodeSingularBytesField(value: &_storage._paymentSecret) }()
        case 67: try { try decoder.decodeSingularBytesField(value: &_storage._paymentMetadata) }()
        case 69: try { try decoder.decodeRepeatedMessageField(value: &_storage._extra) }()
        case 70: try { try decoder.decodeSingularStringField(value: &_storage._uniqueID) }()
        case 71: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 72: try { try decoder.decodeSingularStringField(value: &_storage._string) }()
        case 73: try { try decoder.decodeRepeatedMessageField(value: &_storage._restrictions) }()
        case 74: try { try decoder.decodeSingularStringField(value: &_storage._warningRuneInvalidUtf8) }()
        case 75: try { try decoder.decodeSingularBytesField(value: &_storage._hex) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._itemType != .bolt12Offer {
        try visitor.visitSingularEnumField(value: _storage._itemType, fieldNumber: 1)
      }
      if _storage._valid != false {
        try visitor.visitSingularBoolField(value: _storage._valid, fieldNumber: 2)
      }
      try { if let v = _storage._offerID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      if !_storage._offerChains.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._offerChains, fieldNumber: 4)
      }
      try { if let v = _storage._offerMetadata {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._offerCurrency {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._warningUnknownOfferCurrency {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currencyMinorUnit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._offerAmount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._offerAmountMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._offerDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._offerIssuer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._offerFeatures {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._offerAbsoluteExpiry {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._offerQuantityMax {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
      } }()
      if !_storage._offerPaths.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._offerPaths, fieldNumber: 16)
      }
      try { if let v = _storage._offerNodeID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._warningMissingOfferNodeID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._warningInvalidOfferDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._warningMissingOfferDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._warningInvalidOfferCurrency {
        try visitor.visitSingularStringField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._warningInvalidOfferIssuer {
        try visitor.visitSingularStringField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._invreqMetadata {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._invreqPayerID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._invreqChain {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._invreqAmountMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._invreqFeatures {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._invreqQuantity {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._invreqPayerNote {
        try visitor.visitSingularStringField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._invreqRecurrenceCounter {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._invreqRecurrenceStart {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._warningMissingInvreqMetadata {
        try visitor.visitSingularStringField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._warningMissingInvreqPayerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._warningInvalidInvreqPayerNote {
        try visitor.visitSingularStringField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._warningMissingInvoiceRequestSignature {
        try visitor.visitSingularStringField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._warningInvalidInvoiceRequestSignature {
        try visitor.visitSingularStringField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._invoiceCreatedAt {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._invoiceRelativeExpiry {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._invoicePaymentHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._invoiceAmountMsat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      if !_storage._invoiceFallbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._invoiceFallbacks, fieldNumber: 45)
      }
      try { if let v = _storage._invoiceFeatures {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._invoiceNodeID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._invoiceRecurrenceBasetime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._warningMissingInvoicePaths {
        try visitor.visitSingularStringField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._warningMissingInvoiceBlindedpay {
        try visitor.visitSingularStringField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._warningMissingInvoiceCreatedAt {
        try visitor.visitSingularStringField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._warningMissingInvoicePaymentHash {
        try visitor.visitSingularStringField(value: v, fieldNumber: 53)
      } }()
      try { if let v = _storage._warningMissingInvoiceAmount {
        try visitor.visitSingularStringField(value: v, fieldNumber: 54)
      } }()
      try { if let v = _storage._warningMissingInvoiceRecurrenceBasetime {
        try visitor.visitSingularStringField(value: v, fieldNumber: 55)
      } }()
      try { if let v = _storage._warningMissingInvoiceNodeID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 56)
      } }()
      try { if let v = _storage._warningMissingInvoiceSignature {
        try visitor.visitSingularStringField(value: v, fieldNumber: 57)
      } }()
      try { if let v = _storage._warningInvalidInvoiceSignature {
        try visitor.visitSingularStringField(value: v, fieldNumber: 58)
      } }()
      if !_storage._fallbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fallbacks, fieldNumber: 59)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._expiry {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._payee {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 62)
      } }()
      try { if let v = _storage._paymentHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 63)
      } }()
      try { if let v = _storage._descriptionHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 64)
      } }()
      try { if let v = _storage._minFinalCltvExpiry {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 65)
      } }()
      try { if let v = _storage._paymentSecret {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 66)
      } }()
      try { if let v = _storage._paymentMetadata {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 67)
      } }()
      if !_storage._extra.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._extra, fieldNumber: 69)
      }
      try { if let v = _storage._uniqueID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 70)
      } }()
      try { if let v = _storage._version {
        try visitor.visitSingularStringField(value: v, fieldNumber: 71)
      } }()
      try { if let v = _storage._string {
        try visitor.visitSingularStringField(value: v, fieldNumber: 72)
      } }()
      if !_storage._restrictions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._restrictions, fieldNumber: 73)
      }
      try { if let v = _storage._warningRuneInvalidUtf8 {
        try visitor.visitSingularStringField(value: v, fieldNumber: 74)
      } }()
      try { if let v = _storage._hex {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 75)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeResponse, rhs: Cln_DecodeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._itemType != rhs_storage._itemType {return false}
        if _storage._valid != rhs_storage._valid {return false}
        if _storage._offerID != rhs_storage._offerID {return false}
        if _storage._offerChains != rhs_storage._offerChains {return false}
        if _storage._offerMetadata != rhs_storage._offerMetadata {return false}
        if _storage._offerCurrency != rhs_storage._offerCurrency {return false}
        if _storage._warningUnknownOfferCurrency != rhs_storage._warningUnknownOfferCurrency {return false}
        if _storage._currencyMinorUnit != rhs_storage._currencyMinorUnit {return false}
        if _storage._offerAmount != rhs_storage._offerAmount {return false}
        if _storage._offerAmountMsat != rhs_storage._offerAmountMsat {return false}
        if _storage._offerDescription != rhs_storage._offerDescription {return false}
        if _storage._offerIssuer != rhs_storage._offerIssuer {return false}
        if _storage._offerFeatures != rhs_storage._offerFeatures {return false}
        if _storage._offerAbsoluteExpiry != rhs_storage._offerAbsoluteExpiry {return false}
        if _storage._offerQuantityMax != rhs_storage._offerQuantityMax {return false}
        if _storage._offerPaths != rhs_storage._offerPaths {return false}
        if _storage._offerNodeID != rhs_storage._offerNodeID {return false}
        if _storage._warningMissingOfferNodeID != rhs_storage._warningMissingOfferNodeID {return false}
        if _storage._warningInvalidOfferDescription != rhs_storage._warningInvalidOfferDescription {return false}
        if _storage._warningMissingOfferDescription != rhs_storage._warningMissingOfferDescription {return false}
        if _storage._warningInvalidOfferCurrency != rhs_storage._warningInvalidOfferCurrency {return false}
        if _storage._warningInvalidOfferIssuer != rhs_storage._warningInvalidOfferIssuer {return false}
        if _storage._invreqMetadata != rhs_storage._invreqMetadata {return false}
        if _storage._invreqPayerID != rhs_storage._invreqPayerID {return false}
        if _storage._invreqChain != rhs_storage._invreqChain {return false}
        if _storage._invreqAmountMsat != rhs_storage._invreqAmountMsat {return false}
        if _storage._invreqFeatures != rhs_storage._invreqFeatures {return false}
        if _storage._invreqQuantity != rhs_storage._invreqQuantity {return false}
        if _storage._invreqPayerNote != rhs_storage._invreqPayerNote {return false}
        if _storage._invreqRecurrenceCounter != rhs_storage._invreqRecurrenceCounter {return false}
        if _storage._invreqRecurrenceStart != rhs_storage._invreqRecurrenceStart {return false}
        if _storage._warningMissingInvreqMetadata != rhs_storage._warningMissingInvreqMetadata {return false}
        if _storage._warningMissingInvreqPayerID != rhs_storage._warningMissingInvreqPayerID {return false}
        if _storage._warningInvalidInvreqPayerNote != rhs_storage._warningInvalidInvreqPayerNote {return false}
        if _storage._warningMissingInvoiceRequestSignature != rhs_storage._warningMissingInvoiceRequestSignature {return false}
        if _storage._warningInvalidInvoiceRequestSignature != rhs_storage._warningInvalidInvoiceRequestSignature {return false}
        if _storage._invoiceCreatedAt != rhs_storage._invoiceCreatedAt {return false}
        if _storage._invoiceRelativeExpiry != rhs_storage._invoiceRelativeExpiry {return false}
        if _storage._invoicePaymentHash != rhs_storage._invoicePaymentHash {return false}
        if _storage._invoiceAmountMsat != rhs_storage._invoiceAmountMsat {return false}
        if _storage._invoiceFallbacks != rhs_storage._invoiceFallbacks {return false}
        if _storage._invoiceFeatures != rhs_storage._invoiceFeatures {return false}
        if _storage._invoiceNodeID != rhs_storage._invoiceNodeID {return false}
        if _storage._invoiceRecurrenceBasetime != rhs_storage._invoiceRecurrenceBasetime {return false}
        if _storage._warningMissingInvoicePaths != rhs_storage._warningMissingInvoicePaths {return false}
        if _storage._warningMissingInvoiceBlindedpay != rhs_storage._warningMissingInvoiceBlindedpay {return false}
        if _storage._warningMissingInvoiceCreatedAt != rhs_storage._warningMissingInvoiceCreatedAt {return false}
        if _storage._warningMissingInvoicePaymentHash != rhs_storage._warningMissingInvoicePaymentHash {return false}
        if _storage._warningMissingInvoiceAmount != rhs_storage._warningMissingInvoiceAmount {return false}
        if _storage._warningMissingInvoiceRecurrenceBasetime != rhs_storage._warningMissingInvoiceRecurrenceBasetime {return false}
        if _storage._warningMissingInvoiceNodeID != rhs_storage._warningMissingInvoiceNodeID {return false}
        if _storage._warningMissingInvoiceSignature != rhs_storage._warningMissingInvoiceSignature {return false}
        if _storage._warningInvalidInvoiceSignature != rhs_storage._warningInvalidInvoiceSignature {return false}
        if _storage._fallbacks != rhs_storage._fallbacks {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._expiry != rhs_storage._expiry {return false}
        if _storage._payee != rhs_storage._payee {return false}
        if _storage._paymentHash != rhs_storage._paymentHash {return false}
        if _storage._descriptionHash != rhs_storage._descriptionHash {return false}
        if _storage._minFinalCltvExpiry != rhs_storage._minFinalCltvExpiry {return false}
        if _storage._paymentSecret != rhs_storage._paymentSecret {return false}
        if _storage._paymentMetadata != rhs_storage._paymentMetadata {return false}
        if _storage._extra != rhs_storage._extra {return false}
        if _storage._uniqueID != rhs_storage._uniqueID {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._string != rhs_storage._string {return false}
        if _storage._restrictions != rhs_storage._restrictions {return false}
        if _storage._warningRuneInvalidUtf8 != rhs_storage._warningRuneInvalidUtf8 {return false}
        if _storage._hex != rhs_storage._hex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeResponse.DecodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOLT12_OFFER"),
    1: .same(proto: "BOLT12_INVOICE"),
    2: .same(proto: "BOLT12_INVOICE_REQUEST"),
    3: .same(proto: "BOLT11_INVOICE"),
    4: .same(proto: "RUNE"),
  ]
}

extension Cln_DecodeOffer_paths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeOffer_paths"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "first_node_id"),
    2: .same(proto: "blinding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.firstNodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blinding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.firstNodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.firstNodeID, fieldNumber: 1)
    }
    if !self.blinding.isEmpty {
      try visitor.visitSingularBytesField(value: self.blinding, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeOffer_paths, rhs: Cln_DecodeOffer_paths) -> Bool {
    if lhs.firstNodeID != rhs.firstNodeID {return false}
    if lhs.blinding != rhs.blinding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeOffer_recurrencePaywindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeOffer_recurrencePaywindow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seconds_before"),
    2: .standard(proto: "seconds_after"),
    3: .standard(proto: "proportional_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.secondsBefore) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.secondsAfter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._proportionalAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.secondsBefore != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsBefore, fieldNumber: 1)
    }
    if self.secondsAfter != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsAfter, fieldNumber: 2)
    }
    try { if let v = self._proportionalAmount {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeOffer_recurrencePaywindow, rhs: Cln_DecodeOffer_recurrencePaywindow) -> Bool {
    if lhs.secondsBefore != rhs.secondsBefore {return false}
    if lhs.secondsAfter != rhs.secondsAfter {return false}
    if lhs._proportionalAmount != rhs._proportionalAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeInvoice_pathsPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeInvoice_pathsPath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blinded_node_id"),
    2: .standard(proto: "encrypted_recipient_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.blindedNodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedRecipientData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blindedNodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.blindedNodeID, fieldNumber: 1)
    }
    if !self.encryptedRecipientData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedRecipientData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeInvoice_pathsPath, rhs: Cln_DecodeInvoice_pathsPath) -> Bool {
    if lhs.blindedNodeID != rhs.blindedNodeID {return false}
    if lhs.encryptedRecipientData != rhs.encryptedRecipientData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeInvoice_fallbacks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeInvoice_fallbacks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "hex"),
    3: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.hex.isEmpty {
      try visitor.visitSingularBytesField(value: self.hex, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeInvoice_fallbacks, rhs: Cln_DecodeInvoice_fallbacks) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.hex != rhs.hex {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeFallbacks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeFallbacks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "warning_invoice_fallbacks_version_invalid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._warningInvoiceFallbacksVersionInvalid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._warningInvoiceFallbacksVersionInvalid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeFallbacks, rhs: Cln_DecodeFallbacks) -> Bool {
    if lhs._warningInvoiceFallbacksVersionInvalid != rhs._warningInvoiceFallbacksVersionInvalid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeExtra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeExtra, rhs: Cln_DecodeExtra) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DecodeRestrictions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodeRestrictions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alternatives"),
    2: .same(proto: "summary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.alternatives) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alternatives.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alternatives, fieldNumber: 1)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DecodeRestrictions, rhs: Cln_DecodeRestrictions) -> Bool {
    if lhs.alternatives != rhs.alternatives {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._force) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._force {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DisconnectRequest, rhs: Cln_DisconnectRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._force != rhs._force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_DisconnectResponse, rhs: Cln_DisconnectResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .perkb {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesRequest, rhs: Cln_FeeratesRequest) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesRequest.FeeratesStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERKB"),
    1: .same(proto: "PERKW"),
  ]
}

extension Cln_FeeratesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "warning_missing_feerates"),
    2: .same(proto: "perkb"),
    3: .same(proto: "perkw"),
    4: .standard(proto: "onchain_fee_estimates"),
  ]

  fileprivate class _StorageClass {
    var _warningMissingFeerates: String? = nil
    var _perkb: Cln_FeeratesPerkb? = nil
    var _perkw: Cln_FeeratesPerkw? = nil
    var _onchainFeeEstimates: Cln_FeeratesOnchain_fee_estimates? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _warningMissingFeerates = source._warningMissingFeerates
      _perkb = source._perkb
      _perkw = source._perkw
      _onchainFeeEstimates = source._onchainFeeEstimates
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._warningMissingFeerates) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._perkb) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._perkw) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._onchainFeeEstimates) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._warningMissingFeerates {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._perkb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._perkw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._onchainFeeEstimates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesResponse, rhs: Cln_FeeratesResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._warningMissingFeerates != rhs_storage._warningMissingFeerates {return false}
        if _storage._perkb != rhs_storage._perkb {return false}
        if _storage._perkw != rhs_storage._perkw {return false}
        if _storage._onchainFeeEstimates != rhs_storage._onchainFeeEstimates {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesPerkb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesPerkb"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_acceptable"),
    2: .standard(proto: "max_acceptable"),
    10: .same(proto: "floor"),
    9: .same(proto: "estimates"),
    3: .same(proto: "opening"),
    4: .standard(proto: "mutual_close"),
    5: .standard(proto: "unilateral_close"),
    11: .standard(proto: "unilateral_anchor_close"),
    6: .standard(proto: "delayed_to_us"),
    7: .standard(proto: "htlc_resolution"),
    8: .same(proto: "penalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minAcceptable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxAcceptable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._opening) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mutualClose) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._unilateralClose) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._delayedToUs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._htlcResolution) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._penalty) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.estimates) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._floor) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._unilateralAnchorClose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minAcceptable != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAcceptable, fieldNumber: 1)
    }
    if self.maxAcceptable != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAcceptable, fieldNumber: 2)
    }
    try { if let v = self._opening {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mutualClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unilateralClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._delayedToUs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._htlcResolution {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._penalty {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    if !self.estimates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.estimates, fieldNumber: 9)
    }
    try { if let v = self._floor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._unilateralAnchorClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesPerkb, rhs: Cln_FeeratesPerkb) -> Bool {
    if lhs.minAcceptable != rhs.minAcceptable {return false}
    if lhs.maxAcceptable != rhs.maxAcceptable {return false}
    if lhs._floor != rhs._floor {return false}
    if lhs.estimates != rhs.estimates {return false}
    if lhs._opening != rhs._opening {return false}
    if lhs._mutualClose != rhs._mutualClose {return false}
    if lhs._unilateralClose != rhs._unilateralClose {return false}
    if lhs._unilateralAnchorClose != rhs._unilateralAnchorClose {return false}
    if lhs._delayedToUs != rhs._delayedToUs {return false}
    if lhs._htlcResolution != rhs._htlcResolution {return false}
    if lhs._penalty != rhs._penalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesPerkbEstimates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesPerkbEstimates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockcount"),
    2: .same(proto: "feerate"),
    3: .standard(proto: "smoothed_feerate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._blockcount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._smoothedFeerate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockcount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._smoothedFeerate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesPerkbEstimates, rhs: Cln_FeeratesPerkbEstimates) -> Bool {
    if lhs._blockcount != rhs._blockcount {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._smoothedFeerate != rhs._smoothedFeerate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesPerkw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesPerkw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_acceptable"),
    2: .standard(proto: "max_acceptable"),
    10: .same(proto: "floor"),
    9: .same(proto: "estimates"),
    3: .same(proto: "opening"),
    4: .standard(proto: "mutual_close"),
    5: .standard(proto: "unilateral_close"),
    11: .standard(proto: "unilateral_anchor_close"),
    6: .standard(proto: "delayed_to_us"),
    7: .standard(proto: "htlc_resolution"),
    8: .same(proto: "penalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minAcceptable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxAcceptable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._opening) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mutualClose) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._unilateralClose) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._delayedToUs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._htlcResolution) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._penalty) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.estimates) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._floor) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._unilateralAnchorClose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minAcceptable != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAcceptable, fieldNumber: 1)
    }
    if self.maxAcceptable != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAcceptable, fieldNumber: 2)
    }
    try { if let v = self._opening {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mutualClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unilateralClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._delayedToUs {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._htlcResolution {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._penalty {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    if !self.estimates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.estimates, fieldNumber: 9)
    }
    try { if let v = self._floor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._unilateralAnchorClose {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesPerkw, rhs: Cln_FeeratesPerkw) -> Bool {
    if lhs.minAcceptable != rhs.minAcceptable {return false}
    if lhs.maxAcceptable != rhs.maxAcceptable {return false}
    if lhs._floor != rhs._floor {return false}
    if lhs.estimates != rhs.estimates {return false}
    if lhs._opening != rhs._opening {return false}
    if lhs._mutualClose != rhs._mutualClose {return false}
    if lhs._unilateralClose != rhs._unilateralClose {return false}
    if lhs._unilateralAnchorClose != rhs._unilateralAnchorClose {return false}
    if lhs._delayedToUs != rhs._delayedToUs {return false}
    if lhs._htlcResolution != rhs._htlcResolution {return false}
    if lhs._penalty != rhs._penalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesPerkwEstimates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesPerkwEstimates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockcount"),
    2: .same(proto: "feerate"),
    3: .standard(proto: "smoothed_feerate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._blockcount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._smoothedFeerate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockcount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._smoothedFeerate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesPerkwEstimates, rhs: Cln_FeeratesPerkwEstimates) -> Bool {
    if lhs._blockcount != rhs._blockcount {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._smoothedFeerate != rhs._smoothedFeerate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FeeratesOnchain_fee_estimates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeratesOnchain_fee_estimates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opening_channel_satoshis"),
    2: .standard(proto: "mutual_close_satoshis"),
    3: .standard(proto: "unilateral_close_satoshis"),
    6: .standard(proto: "unilateral_close_nonanchor_satoshis"),
    4: .standard(proto: "htlc_timeout_satoshis"),
    5: .standard(proto: "htlc_success_satoshis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.openingChannelSatoshis) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mutualCloseSatoshis) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.unilateralCloseSatoshis) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.htlcTimeoutSatoshis) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.htlcSuccessSatoshis) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._unilateralCloseNonanchorSatoshis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.openingChannelSatoshis != 0 {
      try visitor.visitSingularUInt64Field(value: self.openingChannelSatoshis, fieldNumber: 1)
    }
    if self.mutualCloseSatoshis != 0 {
      try visitor.visitSingularUInt64Field(value: self.mutualCloseSatoshis, fieldNumber: 2)
    }
    if self.unilateralCloseSatoshis != 0 {
      try visitor.visitSingularUInt64Field(value: self.unilateralCloseSatoshis, fieldNumber: 3)
    }
    if self.htlcTimeoutSatoshis != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcTimeoutSatoshis, fieldNumber: 4)
    }
    if self.htlcSuccessSatoshis != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcSuccessSatoshis, fieldNumber: 5)
    }
    try { if let v = self._unilateralCloseNonanchorSatoshis {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FeeratesOnchain_fee_estimates, rhs: Cln_FeeratesOnchain_fee_estimates) -> Bool {
    if lhs.openingChannelSatoshis != rhs.openingChannelSatoshis {return false}
    if lhs.mutualCloseSatoshis != rhs.mutualCloseSatoshis {return false}
    if lhs.unilateralCloseSatoshis != rhs.unilateralCloseSatoshis {return false}
    if lhs._unilateralCloseNonanchorSatoshis != rhs._unilateralCloseNonanchorSatoshis {return false}
    if lhs.htlcTimeoutSatoshis != rhs.htlcTimeoutSatoshis {return false}
    if lhs.htlcSuccessSatoshis != rhs.htlcSuccessSatoshis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FundchannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundchannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "amount"),
    2: .same(proto: "feerate"),
    3: .same(proto: "announce"),
    10: .same(proto: "minconf"),
    5: .standard(proto: "push_msat"),
    6: .standard(proto: "close_to"),
    7: .standard(proto: "request_amt"),
    8: .standard(proto: "compact_lease"),
    11: .same(proto: "utxos"),
    12: .same(proto: "mindepth"),
    13: .same(proto: "reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feerate) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._announce) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pushMsat) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._closeTo) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._requestAmt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._compactLease) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._minconf) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._mindepth) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._reserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feerate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._announce {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pushMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._closeTo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._requestAmt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._compactLease {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 9)
    }
    try { if let v = self._minconf {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 11)
    }
    try { if let v = self._mindepth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._reserve {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FundchannelRequest, rhs: Cln_FundchannelRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._feerate != rhs._feerate {return false}
    if lhs._announce != rhs._announce {return false}
    if lhs._minconf != rhs._minconf {return false}
    if lhs._pushMsat != rhs._pushMsat {return false}
    if lhs._closeTo != rhs._closeTo {return false}
    if lhs._requestAmt != rhs._requestAmt {return false}
    if lhs._compactLease != rhs._compactLease {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs._mindepth != rhs._mindepth {return false}
    if lhs._reserve != rhs._reserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_FundchannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundchannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "txid"),
    3: .same(proto: "outnum"),
    4: .standard(proto: "channel_id"),
    5: .standard(proto: "close_to"),
    6: .same(proto: "mindepth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.outnum) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.channelID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._closeTo) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mindepth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    if self.outnum != 0 {
      try visitor.visitSingularUInt32Field(value: self.outnum, fieldNumber: 3)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 4)
    }
    try { if let v = self._closeTo {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._mindepth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_FundchannelResponse, rhs: Cln_FundchannelResponse) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.outnum != rhs.outnum {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._closeTo != rhs._closeTo {return false}
    if lhs._mindepth != rhs._mindepth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetrouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetrouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    9: .standard(proto: "amount_msat"),
    3: .same(proto: "riskfactor"),
    4: .same(proto: "cltv"),
    5: .same(proto: "fromid"),
    6: .same(proto: "fuzzpercent"),
    7: .same(proto: "exclude"),
    8: .same(proto: "maxhops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.riskfactor) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._cltv) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._fromid) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._fuzzpercent) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.exclude) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._maxhops) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.riskfactor != 0 {
      try visitor.visitSingularUInt64Field(value: self.riskfactor, fieldNumber: 3)
    }
    try { if let v = self._cltv {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fromid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._fuzzpercent {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    if !self.exclude.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclude, fieldNumber: 7)
    }
    try { if let v = self._maxhops {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetrouteRequest, rhs: Cln_GetrouteRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.riskfactor != rhs.riskfactor {return false}
    if lhs._cltv != rhs._cltv {return false}
    if lhs._fromid != rhs._fromid {return false}
    if lhs._fuzzpercent != rhs._fuzzpercent {return false}
    if lhs.exclude != rhs.exclude {return false}
    if lhs._maxhops != rhs._maxhops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetrouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetrouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.route, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetrouteResponse, rhs: Cln_GetrouteResponse) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetrouteRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetrouteRoute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "channel"),
    3: .same(proto: "direction"),
    4: .standard(proto: "amount_msat"),
    5: .same(proto: "delay"),
    6: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.delay) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 2)
    }
    if self.direction != 0 {
      try visitor.visitSingularUInt32Field(value: self.direction, fieldNumber: 3)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.delay != 0 {
      try visitor.visitSingularUInt32Field(value: self.delay, fieldNumber: 5)
    }
    if self.style != .tlv {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_GetrouteRoute, rhs: Cln_GetrouteRoute) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_GetrouteRoute.GetrouteRouteStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TLV"),
  ]
}

extension Cln_ListforwardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListforwardsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "in_channel"),
    3: .standard(proto: "out_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._inChannel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._outChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inChannel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outChannel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListforwardsRequest, rhs: Cln_ListforwardsRequest) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._inChannel != rhs._inChannel {return false}
    if lhs._outChannel != rhs._outChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListforwardsRequest.ListforwardsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFFERED"),
    1: .same(proto: "SETTLED"),
    2: .same(proto: "LOCAL_FAILED"),
    3: .same(proto: "FAILED"),
  ]
}

extension Cln_ListforwardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListforwardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forwards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.forwards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forwards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListforwardsResponse, rhs: Cln_ListforwardsResponse) -> Bool {
    if lhs.forwards != rhs.forwards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListforwardsForwards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListforwardsForwards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "in_channel"),
    10: .standard(proto: "in_htlc_id"),
    2: .standard(proto: "in_msat"),
    3: .same(proto: "status"),
    4: .standard(proto: "received_time"),
    5: .standard(proto: "out_channel"),
    11: .standard(proto: "out_htlc_id"),
    9: .same(proto: "style"),
    7: .standard(proto: "fee_msat"),
    8: .standard(proto: "out_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inChannel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inMsat) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.receivedTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._outChannel) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._feeMsat) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._outMsat) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._style) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._inHtlcID) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._outHtlcID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.inChannel, fieldNumber: 1)
    }
    try { if let v = self._inMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.status != .offered {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.receivedTime != 0 {
      try visitor.visitSingularDoubleField(value: self.receivedTime, fieldNumber: 4)
    }
    try { if let v = self._outChannel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._feeMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._outMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._inHtlcID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._outHtlcID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListforwardsForwards, rhs: Cln_ListforwardsForwards) -> Bool {
    if lhs.inChannel != rhs.inChannel {return false}
    if lhs._inHtlcID != rhs._inHtlcID {return false}
    if lhs._inMsat != rhs._inMsat {return false}
    if lhs.status != rhs.status {return false}
    if lhs.receivedTime != rhs.receivedTime {return false}
    if lhs._outChannel != rhs._outChannel {return false}
    if lhs._outHtlcID != rhs._outHtlcID {return false}
    if lhs._style != rhs._style {return false}
    if lhs._feeMsat != rhs._feeMsat {return false}
    if lhs._outMsat != rhs._outMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListforwardsForwards.ListforwardsForwardsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFFERED"),
    1: .same(proto: "SETTLED"),
    2: .same(proto: "LOCAL_FAILED"),
    3: .same(proto: "FAILED"),
  ]
}

extension Cln_ListforwardsForwards.ListforwardsForwardsStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEGACY"),
    1: .same(proto: "TLV"),
  ]
}

extension Cln_ListpaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpaysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
    2: .standard(proto: "payment_hash"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._paymentHash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paymentHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpaysRequest, rhs: Cln_ListpaysRequest) -> Bool {
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._paymentHash != rhs._paymentHash {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpaysRequest.ListpaysStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETE"),
    2: .same(proto: "FAILED"),
  ]
}

extension Cln_ListpaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pays"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pays) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pays.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pays, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpaysResponse, rhs: Cln_ListpaysResponse) -> Bool {
    if lhs.pays != rhs.pays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpaysPays: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListpaysPays"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .same(proto: "status"),
    3: .same(proto: "destination"),
    4: .standard(proto: "created_at"),
    12: .standard(proto: "completed_at"),
    5: .same(proto: "label"),
    6: .same(proto: "bolt11"),
    11: .same(proto: "description"),
    7: .same(proto: "bolt12"),
    8: .standard(proto: "amount_msat"),
    9: .standard(proto: "amount_sent_msat"),
    13: .same(proto: "preimage"),
    14: .standard(proto: "number_of_parts"),
    10: .same(proto: "erroronion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._bolt12) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._amountSentMsat) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self._erroronion) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self._completedAt) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self._preimage) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self._numberOfParts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 4)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._bolt12 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._amountSentMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._erroronion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._completedAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._preimage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._numberOfParts {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListpaysPays, rhs: Cln_ListpaysPays) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs._label != rhs._label {return false}
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._bolt12 != rhs._bolt12 {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs._amountSentMsat != rhs._amountSentMsat {return false}
    if lhs._preimage != rhs._preimage {return false}
    if lhs._numberOfParts != rhs._numberOfParts {return false}
    if lhs._erroronion != rhs._erroronion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListpaysPays.ListpaysPaysStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "COMPLETE"),
  ]
}

extension Cln_ListhtlcsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListhtlcsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListhtlcsRequest, rhs: Cln_ListhtlcsRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListhtlcsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListhtlcsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "htlcs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.htlcs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.htlcs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.htlcs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListhtlcsResponse, rhs: Cln_ListhtlcsResponse) -> Bool {
    if lhs.htlcs != rhs.htlcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListhtlcsHtlcs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListhtlcsHtlcs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_channel_id"),
    2: .same(proto: "id"),
    3: .same(proto: "expiry"),
    4: .standard(proto: "amount_msat"),
    5: .same(proto: "direction"),
    6: .standard(proto: "payment_hash"),
    7: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shortChannelID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.expiry) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shortChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.shortChannelID, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 3)
    }
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.direction != .out {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 5)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 6)
    }
    if self.state != .sentAddHtlc {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_ListhtlcsHtlcs, rhs: Cln_ListhtlcsHtlcs) -> Bool {
    if lhs.shortChannelID != rhs.shortChannelID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_ListhtlcsHtlcs.ListhtlcsHtlcsDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUT"),
    1: .same(proto: "IN"),
  ]
}

extension Cln_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "len"),
    3: .same(proto: "pongbytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._len) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pongbytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._len {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pongbytes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PingRequest, rhs: Cln_PingRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._len != rhs._len {return false}
    if lhs._pongbytes != rhs._pongbytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totlen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totlen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totlen != 0 {
      try visitor.visitSingularUInt32Field(value: self.totlen, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PingResponse, rhs: Cln_PingResponse) -> Bool {
    if lhs.totlen != rhs.totlen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendcustommsgRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendcustommsgRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendcustommsgRequest, rhs: Cln_SendcustommsgRequest) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SendcustommsgResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendcustommsgResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SendcustommsgResponse, rhs: Cln_SendcustommsgResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SetchannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetchannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "feebase"),
    3: .same(proto: "feeppm"),
    4: .same(proto: "htlcmin"),
    5: .same(proto: "htlcmax"),
    6: .same(proto: "enforcedelay"),
    7: .same(proto: "ignorefeelimits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feebase) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._feeppm) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._htlcmin) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._htlcmax) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._enforcedelay) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._ignorefeelimits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._feebase {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feeppm {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._htlcmin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._htlcmax {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._enforcedelay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._ignorefeelimits {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SetchannelRequest, rhs: Cln_SetchannelRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._feebase != rhs._feebase {return false}
    if lhs._feeppm != rhs._feeppm {return false}
    if lhs._htlcmin != rhs._htlcmin {return false}
    if lhs._htlcmax != rhs._htlcmax {return false}
    if lhs._enforcedelay != rhs._enforcedelay {return false}
    if lhs._ignorefeelimits != rhs._ignorefeelimits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SetchannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetchannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SetchannelResponse, rhs: Cln_SetchannelResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SetchannelChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetchannelChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "short_channel_id"),
    4: .standard(proto: "fee_base_msat"),
    5: .standard(proto: "fee_proportional_millionths"),
    10: .standard(proto: "ignore_fee_limits"),
    6: .standard(proto: "minimum_htlc_out_msat"),
    7: .standard(proto: "warning_htlcmin_too_low"),
    8: .standard(proto: "maximum_htlc_out_msat"),
    9: .standard(proto: "warning_htlcmax_too_high"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._shortChannelID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._feeBaseMsat) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.feeProportionalMillionths) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._minimumHtlcOutMsat) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._warningHtlcminTooLow) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._maximumHtlcOutMsat) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._warningHtlcmaxTooHigh) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._ignoreFeeLimits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.peerID.isEmpty {
      try visitor.visitSingularBytesField(value: self.peerID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 2)
    }
    try { if let v = self._shortChannelID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._feeBaseMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.feeProportionalMillionths != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeProportionalMillionths, fieldNumber: 5)
    }
    try { if let v = self._minimumHtlcOutMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._warningHtlcminTooLow {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._maximumHtlcOutMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._warningHtlcmaxTooHigh {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._ignoreFeeLimits {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SetchannelChannels, rhs: Cln_SetchannelChannels) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._shortChannelID != rhs._shortChannelID {return false}
    if lhs._feeBaseMsat != rhs._feeBaseMsat {return false}
    if lhs.feeProportionalMillionths != rhs.feeProportionalMillionths {return false}
    if lhs._ignoreFeeLimits != rhs._ignoreFeeLimits {return false}
    if lhs._minimumHtlcOutMsat != rhs._minimumHtlcOutMsat {return false}
    if lhs._warningHtlcminTooLow != rhs._warningHtlcminTooLow {return false}
    if lhs._maximumHtlcOutMsat != rhs._maximumHtlcOutMsat {return false}
    if lhs._warningHtlcmaxTooHigh != rhs._warningHtlcmaxTooHigh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SigninvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigninvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invstring"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.invstring) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invstring.isEmpty {
      try visitor.visitSingularStringField(value: self.invstring, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SigninvoiceRequest, rhs: Cln_SigninvoiceRequest) -> Bool {
    if lhs.invstring != rhs.invstring {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SigninvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigninvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bolt11) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bolt11.isEmpty {
      try visitor.visitSingularStringField(value: self.bolt11, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SigninvoiceResponse, rhs: Cln_SigninvoiceResponse) -> Bool {
    if lhs.bolt11 != rhs.bolt11 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SignmessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignmessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SignmessageRequest, rhs: Cln_SignmessageRequest) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_SignmessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignmessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "recid"),
    3: .same(proto: "zbase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.recid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.zbase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.recid.isEmpty {
      try visitor.visitSingularBytesField(value: self.recid, fieldNumber: 2)
    }
    if !self.zbase.isEmpty {
      try visitor.visitSingularStringField(value: self.zbase, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_SignmessageResponse, rhs: Cln_SignmessageResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.recid != rhs.recid {return false}
    if lhs.zbase != rhs.zbase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_StopRequest, rhs: Cln_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_StopResponse, rhs: Cln_StopResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PreapprovekeysendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreapprovekeysendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "payment_hash"),
    3: .standard(proto: "amount_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._paymentHash) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paymentHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amountMsat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PreapprovekeysendRequest, rhs: Cln_PreapprovekeysendRequest) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs._paymentHash != rhs._paymentHash {return false}
    if lhs._amountMsat != rhs._amountMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PreapprovekeysendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreapprovekeysendResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PreapprovekeysendResponse, rhs: Cln_PreapprovekeysendResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PreapproveinvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreapproveinvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bolt11"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bolt11) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bolt11 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PreapproveinvoiceRequest, rhs: Cln_PreapproveinvoiceRequest) -> Bool {
    if lhs._bolt11 != rhs._bolt11 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_PreapproveinvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreapproveinvoiceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_PreapproveinvoiceResponse, rhs: Cln_PreapproveinvoiceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_StaticbackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticbackupRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_StaticbackupRequest, rhs: Cln_StaticbackupRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cln_StaticbackupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticbackupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.scb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scb.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.scb, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cln_StaticbackupResponse, rhs: Cln_StaticbackupResponse) -> Bool {
    if lhs.scb != rhs.scb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
